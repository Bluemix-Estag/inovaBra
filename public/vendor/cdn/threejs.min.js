! function (e, t) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) {
        if (!e.document) throw new Error("jQuery requires a window with a document");
        return t(e)
    } : t(e)
}("undefined" != typeof window ? window : this, function (e, t) {
    function n(e) {
        var t = "length" in e && e.length,
            n = Z.type(e);
        return "function" === n || Z.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e
    }

    function r(e, t, n) {
        if (Z.isFunction(t)) return Z.grep(e, function (e, r) {
            return !!t.call(e, r, e) !== n
        });
        if (t.nodeType) return Z.grep(e, function (e) {
            return e === t !== n
        });
        if ("string" == typeof t) {
            if (at.test(t)) return Z.filter(t, e, n);
            t = Z.filter(t, e)
        }
        return Z.grep(e, function (e) {
            return U.call(t, e) >= 0 !== n
        })
    }

    function i(e, t) {
        for (;
            (e = e[t]) && 1 !== e.nodeType;);
        return e
    }

    function o(e) {
        var t = ht[e] = {};
        return Z.each(e.match(dt) || [], function (e, n) {
            t[n] = !0
        }), t
    }

    function s() {
        J.removeEventListener("DOMContentLoaded", s, !1), e.removeEventListener("load", s, !1), Z.ready()
    }

    function a() {
        Object.defineProperty(this.cache = {}, 0, {
            get: function () {
                return {}
            }
        }), this.expando = Z.expando + a.uid++
    }

    function u(e, t, n) {
        var r;
        if (void 0 === n && 1 === e.nodeType)
            if (r = "data-" + t.replace(bt, "-$1").toLowerCase(), n = e.getAttribute(r), "string" == typeof n) {
                try {
                    n = "true" === n ? !0 : "false" === n ? !1 : "null" === n ? null : +n + "" === n ? +n : xt.test(n) ? Z.parseJSON(n) : n
                } catch (i) {}
                yt.set(e, t, n)
            } else n = void 0;
        return n
    }

    function l() {
        return !0
    }

    function c() {
        return !1
    }

    function f() {
        try {
            return J.activeElement
        } catch (e) {}
    }

    function p(e, t) {
        return Z.nodeName(e, "table") && Z.nodeName(11 !== t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
    }

    function d(e) {
        return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
    }

    function h(e) {
        var t = Pt.exec(e.type);
        return t ? e.type = t[1] : e.removeAttribute("type"), e
    }

    function g(e, t) {
        for (var n = 0, r = e.length; r > n; n++) vt.set(e[n], "globalEval", !t || vt.get(t[n], "globalEval"))
    }

    function m(e, t) {
        var n, r, i, o, s, a, u, l;
        if (1 === t.nodeType) {
            if (vt.hasData(e) && (o = vt.access(e), s = vt.set(t, o), l = o.events)) {
                delete s.handle, s.events = {};
                for (i in l)
                    for (n = 0, r = l[i].length; r > n; n++) Z.event.add(t, i, l[i][n])
            }
            yt.hasData(e) && (a = yt.access(e), u = Z.extend({}, a), yt.set(t, u))
        }
    }

    function v(e, t) {
        var n = e.getElementsByTagName ? e.getElementsByTagName(t || "*") : e.querySelectorAll ? e.querySelectorAll(t || "*") : [];
        return void 0 === t || t && Z.nodeName(e, t) ? Z.merge([e], n) : n
    }

    function y(e, t) {
        var n = t.nodeName.toLowerCase();
        "input" === n && Nt.test(e.type) ? t.checked = e.checked : ("input" === n || "textarea" === n) && (t.defaultValue = e.defaultValue)
    }

    function x(t, n) {
        var r, i = Z(n.createElement(t)).appendTo(n.body),
            o = e.getDefaultComputedStyle && (r = e.getDefaultComputedStyle(i[0])) ? r.display : Z.css(i[0], "display");
        return i.detach(), o
    }

    function b(e) {
        var t = J,
            n = $t[e];
        return n || (n = x(e, t), "none" !== n && n || (Wt = (Wt || Z("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement), t = Wt[0].contentDocument, t.write(), t.close(), n = x(e, t), Wt.detach()), $t[e] = n), n
    }

    function w(e, t, n) {
        var r, i, o, s, a = e.style;
        return n = n || _t(e), n && (s = n.getPropertyValue(t) || n[t]), n && ("" !== s || Z.contains(e.ownerDocument, e) || (s = Z.style(e, t)), Bt.test(s) && It.test(t) && (r = a.width, i = a.minWidth, o = a.maxWidth, a.minWidth = a.maxWidth = a.width = s, s = n.width, a.width = r, a.minWidth = i, a.maxWidth = o)), void 0 !== s ? s + "" : s
    }

    function T(e, t) {
        return {
            get: function () {
                return e() ? void delete this.get : (this.get = t).apply(this, arguments)
            }
        }
    }

    function C(e, t) {
        if (t in e) return t;
        for (var n = t[0].toUpperCase() + t.slice(1), r = t, i = Gt.length; i--;)
            if (t = Gt[i] + n, t in e) return t;
        return r
    }

    function N(e, t, n) {
        var r = Xt.exec(t);
        return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t
    }

    function k(e, t, n, r, i) {
        for (var o = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0, s = 0; 4 > o; o += 2) "margin" === n && (s += Z.css(e, n + Tt[o], !0, i)), r ? ("content" === n && (s -= Z.css(e, "padding" + Tt[o], !0, i)), "margin" !== n && (s -= Z.css(e, "border" + Tt[o] + "Width", !0, i))) : (s += Z.css(e, "padding" + Tt[o], !0, i), "padding" !== n && (s += Z.css(e, "border" + Tt[o] + "Width", !0, i)));
        return s
    }

    function E(e, t, n) {
        var r = !0,
            i = "width" === t ? e.offsetWidth : e.offsetHeight,
            o = _t(e),
            s = "border-box" === Z.css(e, "boxSizing", !1, o);
        if (0 >= i || null == i) {
            if (i = w(e, t, o), (0 > i || null == i) && (i = e.style[t]), Bt.test(i)) return i;
            r = s && (Q.boxSizingReliable() || i === e.style[t]), i = parseFloat(i) || 0
        }
        return i + k(e, t, n || (s ? "border" : "content"), r, o) + "px"
    }

    function S(e, t) {
        for (var n, r, i, o = [], s = 0, a = e.length; a > s; s++) r = e[s], r.style && (o[s] = vt.get(r, "olddisplay"), n = r.style.display, t ? (o[s] || "none" !== n || (r.style.display = ""), "" === r.style.display && Ct(r) && (o[s] = vt.access(r, "olddisplay", b(r.nodeName)))) : (i = Ct(r), "none" === n && i || vt.set(r, "olddisplay", i ? n : Z.css(r, "display"))));
        for (s = 0; a > s; s++) r = e[s], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? o[s] || "" : "none"));
        return e
    }

    function D(e, t, n, r, i) {
        return new D.prototype.init(e, t, n, r, i)
    }

    function j() {
        return setTimeout(function () {
            Qt = void 0
        }), Qt = Z.now()
    }

    function A(e, t) {
        var n, r = 0,
            i = {
                height: e
            };
        for (t = t ? 1 : 0; 4 > r; r += 2 - t) n = Tt[r], i["margin" + n] = i["padding" + n] = e;
        return t && (i.opacity = i.width = e), i
    }

    function L(e, t, n) {
        for (var r, i = (nn[t] || []).concat(nn["*"]), o = 0, s = i.length; s > o; o++)
            if (r = i[o].call(n, t, e)) return r
    }

    function q(e, t, n) {
        var r, i, o, s, a, u, l, c, f = this,
            p = {},
            d = e.style,
            h = e.nodeType && Ct(e),
            g = vt.get(e, "fxshow");
        n.queue || (a = Z._queueHooks(e, "fx"), null == a.unqueued && (a.unqueued = 0, u = a.empty.fire, a.empty.fire = function () {
            a.unqueued || u()
        }), a.unqueued++, f.always(function () {
            f.always(function () {
                a.unqueued--, Z.queue(e, "fx").length || a.empty.fire()
            })
        })), 1 === e.nodeType && ("height" in t || "width" in t) && (n.overflow = [d.overflow, d.overflowX, d.overflowY], l = Z.css(e, "display"), c = "none" === l ? vt.get(e, "olddisplay") || b(e.nodeName) : l, "inline" === c && "none" === Z.css(e, "float") && (d.display = "inline-block")), n.overflow && (d.overflow = "hidden", f.always(function () {
            d.overflow = n.overflow[0], d.overflowX = n.overflow[1], d.overflowY = n.overflow[2]
        }));
        for (r in t)
            if (i = t[r], Kt.exec(i)) {
                if (delete t[r], o = o || "toggle" === i, i === (h ? "hide" : "show")) {
                    if ("show" !== i || !g || void 0 === g[r]) continue;
                    h = !0
                }
                p[r] = g && g[r] || Z.style(e, r)
            } else l = void 0;
        if (Z.isEmptyObject(p)) "inline" === ("none" === l ? b(e.nodeName) : l) && (d.display = l);
        else {
            g ? "hidden" in g && (h = g.hidden) : g = vt.access(e, "fxshow", {}), o && (g.hidden = !h), h ? Z(e).show() : f.done(function () {
                Z(e).hide()
            }), f.done(function () {
                var t;
                vt.remove(e, "fxshow");
                for (t in p) Z.style(e, t, p[t])
            });
            for (r in p) s = L(h ? g[r] : 0, r, f), r in g || (g[r] = s.start, h && (s.end = s.start, s.start = "width" === r || "height" === r ? 1 : 0))
        }
    }

    function H(e, t) {
        var n, r, i, o, s;
        for (n in e)
            if (r = Z.camelCase(n), i = t[r], o = e[n], Z.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), s = Z.cssHooks[r], s && "expand" in s) {
                o = s.expand(o), delete e[r];
                for (n in o) n in e || (e[n] = o[n], t[n] = i)
            } else t[r] = i
    }

    function O(e, t, n) {
        var r, i, o = 0,
            s = tn.length,
            a = Z.Deferred().always(function () {
                delete u.elem
            }),
            u = function () {
                if (i) return !1;
                for (var t = Qt || j(), n = Math.max(0, l.startTime + l.duration - t), r = n / l.duration || 0, o = 1 - r, s = 0, u = l.tweens.length; u > s; s++) l.tweens[s].run(o);
                return a.notifyWith(e, [l, o, n]), 1 > o && u ? n : (a.resolveWith(e, [l]), !1)
            },
            l = a.promise({
                elem: e,
                props: Z.extend({}, t),
                opts: Z.extend(!0, {
                    specialEasing: {}
                }, n),
                originalProperties: t,
                originalOptions: n,
                startTime: Qt || j(),
                duration: n.duration,
                tweens: [],
                createTween: function (t, n) {
                    var r = Z.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing);
                    return l.tweens.push(r), r
                },
                stop: function (t) {
                    var n = 0,
                        r = t ? l.tweens.length : 0;
                    if (i) return this;
                    for (i = !0; r > n; n++) l.tweens[n].run(1);
                    return t ? a.resolveWith(e, [l, t]) : a.rejectWith(e, [l, t]), this
                }
            }),
            c = l.props;
        for (H(c, l.opts.specialEasing); s > o; o++)
            if (r = tn[o].call(l, e, c, l.opts)) return r;
        return Z.map(c, L, l), Z.isFunction(l.opts.start) && l.opts.start.call(e, l), Z.fx.timer(Z.extend(u, {
            elem: e,
            anim: l,
            queue: l.opts.queue
        })), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always)
    }

    function F(e) {
        return function (t, n) {
            "string" != typeof t && (n = t, t = "*");
            var r, i = 0,
                o = t.toLowerCase().match(dt) || [];
            if (Z.isFunction(n))
                for (; r = o[i++];) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n)
        }
    }

    function P(e, t, n, r) {
        function i(a) {
            var u;
            return o[a] = !0, Z.each(e[a] || [], function (e, a) {
                var l = a(t, n, r);
                return "string" != typeof l || s || o[l] ? s ? !(u = l) : void 0 : (t.dataTypes.unshift(l), i(l), !1)
            }), u
        }
        var o = {},
            s = e === bn;
        return i(t.dataTypes[0]) || !o["*"] && i("*")
    }

    function R(e, t) {
        var n, r, i = Z.ajaxSettings.flatOptions || {};
        for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
        return r && Z.extend(!0, e, r), e
    }

    function M(e, t, n) {
        for (var r, i, o, s, a = e.contents, u = e.dataTypes;
            "*" === u[0];) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
        if (r)
            for (i in a)
                if (a[i] && a[i].test(r)) {
                    u.unshift(i);
                    break
                }
        if (u[0] in n) o = u[0];
        else {
            for (i in n) {
                if (!u[0] || e.converters[i + " " + u[0]]) {
                    o = i;
                    break
                }
                s || (s = i)
            }
            o = o || s
        }
        return o ? (o !== u[0] && u.unshift(o), n[o]) : void 0
    }

    function W(e, t, n, r) {
        var i, o, s, a, u, l = {},
            c = e.dataTypes.slice();
        if (c[1])
            for (s in e.converters) l[s.toLowerCase()] = e.converters[s];
        for (o = c.shift(); o;)
            if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift())
                if ("*" === o) o = u;
                else if ("*" !== u && u !== o) {
            if (s = l[u + " " + o] || l["* " + o], !s)
                for (i in l)
                    if (a = i.split(" "), a[1] === o && (s = l[u + " " + a[0]] || l["* " + a[0]])) {
                        s === !0 ? s = l[i] : l[i] !== !0 && (o = a[0], c.unshift(a[1]));
                        break
                    }
            if (s !== !0)
                if (s && e["throws"]) t = s(t);
                else try {
                    t = s(t)
                } catch (f) {
                    return {
                        state: "parsererror",
                        error: s ? f : "No conversion from " + u + " to " + o
                    }
                }
        }
        return {
            state: "success",
            data: t
        }
    }

    function $(e, t, n, r) {
        var i;
        if (Z.isArray(t)) Z.each(t, function (t, i) {
            n || kn.test(e) ? r(e, i) : $(e + "[" + ("object" == typeof i ? t : "") + "]", i, n, r)
        });
        else if (n || "object" !== Z.type(t)) r(e, t);
        else
            for (i in t) $(e + "[" + i + "]", t[i], n, r)
    }

    function I(e) {
        return Z.isWindow(e) ? e : 9 === e.nodeType && e.defaultView
    }
    var B = [],
        _ = B.slice,
        z = B.concat,
        X = B.push,
        U = B.indexOf,
        V = {},
        Y = V.toString,
        G = V.hasOwnProperty,
        Q = {},
        J = e.document,
        K = "2.1.4",
        Z = function (e, t) {
            return new Z.fn.init(e, t)
        },
        et = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
        tt = /^-ms-/,
        nt = /-([\da-z])/gi,
        rt = function (e, t) {
            return t.toUpperCase()
        };
    Z.fn = Z.prototype = {
        jquery: K,
        constructor: Z,
        selector: "",
        length: 0,
        toArray: function () {
            return _.call(this)
        },
        get: function (e) {
            return null != e ? 0 > e ? this[e + this.length] : this[e] : _.call(this)
        },
        pushStack: function (e) {
            var t = Z.merge(this.constructor(), e);
            return t.prevObject = this, t.context = this.context, t
        },
        each: function (e, t) {
            return Z.each(this, e, t)
        },
        map: function (e) {
            return this.pushStack(Z.map(this, function (t, n) {
                return e.call(t, n, t)
            }))
        },
        slice: function () {
            return this.pushStack(_.apply(this, arguments))
        },
        first: function () {
            return this.eq(0)
        },
        last: function () {
            return this.eq(-1)
        },
        eq: function (e) {
            var t = this.length,
                n = +e + (0 > e ? t : 0);
            return this.pushStack(n >= 0 && t > n ? [this[n]] : [])
        },
        end: function () {
            return this.prevObject || this.constructor(null)
        },
        push: X,
        sort: B.sort,
        splice: B.splice
    }, Z.extend = Z.fn.extend = function () {
        var e, t, n, r, i, o, s = arguments[0] || {},
            a = 1,
            u = arguments.length,
            l = !1;
        for ("boolean" == typeof s && (l = s, s = arguments[a] || {}, a++), "object" == typeof s || Z.isFunction(s) || (s = {}), a === u && (s = this, a--); u > a; a++)
            if (null != (e = arguments[a]))
                for (t in e) n = s[t], r = e[t], s !== r && (l && r && (Z.isPlainObject(r) || (i = Z.isArray(r))) ? (i ? (i = !1, o = n && Z.isArray(n) ? n : []) : o = n && Z.isPlainObject(n) ? n : {}, s[t] = Z.extend(l, o, r)) : void 0 !== r && (s[t] = r));
        return s
    }, Z.extend({
        expando: "jQuery" + (K + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function (e) {
            throw new Error(e)
        },
        noop: function () {},
        isFunction: function (e) {
            return "function" === Z.type(e)
        },
        isArray: Array.isArray,
        isWindow: function (e) {
            return null != e && e === e.window
        },
        isNumeric: function (e) {
            return !Z.isArray(e) && e - parseFloat(e) + 1 >= 0
        },
        isPlainObject: function (e) {
            return "object" !== Z.type(e) || e.nodeType || Z.isWindow(e) ? !1 : e.constructor && !G.call(e.constructor.prototype, "isPrototypeOf") ? !1 : !0
        },
        isEmptyObject: function (e) {
            var t;
            for (t in e) return !1;
            return !0
        },
        type: function (e) {
            return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? V[Y.call(e)] || "object" : typeof e
        },
        globalEval: function (e) {
            var t, n = eval;
            e = Z.trim(e), e && (1 === e.indexOf("use strict") ? (t = J.createElement("script"), t.text = e, J.head.appendChild(t).parentNode.removeChild(t)) : n(e))
        },
        camelCase: function (e) {
            return e.replace(tt, "ms-").replace(nt, rt)
        },
        nodeName: function (e, t) {
            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
        },
        each: function (e, t, r) {
            var i, o = 0,
                s = e.length,
                a = n(e);
            if (r) {
                if (a)
                    for (; s > o && (i = t.apply(e[o], r), i !== !1); o++);
                else
                    for (o in e)
                        if (i = t.apply(e[o], r), i === !1) break
            } else if (a)
                for (; s > o && (i = t.call(e[o], o, e[o]), i !== !1); o++);
            else
                for (o in e)
                    if (i = t.call(e[o], o, e[o]), i === !1) break;
            return e
        },
        trim: function (e) {
            return null == e ? "" : (e + "").replace(et, "")
        },
        makeArray: function (e, t) {
            var r = t || [];
            return null != e && (n(Object(e)) ? Z.merge(r, "string" == typeof e ? [e] : e) : X.call(r, e)), r
        },
        inArray: function (e, t, n) {
            return null == t ? -1 : U.call(t, e, n)
        },
        merge: function (e, t) {
            for (var n = +t.length, r = 0, i = e.length; n > r; r++) e[i++] = t[r];
            return e.length = i, e
        },
        grep: function (e, t, n) {
            for (var r, i = [], o = 0, s = e.length, a = !n; s > o; o++) r = !t(e[o], o), r !== a && i.push(e[o]);
            return i
        },
        map: function (e, t, r) {
            var i, o = 0,
                s = e.length,
                a = n(e),
                u = [];
            if (a)
                for (; s > o; o++) i = t(e[o], o, r), null != i && u.push(i);
            else
                for (o in e) i = t(e[o], o, r), null != i && u.push(i);
            return z.apply([], u)
        },
        guid: 1,
        proxy: function (e, t) {
            var n, r, i;
            return "string" == typeof t && (n = e[t], t = e, e = n), Z.isFunction(e) ? (r = _.call(arguments, 2), i = function () {
                return e.apply(t || this, r.concat(_.call(arguments)))
            }, i.guid = e.guid = e.guid || Z.guid++, i) : void 0
        },
        now: Date.now,
        support: Q
    }), Z.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (e, t) {
        V["[object " + t + "]"] = t.toLowerCase()
    });
    var it = function (e) {
        function t(e, t, n, r) {
            var i, o, s, a, u, l, f, d, h, g;
            if ((t ? t.ownerDocument || t : $) !== q && L(t), t = t || q, n = n || [], a = t.nodeType, "string" != typeof e || !e || 1 !== a && 9 !== a && 11 !== a) return n;
            if (!r && O) {
                if (11 !== a && (i = yt.exec(e)))
                    if (s = i[1]) {
                        if (9 === a) {
                            if (o = t.getElementById(s), !o || !o.parentNode) return n;
                            if (o.id === s) return n.push(o), n
                        } else if (t.ownerDocument && (o = t.ownerDocument.getElementById(s)) && M(t, o) && o.id === s) return n.push(o), n
                    } else {
                        if (i[2]) return K.apply(n, t.getElementsByTagName(e)), n;
                        if ((s = i[3]) && w.getElementsByClassName) return K.apply(n, t.getElementsByClassName(s)), n
                    }
                if (w.qsa && (!F || !F.test(e))) {
                    if (d = f = W, h = t, g = 1 !== a && e, 1 === a && "object" !== t.nodeName.toLowerCase()) {
                        for (l = k(e), (f = t.getAttribute("id")) ? d = f.replace(bt, "\\$&") : t.setAttribute("id", d), d = "[id='" + d + "'] ", u = l.length; u--;) l[u] = d + p(l[u]);
                        h = xt.test(e) && c(t.parentNode) || t, g = l.join(",")
                    }
                    if (g) try {
                        return K.apply(n, h.querySelectorAll(g)), n
                    } catch (m) {} finally {
                        f || t.removeAttribute("id")
                    }
                }
            }
            return S(e.replace(ut, "$1"), t, n, r)
        }

        function n() {
            function e(n, r) {
                return t.push(n + " ") > T.cacheLength && delete e[t.shift()], e[n + " "] = r
            }
            var t = [];
            return e
        }

        function r(e) {
            return e[W] = !0, e
        }

        function i(e) {
            var t = q.createElement("div");
            try {
                return !!e(t)
            } catch (n) {
                return !1
            } finally {
                t.parentNode && t.parentNode.removeChild(t), t = null
            }
        }

        function o(e, t) {
            for (var n = e.split("|"), r = e.length; r--;) T.attrHandle[n[r]] = t
        }

        function s(e, t) {
            var n = t && e,
                r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || V) - (~e.sourceIndex || V);
            if (r) return r;
            if (n)
                for (; n = n.nextSibling;)
                    if (n === t) return -1;
            return e ? 1 : -1
        }

        function a(e) {
            return function (t) {
                var n = t.nodeName.toLowerCase();
                return "input" === n && t.type === e
            }
        }

        function u(e) {
            return function (t) {
                var n = t.nodeName.toLowerCase();
                return ("input" === n || "button" === n) && t.type === e
            }
        }

        function l(e) {
            return r(function (t) {
                return t = +t, r(function (n, r) {
                    for (var i, o = e([], n.length, t), s = o.length; s--;) n[i = o[s]] && (n[i] = !(r[i] = n[i]))
                })
            })
        }

        function c(e) {
            return e && "undefined" != typeof e.getElementsByTagName && e
        }

        function f() {}

        function p(e) {
            for (var t = 0, n = e.length, r = ""; n > t; t++) r += e[t].value;
            return r
        }

        function d(e, t, n) {
            var r = t.dir,
                i = n && "parentNode" === r,
                o = B++;
            return t.first ? function (t, n, o) {
                for (; t = t[r];)
                    if (1 === t.nodeType || i) return e(t, n, o)
            } : function (t, n, s) {
                var a, u, l = [I, o];
                if (s) {
                    for (; t = t[r];)
                        if ((1 === t.nodeType || i) && e(t, n, s)) return !0
                } else
                    for (; t = t[r];)
                        if (1 === t.nodeType || i) {
                            if (u = t[W] || (t[W] = {}), (a = u[r]) && a[0] === I && a[1] === o) return l[2] = a[2];
                            if (u[r] = l, l[2] = e(t, n, s)) return !0
                        }
            }
        }

        function h(e) {
            return e.length > 1 ? function (t, n, r) {
                for (var i = e.length; i--;)
                    if (!e[i](t, n, r)) return !1;
                return !0
            } : e[0]
        }

        function g(e, n, r) {
            for (var i = 0, o = n.length; o > i; i++) t(e, n[i], r);
            return r
        }

        function m(e, t, n, r, i) {
            for (var o, s = [], a = 0, u = e.length, l = null != t; u > a; a++)(o = e[a]) && (!n || n(o, r, i)) && (s.push(o), l && t.push(a));
            return s
        }

        function v(e, t, n, i, o, s) {
            return i && !i[W] && (i = v(i)), o && !o[W] && (o = v(o, s)), r(function (r, s, a, u) {
                var l, c, f, p = [],
                    d = [],
                    h = s.length,
                    v = r || g(t || "*", a.nodeType ? [a] : a, []),
                    y = !e || !r && t ? v : m(v, p, e, a, u),
                    x = n ? o || (r ? e : h || i) ? [] : s : y;
                if (n && n(y, x, a, u), i)
                    for (l = m(x, d), i(l, [], a, u), c = l.length; c--;)(f = l[c]) && (x[d[c]] = !(y[d[c]] = f));
                if (r) {
                    if (o || e) {
                        if (o) {
                            for (l = [], c = x.length; c--;)(f = x[c]) && l.push(y[c] = f);
                            o(null, x = [], l, u)
                        }
                        for (c = x.length; c--;)(f = x[c]) && (l = o ? et(r, f) : p[c]) > -1 && (r[l] = !(s[l] = f))
                    }
                } else x = m(x === s ? x.splice(h, x.length) : x), o ? o(null, s, x, u) : K.apply(s, x)
            })
        }

        function y(e) {
            for (var t, n, r, i = e.length, o = T.relative[e[0].type], s = o || T.relative[" "], a = o ? 1 : 0, u = d(function (e) {
                    return e === t
                }, s, !0), l = d(function (e) {
                    return et(t, e) > -1
                }, s, !0), c = [function (e, n, r) {
                    var i = !o && (r || n !== D) || ((t = n).nodeType ? u(e, n, r) : l(e, n, r));
                    return t = null, i
                }]; i > a; a++)
                if (n = T.relative[e[a].type]) c = [d(h(c), n)];
                else {
                    if (n = T.filter[e[a].type].apply(null, e[a].matches), n[W]) {
                        for (r = ++a; i > r && !T.relative[e[r].type]; r++);
                        return v(a > 1 && h(c), a > 1 && p(e.slice(0, a - 1).concat({
                            value: " " === e[a - 2].type ? "*" : ""
                        })).replace(ut, "$1"), n, r > a && y(e.slice(a, r)), i > r && y(e = e.slice(r)), i > r && p(e))
                    }
                    c.push(n)
                }
            return h(c)
        }

        function x(e, n) {
            var i = n.length > 0,
                o = e.length > 0,
                s = function (r, s, a, u, l) {
                    var c, f, p, d = 0,
                        h = "0",
                        g = r && [],
                        v = [],
                        y = D,
                        x = r || o && T.find.TAG("*", l),
                        b = I += null == y ? 1 : Math.random() || .1,
                        w = x.length;
                    for (l && (D = s !== q && s); h !== w && null != (c = x[h]); h++) {
                        if (o && c) {
                            for (f = 0; p = e[f++];)
                                if (p(c, s, a)) {
                                    u.push(c);
                                    break
                                }
                            l && (I = b)
                        }
                        i && ((c = !p && c) && d--, r && g.push(c))
                    }
                    if (d += h, i && h !== d) {
                        for (f = 0; p = n[f++];) p(g, v, s, a);
                        if (r) {
                            if (d > 0)
                                for (; h--;) g[h] || v[h] || (v[h] = Q.call(u));
                            v = m(v)
                        }
                        K.apply(u, v), l && !r && v.length > 0 && d + n.length > 1 && t.uniqueSort(u)
                    }
                    return l && (I = b, D = y), g
                };
            return i ? r(s) : s
        }
        var b, w, T, C, N, k, E, S, D, j, A, L, q, H, O, F, P, R, M, W = "sizzle" + 1 * new Date,
            $ = e.document,
            I = 0,
            B = 0,
            _ = n(),
            z = n(),
            X = n(),
            U = function (e, t) {
                return e === t && (A = !0), 0
            },
            V = 1 << 31,
            Y = {}.hasOwnProperty,
            G = [],
            Q = G.pop,
            J = G.push,
            K = G.push,
            Z = G.slice,
            et = function (e, t) {
                for (var n = 0, r = e.length; r > n; n++)
                    if (e[n] === t) return n;
                return -1
            },
            tt = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            nt = "[\\x20\\t\\r\\n\\f]",
            rt = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
            it = rt.replace("w", "w#"),
            ot = "\\[" + nt + "*(" + rt + ")(?:" + nt + "*([*^$|!~]?=)" + nt + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + it + "))|)" + nt + "*\\]",
            st = ":(" + rt + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + ot + ")*)|.*)\\)|)",
            at = new RegExp(nt + "+", "g"),
            ut = new RegExp("^" + nt + "+|((?:^|[^\\\\])(?:\\\\.)*)" + nt + "+$", "g"),
            lt = new RegExp("^" + nt + "*," + nt + "*"),
            ct = new RegExp("^" + nt + "*([>+~]|" + nt + ")" + nt + "*"),
            ft = new RegExp("=" + nt + "*([^\\]'\"]*?)" + nt + "*\\]", "g"),
            pt = new RegExp(st),
            dt = new RegExp("^" + it + "$"),
            ht = {
                ID: new RegExp("^#(" + rt + ")"),
                CLASS: new RegExp("^\\.(" + rt + ")"),
                TAG: new RegExp("^(" + rt.replace("w", "w*") + ")"),
                ATTR: new RegExp("^" + ot),
                PSEUDO: new RegExp("^" + st),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + nt + "*(even|odd|(([+-]|)(\\d*)n|)" + nt + "*(?:([+-]|)" + nt + "*(\\d+)|))" + nt + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + tt + ")$", "i"),
                needsContext: new RegExp("^" + nt + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + nt + "*((?:-\\d)?\\d*)" + nt + "*\\)|)(?=[^-]|$)", "i")
            },
            gt = /^(?:input|select|textarea|button)$/i,
            mt = /^h\d$/i,
            vt = /^[^{]+\{\s*\[native \w/,
            yt = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            xt = /[+~]/,
            bt = /'|\\/g,
            wt = new RegExp("\\\\([\\da-f]{1,6}" + nt + "?|(" + nt + ")|.)", "ig"),
            Tt = function (e, t, n) {
                var r = "0x" + t - 65536;
                return r !== r || n ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320)
            },
            Ct = function () {
                L()
            };
        try {
            K.apply(G = Z.call($.childNodes), $.childNodes), G[$.childNodes.length].nodeType
        } catch (Nt) {
            K = {
                apply: G.length ? function (e, t) {
                    J.apply(e, Z.call(t))
                } : function (e, t) {
                    for (var n = e.length, r = 0; e[n++] = t[r++];);
                    e.length = n - 1
                }
            }
        }
        w = t.support = {}, N = t.isXML = function (e) {
            var t = e && (e.ownerDocument || e).documentElement;
            return t ? "HTML" !== t.nodeName : !1
        }, L = t.setDocument = function (e) {
            var t, n, r = e ? e.ownerDocument || e : $;
            return r !== q && 9 === r.nodeType && r.documentElement ? (q = r, H = r.documentElement, n = r.defaultView, n && n !== n.top && (n.addEventListener ? n.addEventListener("unload", Ct, !1) : n.attachEvent && n.attachEvent("onunload", Ct)), O = !N(r), w.attributes = i(function (e) {
                return e.className = "i", !e.getAttribute("className")
            }), w.getElementsByTagName = i(function (e) {
                return e.appendChild(r.createComment("")), !e.getElementsByTagName("*").length
            }), w.getElementsByClassName = vt.test(r.getElementsByClassName), w.getById = i(function (e) {
                return H.appendChild(e).id = W, !r.getElementsByName || !r.getElementsByName(W).length
            }), w.getById ? (T.find.ID = function (e, t) {
                if ("undefined" != typeof t.getElementById && O) {
                    var n = t.getElementById(e);
                    return n && n.parentNode ? [n] : []
                }
            }, T.filter.ID = function (e) {
                var t = e.replace(wt, Tt);
                return function (e) {
                    return e.getAttribute("id") === t
                }
            }) : (delete T.find.ID, T.filter.ID = function (e) {
                var t = e.replace(wt, Tt);
                return function (e) {
                    var n = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
                    return n && n.value === t
                }
            }), T.find.TAG = w.getElementsByTagName ? function (e, t) {
                return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : w.qsa ? t.querySelectorAll(e) : void 0
            } : function (e, t) {
                var n, r = [],
                    i = 0,
                    o = t.getElementsByTagName(e);
                if ("*" === e) {
                    for (; n = o[i++];) 1 === n.nodeType && r.push(n);
                    return r
                }
                return o
            }, T.find.CLASS = w.getElementsByClassName && function (e, t) {
                return O ? t.getElementsByClassName(e) : void 0
            }, P = [], F = [], (w.qsa = vt.test(r.querySelectorAll)) && (i(function (e) {
                H.appendChild(e).innerHTML = "<a id='" + W + "'></a><select id='" + W + "-\f]' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && F.push("[*^$]=" + nt + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || F.push("\\[" + nt + "*(?:value|" + tt + ")"), e.querySelectorAll("[id~=" + W + "-]").length || F.push("~="), e.querySelectorAll(":checked").length || F.push(":checked"), e.querySelectorAll("a#" + W + "+*").length || F.push(".#.+[+~]")
            }), i(function (e) {
                var t = r.createElement("input");
                t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && F.push("name" + nt + "*[*^$|!~]?="), e.querySelectorAll(":enabled").length || F.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), F.push(",.*:")
            })), (w.matchesSelector = vt.test(R = H.matches || H.webkitMatchesSelector || H.mozMatchesSelector || H.oMatchesSelector || H.msMatchesSelector)) && i(function (e) {
                w.disconnectedMatch = R.call(e, "div"), R.call(e, "[s!='']:x"), P.push("!=", st)
            }), F = F.length && new RegExp(F.join("|")), P = P.length && new RegExp(P.join("|")), t = vt.test(H.compareDocumentPosition), M = t || vt.test(H.contains) ? function (e, t) {
                var n = 9 === e.nodeType ? e.documentElement : e,
                    r = t && t.parentNode;
                return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
            } : function (e, t) {
                if (t)
                    for (; t = t.parentNode;)
                        if (t === e) return !0;
                return !1
            }, U = t ? function (e, t) {
                if (e === t) return A = !0, 0;
                var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
                return n ? n : (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & n || !w.sortDetached && t.compareDocumentPosition(e) === n ? e === r || e.ownerDocument === $ && M($, e) ? -1 : t === r || t.ownerDocument === $ && M($, t) ? 1 : j ? et(j, e) - et(j, t) : 0 : 4 & n ? -1 : 1)
            } : function (e, t) {
                if (e === t) return A = !0, 0;
                var n, i = 0,
                    o = e.parentNode,
                    a = t.parentNode,
                    u = [e],
                    l = [t];
                if (!o || !a) return e === r ? -1 : t === r ? 1 : o ? -1 : a ? 1 : j ? et(j, e) - et(j, t) : 0;
                if (o === a) return s(e, t);
                for (n = e; n = n.parentNode;) u.unshift(n);
                for (n = t; n = n.parentNode;) l.unshift(n);
                for (; u[i] === l[i];) i++;
                return i ? s(u[i], l[i]) : u[i] === $ ? -1 : l[i] === $ ? 1 : 0
            }, r) : q
        }, t.matches = function (e, n) {
            return t(e, null, null, n)
        }, t.matchesSelector = function (e, n) {
            if ((e.ownerDocument || e) !== q && L(e), n = n.replace(ft, "='$1']"), !(!w.matchesSelector || !O || P && P.test(n) || F && F.test(n))) try {
                var r = R.call(e, n);
                if (r || w.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r
            } catch (i) {}
            return t(n, q, null, [e]).length > 0
        }, t.contains = function (e, t) {
            return (e.ownerDocument || e) !== q && L(e), M(e, t)
        }, t.attr = function (e, t) {
            (e.ownerDocument || e) !== q && L(e);
            var n = T.attrHandle[t.toLowerCase()],
                r = n && Y.call(T.attrHandle, t.toLowerCase()) ? n(e, t, !O) : void 0;
            return void 0 !== r ? r : w.attributes || !O ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
        }, t.error = function (e) {
            throw new Error("Syntax error, unrecognized expression: " + e)
        }, t.uniqueSort = function (e) {
            var t, n = [],
                r = 0,
                i = 0;
            if (A = !w.detectDuplicates, j = !w.sortStable && e.slice(0), e.sort(U), A) {
                for (; t = e[i++];) t === e[i] && (r = n.push(i));
                for (; r--;) e.splice(n[r], 1)
            }
            return j = null, e
        }, C = t.getText = function (e) {
            var t, n = "",
                r = 0,
                i = e.nodeType;
            if (i) {
                if (1 === i || 9 === i || 11 === i) {
                    if ("string" == typeof e.textContent) return e.textContent;
                    for (e = e.firstChild; e; e = e.nextSibling) n += C(e)
                } else if (3 === i || 4 === i) return e.nodeValue
            } else
                for (; t = e[r++];) n += C(t);
            return n
        }, T = t.selectors = {
            cacheLength: 50,
            createPseudo: r,
            match: ht,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function (e) {
                    return e[1] = e[1].replace(wt, Tt), e[3] = (e[3] || e[4] || e[5] || "").replace(wt, Tt), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                },
                CHILD: function (e) {
                    return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || t.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && t.error(e[0]), e
                },
                PSEUDO: function (e) {
                    var t, n = !e[6] && e[2];
                    return ht.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && pt.test(n) && (t = k(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
                }
            },
            filter: {
                TAG: function (e) {
                    var t = e.replace(wt, Tt).toLowerCase();
                    return "*" === e ? function () {
                        return !0
                    } : function (e) {
                        return e.nodeName && e.nodeName.toLowerCase() === t
                    }
                },
                CLASS: function (e) {
                    var t = _[e + " "];
                    return t || (t = new RegExp("(^|" + nt + ")" + e + "(" + nt + "|$)")) && _(e, function (e) {
                        return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "")
                    })
                },
                ATTR: function (e, n, r) {
                    return function (i) {
                        var o = t.attr(i, e);
                        return null == o ? "!=" === n : n ? (o += "", "=" === n ? o === r : "!=" === n ? o !== r : "^=" === n ? r && 0 === o.indexOf(r) : "*=" === n ? r && o.indexOf(r) > -1 : "$=" === n ? r && o.slice(-r.length) === r : "~=" === n ? (" " + o.replace(at, " ") + " ").indexOf(r) > -1 : "|=" === n ? o === r || o.slice(0, r.length + 1) === r + "-" : !1) : !0
                    }
                },
                CHILD: function (e, t, n, r, i) {
                    var o = "nth" !== e.slice(0, 3),
                        s = "last" !== e.slice(-4),
                        a = "of-type" === t;
                    return 1 === r && 0 === i ? function (e) {
                        return !!e.parentNode
                    } : function (t, n, u) {
                        var l, c, f, p, d, h, g = o !== s ? "nextSibling" : "previousSibling",
                            m = t.parentNode,
                            v = a && t.nodeName.toLowerCase(),
                            y = !u && !a;
                        if (m) {
                            if (o) {
                                for (; g;) {
                                    for (f = t; f = f[g];)
                                        if (a ? f.nodeName.toLowerCase() === v : 1 === f.nodeType) return !1;
                                    h = g = "only" === e && !h && "nextSibling"
                                }
                                return !0
                            }
                            if (h = [s ? m.firstChild : m.lastChild], s && y) {
                                for (c = m[W] || (m[W] = {}), l = c[e] || [], d = l[0] === I && l[1], p = l[0] === I && l[2], f = d && m.childNodes[d]; f = ++d && f && f[g] || (p = d = 0) || h.pop();)
                                    if (1 === f.nodeType && ++p && f === t) {
                                        c[e] = [I, d, p];
                                        break
                                    }
                            } else if (y && (l = (t[W] || (t[W] = {}))[e]) && l[0] === I) p = l[1];
                            else
                                for (;
                                    (f = ++d && f && f[g] || (p = d = 0) || h.pop()) && ((a ? f.nodeName.toLowerCase() !== v : 1 !== f.nodeType) || !++p || (y && ((f[W] || (f[W] = {}))[e] = [I, p]), f !== t)););
                            return p -= i, p === r || p % r === 0 && p / r >= 0
                        }
                    }
                },
                PSEUDO: function (e, n) {
                    var i, o = T.pseudos[e] || T.setFilters[e.toLowerCase()] || t.error("unsupported pseudo: " + e);
                    return o[W] ? o(n) : o.length > 1 ? (i = [e, e, "", n], T.setFilters.hasOwnProperty(e.toLowerCase()) ? r(function (e, t) {
                        for (var r, i = o(e, n), s = i.length; s--;) r = et(e, i[s]), e[r] = !(t[r] = i[s])
                    }) : function (e) {
                        return o(e, 0, i)
                    }) : o
                }
            },
            pseudos: {
                not: r(function (e) {
                    var t = [],
                        n = [],
                        i = E(e.replace(ut, "$1"));
                    return i[W] ? r(function (e, t, n, r) {
                        for (var o, s = i(e, null, r, []), a = e.length; a--;)(o = s[a]) && (e[a] = !(t[a] = o))
                    }) : function (e, r, o) {
                        return t[0] = e, i(t, null, o, n), t[0] = null, !n.pop()
                    }
                }),
                has: r(function (e) {
                    return function (n) {
                        return t(e, n).length > 0
                    }
                }),
                contains: r(function (e) {
                    return e = e.replace(wt, Tt),
                        function (t) {
                            return (t.textContent || t.innerText || C(t)).indexOf(e) > -1
                        }
                }),
                lang: r(function (e) {
                    return dt.test(e || "") || t.error("unsupported lang: " + e), e = e.replace(wt, Tt).toLowerCase(),
                        function (t) {
                            var n;
                            do
                                if (n = O ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + "-"); while ((t = t.parentNode) && 1 === t.nodeType);
                            return !1
                        }
                }),
                target: function (t) {
                    var n = e.location && e.location.hash;
                    return n && n.slice(1) === t.id
                },
                root: function (e) {
                    return e === H
                },
                focus: function (e) {
                    return e === q.activeElement && (!q.hasFocus || q.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                },
                enabled: function (e) {
                    return e.disabled === !1
                },
                disabled: function (e) {
                    return e.disabled === !0
                },
                checked: function (e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && !!e.checked || "option" === t && !!e.selected
                },
                selected: function (e) {
                    return e.parentNode && e.parentNode.selectedIndex, e.selected === !0
                },
                empty: function (e) {
                    for (e = e.firstChild; e; e = e.nextSibling)
                        if (e.nodeType < 6) return !1;
                    return !0
                },
                parent: function (e) {
                    return !T.pseudos.empty(e)
                },
                header: function (e) {
                    return mt.test(e.nodeName)
                },
                input: function (e) {
                    return gt.test(e.nodeName)
                },
                button: function (e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && "button" === e.type || "button" === t
                },
                text: function (e) {
                    var t;
                    return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                },
                first: l(function () {
                    return [0]
                }),
                last: l(function (e, t) {
                    return [t - 1]
                }),
                eq: l(function (e, t, n) {
                    return [0 > n ? n + t : n]
                }),
                even: l(function (e, t) {
                    for (var n = 0; t > n; n += 2) e.push(n);
                    return e
                }),
                odd: l(function (e, t) {
                    for (var n = 1; t > n; n += 2) e.push(n);
                    return e
                }),
                lt: l(function (e, t, n) {
                    for (var r = 0 > n ? n + t : n; --r >= 0;) e.push(r);
                    return e
                }),
                gt: l(function (e, t, n) {
                    for (var r = 0 > n ? n + t : n; ++r < t;) e.push(r);
                    return e
                })
            }
        }, T.pseudos.nth = T.pseudos.eq;
        for (b in {
                radio: !0,
                checkbox: !0,
                file: !0,
                password: !0,
                image: !0
            }) T.pseudos[b] = a(b);
        for (b in {
                submit: !0,
                reset: !0
            }) T.pseudos[b] = u(b);
        return f.prototype = T.filters = T.pseudos, T.setFilters = new f, k = t.tokenize = function (e, n) {
            var r, i, o, s, a, u, l, c = z[e + " "];
            if (c) return n ? 0 : c.slice(0);
            for (a = e, u = [], l = T.preFilter; a;) {
                (!r || (i = lt.exec(a))) && (i && (a = a.slice(i[0].length) || a), u.push(o = [])), r = !1, (i = ct.exec(a)) && (r = i.shift(), o.push({
                    value: r,
                    type: i[0].replace(ut, " ")
                }), a = a.slice(r.length));
                for (s in T.filter) !(i = ht[s].exec(a)) || l[s] && !(i = l[s](i)) || (r = i.shift(), o.push({
                    value: r,
                    type: s,
                    matches: i
                }), a = a.slice(r.length));
                if (!r) break
            }
            return n ? a.length : a ? t.error(e) : z(e, u).slice(0)
        }, E = t.compile = function (e, t) {
            var n, r = [],
                i = [],
                o = X[e + " "];
            if (!o) {
                for (t || (t = k(e)), n = t.length; n--;) o = y(t[n]), o[W] ? r.push(o) : i.push(o);
                o = X(e, x(i, r)), o.selector = e
            }
            return o
        }, S = t.select = function (e, t, n, r) {
            var i, o, s, a, u, l = "function" == typeof e && e,
                f = !r && k(e = l.selector || e);
            if (n = n || [], 1 === f.length) {
                if (o = f[0] = f[0].slice(0), o.length > 2 && "ID" === (s = o[0]).type && w.getById && 9 === t.nodeType && O && T.relative[o[1].type]) {
                    if (t = (T.find.ID(s.matches[0].replace(wt, Tt), t) || [])[0], !t) return n;
                    l && (t = t.parentNode), e = e.slice(o.shift().value.length)
                }
                for (i = ht.needsContext.test(e) ? 0 : o.length; i-- && (s = o[i], !T.relative[a = s.type]);)
                    if ((u = T.find[a]) && (r = u(s.matches[0].replace(wt, Tt), xt.test(o[0].type) && c(t.parentNode) || t))) {
                        if (o.splice(i, 1), e = r.length && p(o), !e) return K.apply(n, r), n;
                        break
                    }
            }
            return (l || E(e, f))(r, t, !O, n, xt.test(e) && c(t.parentNode) || t), n
        }, w.sortStable = W.split("").sort(U).join("") === W, w.detectDuplicates = !!A, L(), w.sortDetached = i(function (e) {
            return 1 & e.compareDocumentPosition(q.createElement("div"))
        }), i(function (e) {
            return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
        }) || o("type|href|height|width", function (e, t, n) {
            return n ? void 0 : e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
        }), w.attributes && i(function (e) {
            return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
        }) || o("value", function (e, t, n) {
            return n || "input" !== e.nodeName.toLowerCase() ? void 0 : e.defaultValue
        }), i(function (e) {
            return null == e.getAttribute("disabled")
        }) || o(tt, function (e, t, n) {
            var r;
            return n ? void 0 : e[t] === !0 ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
        }), t
    }(e);
    Z.find = it, Z.expr = it.selectors, Z.expr[":"] = Z.expr.pseudos, Z.unique = it.uniqueSort, Z.text = it.getText, Z.isXMLDoc = it.isXML, Z.contains = it.contains;
    var ot = Z.expr.match.needsContext,
        st = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        at = /^.[^:#\[\.,]*$/;
    Z.filter = function (e, t, n) {
        var r = t[0];
        return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? Z.find.matchesSelector(r, e) ? [r] : [] : Z.find.matches(e, Z.grep(t, function (e) {
            return 1 === e.nodeType
        }))
    }, Z.fn.extend({
        find: function (e) {
            var t, n = this.length,
                r = [],
                i = this;
            if ("string" != typeof e) return this.pushStack(Z(e).filter(function () {
                for (t = 0; n > t; t++)
                    if (Z.contains(i[t], this)) return !0
            }));
            for (t = 0; n > t; t++) Z.find(e, i[t], r);
            return r = this.pushStack(n > 1 ? Z.unique(r) : r), r.selector = this.selector ? this.selector + " " + e : e, r
        },
        filter: function (e) {
            return this.pushStack(r(this, e || [], !1))
        },
        not: function (e) {
            return this.pushStack(r(this, e || [], !0))
        },
        is: function (e) {
            return !!r(this, "string" == typeof e && ot.test(e) ? Z(e) : e || [], !1).length
        }
    });
    var ut, lt = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
        ct = Z.fn.init = function (e, t) {
            var n, r;
            if (!e) return this;
            if ("string" == typeof e) {
                if (n = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : lt.exec(e), !n || !n[1] && t) return !t || t.jquery ? (t || ut).find(e) : this.constructor(t).find(e);
                if (n[1]) {
                    if (t = t instanceof Z ? t[0] : t, Z.merge(this, Z.parseHTML(n[1], t && t.nodeType ? t.ownerDocument || t : J, !0)), st.test(n[1]) && Z.isPlainObject(t))
                        for (n in t) Z.isFunction(this[n]) ? this[n](t[n]) : this.attr(n, t[n]);
                    return this
                }
                return r = J.getElementById(n[2]), r && r.parentNode && (this.length = 1, this[0] = r), this.context = J, this.selector = e, this
            }
            return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : Z.isFunction(e) ? "undefined" != typeof ut.ready ? ut.ready(e) : e(Z) : (void 0 !== e.selector && (this.selector = e.selector, this.context = e.context), Z.makeArray(e, this))
        };
    ct.prototype = Z.fn, ut = Z(J);
    var ft = /^(?:parents|prev(?:Until|All))/,
        pt = {
            children: !0,
            contents: !0,
            next: !0,
            prev: !0
        };
    Z.extend({
        dir: function (e, t, n) {
            for (var r = [], i = void 0 !== n;
                (e = e[t]) && 9 !== e.nodeType;)
                if (1 === e.nodeType) {
                    if (i && Z(e).is(n)) break;
                    r.push(e)
                }
            return r
        },
        sibling: function (e, t) {
            for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
            return n
        }
    }), Z.fn.extend({
        has: function (e) {
            var t = Z(e, this),
                n = t.length;
            return this.filter(function () {
                for (var e = 0; n > e; e++)
                    if (Z.contains(this, t[e])) return !0
            })
        },
        closest: function (e, t) {
            for (var n, r = 0, i = this.length, o = [], s = ot.test(e) || "string" != typeof e ? Z(e, t || this.context) : 0; i > r; r++)
                for (n = this[r]; n && n !== t; n = n.parentNode)
                    if (n.nodeType < 11 && (s ? s.index(n) > -1 : 1 === n.nodeType && Z.find.matchesSelector(n, e))) {
                        o.push(n);
                        break
                    }
            return this.pushStack(o.length > 1 ? Z.unique(o) : o)
        },
        index: function (e) {
            return e ? "string" == typeof e ? U.call(Z(e), this[0]) : U.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function (e, t) {
            return this.pushStack(Z.unique(Z.merge(this.get(), Z(e, t))))
        },
        addBack: function (e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
        }
    }), Z.each({
        parent: function (e) {
            var t = e.parentNode;
            return t && 11 !== t.nodeType ? t : null
        },
        parents: function (e) {
            return Z.dir(e, "parentNode")
        },
        parentsUntil: function (e, t, n) {
            return Z.dir(e, "parentNode", n)
        },
        next: function (e) {
            return i(e, "nextSibling")
        },
        prev: function (e) {
            return i(e, "previousSibling")
        },
        nextAll: function (e) {
            return Z.dir(e, "nextSibling")
        },
        prevAll: function (e) {
            return Z.dir(e, "previousSibling")
        },
        nextUntil: function (e, t, n) {
            return Z.dir(e, "nextSibling", n)
        },
        prevUntil: function (e, t, n) {
            return Z.dir(e, "previousSibling", n)
        },
        siblings: function (e) {
            return Z.sibling((e.parentNode || {}).firstChild, e)
        },
        children: function (e) {
            return Z.sibling(e.firstChild)
        },
        contents: function (e) {
            return e.contentDocument || Z.merge([], e.childNodes)
        }
    }, function (e, t) {
        Z.fn[e] = function (n, r) {
            var i = Z.map(this, t, n);
            return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = Z.filter(r, i)), this.length > 1 && (pt[e] || Z.unique(i), ft.test(e) && i.reverse()), this.pushStack(i)
        }
    });
    var dt = /\S+/g,
        ht = {};
    Z.Callbacks = function (e) {
        e = "string" == typeof e ? ht[e] || o(e) : Z.extend({}, e);
        var t, n, r, i, s, a, u = [],
            l = !e.once && [],
            c = function (o) {
                for (t = e.memory && o, n = !0, a = i || 0, i = 0, s = u.length, r = !0; u && s > a; a++)
                    if (u[a].apply(o[0], o[1]) === !1 && e.stopOnFalse) {
                        t = !1;
                        break
                    }
                r = !1, u && (l ? l.length && c(l.shift()) : t ? u = [] : f.disable())
            },
            f = {
                add: function () {
                    if (u) {
                        var n = u.length;
                        ! function o(t) {
                            Z.each(t, function (t, n) {
                                var r = Z.type(n);
                                "function" === r ? e.unique && f.has(n) || u.push(n) : n && n.length && "string" !== r && o(n)
                            })
                        }(arguments), r ? s = u.length : t && (i = n, c(t))
                    }
                    return this
                },
                remove: function () {
                    return u && Z.each(arguments, function (e, t) {
                        for (var n;
                            (n = Z.inArray(t, u, n)) > -1;) u.splice(n, 1), r && (s >= n && s--, a >= n && a--)
                    }), this
                },
                has: function (e) {
                    return e ? Z.inArray(e, u) > -1 : !(!u || !u.length)
                },
                empty: function () {
                    return u = [], s = 0, this
                },
                disable: function () {
                    return u = l = t = void 0, this
                },
                disabled: function () {
                    return !u
                },
                lock: function () {
                    return l = void 0, t || f.disable(), this
                },
                locked: function () {
                    return !l
                },
                fireWith: function (e, t) {
                    return !u || n && !l || (t = t || [], t = [e, t.slice ? t.slice() : t], r ? l.push(t) : c(t)), this
                },
                fire: function () {
                    return f.fireWith(this, arguments), this
                },
                fired: function () {
                    return !!n
                }
            };
        return f
    }, Z.extend({
        Deferred: function (e) {
            var t = [
                    ["resolve", "done", Z.Callbacks("once memory"), "resolved"],
                    ["reject", "fail", Z.Callbacks("once memory"), "rejected"],
                    ["notify", "progress", Z.Callbacks("memory")]
                ],
                n = "pending",
                r = {
                    state: function () {
                        return n
                    },
                    always: function () {
                        return i.done(arguments).fail(arguments), this
                    },
                    then: function () {
                        var e = arguments;
                        return Z.Deferred(function (n) {
                            Z.each(t, function (t, o) {
                                var s = Z.isFunction(e[t]) && e[t];
                                i[o[1]](function () {
                                    var e = s && s.apply(this, arguments);
                                    e && Z.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[o[0] + "With"](this === r ? n.promise() : this, s ? [e] : arguments)
                                })
                            }), e = null
                        }).promise()
                    },
                    promise: function (e) {
                        return null != e ? Z.extend(e, r) : r
                    }
                },
                i = {};
            return r.pipe = r.then, Z.each(t, function (e, o) {
                var s = o[2],
                    a = o[3];
                r[o[1]] = s.add, a && s.add(function () {
                    n = a
                }, t[1 ^ e][2].disable, t[2][2].lock), i[o[0]] = function () {
                    return i[o[0] + "With"](this === i ? r : this, arguments), this
                }, i[o[0] + "With"] = s.fireWith
            }), r.promise(i), e && e.call(i, i), i
        },
        when: function (e) {
            var t, n, r, i = 0,
                o = _.call(arguments),
                s = o.length,
                a = 1 !== s || e && Z.isFunction(e.promise) ? s : 0,
                u = 1 === a ? e : Z.Deferred(),
                l = function (e, n, r) {
                    return function (i) {
                        n[e] = this, r[e] = arguments.length > 1 ? _.call(arguments) : i, r === t ? u.notifyWith(n, r) : --a || u.resolveWith(n, r)
                    }
                };
            if (s > 1)
                for (t = new Array(s), n = new Array(s), r = new Array(s); s > i; i++) o[i] && Z.isFunction(o[i].promise) ? o[i].promise().done(l(i, r, o)).fail(u.reject).progress(l(i, n, t)) : --a;
            return a || u.resolveWith(r, o), u.promise()
        }
    });
    var gt;
    Z.fn.ready = function (e) {
        return Z.ready.promise().done(e), this
    }, Z.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function (e) {
            e ? Z.readyWait++ : Z.ready(!0)
        },
        ready: function (e) {
            (e === !0 ? --Z.readyWait : Z.isReady) || (Z.isReady = !0, e !== !0 && --Z.readyWait > 0 || (gt.resolveWith(J, [Z]), Z.fn.triggerHandler && (Z(J).triggerHandler("ready"), Z(J).off("ready"))))
        }
    }), Z.ready.promise = function (t) {
        return gt || (gt = Z.Deferred(), "complete" === J.readyState ? setTimeout(Z.ready) : (J.addEventListener("DOMContentLoaded", s, !1), e.addEventListener("load", s, !1))), gt.promise(t)
    }, Z.ready.promise();
    var mt = Z.access = function (e, t, n, r, i, o, s) {
        var a = 0,
            u = e.length,
            l = null == n;
        if ("object" === Z.type(n)) {
            i = !0;
            for (a in n) Z.access(e, t, a, n[a], !0, o, s)
        } else if (void 0 !== r && (i = !0, Z.isFunction(r) || (s = !0), l && (s ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) {
                return l.call(Z(e), n)
            })), t))
            for (; u > a; a++) t(e[a], n, s ? r : r.call(e[a], a, t(e[a], n)));
        return i ? e : l ? t.call(e) : u ? t(e[0], n) : o
    };
    Z.acceptData = function (e) {
        return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
    }, a.uid = 1, a.accepts = Z.acceptData, a.prototype = {
        key: function (e) {
            if (!a.accepts(e)) return 0;
            var t = {},
                n = e[this.expando];
            if (!n) {
                n = a.uid++;
                try {
                    t[this.expando] = {
                        value: n
                    }, Object.defineProperties(e, t)
                } catch (r) {
                    t[this.expando] = n, Z.extend(e, t)
                }
            }
            return this.cache[n] || (this.cache[n] = {}), n
        },
        set: function (e, t, n) {
            var r, i = this.key(e),
                o = this.cache[i];
            if ("string" == typeof t) o[t] = n;
            else if (Z.isEmptyObject(o)) Z.extend(this.cache[i], t);
            else
                for (r in t) o[r] = t[r];
            return o
        },
        get: function (e, t) {
            var n = this.cache[this.key(e)];
            return void 0 === t ? n : n[t]
        },
        access: function (e, t, n) {
            var r;
            return void 0 === t || t && "string" == typeof t && void 0 === n ? (r = this.get(e, t), void 0 !== r ? r : this.get(e, Z.camelCase(t))) : (this.set(e, t, n), void 0 !== n ? n : t)
        },
        remove: function (e, t) {
            var n, r, i, o = this.key(e),
                s = this.cache[o];
            if (void 0 === t) this.cache[o] = {};
            else {
                Z.isArray(t) ? r = t.concat(t.map(Z.camelCase)) : (i = Z.camelCase(t), t in s ? r = [t, i] : (r = i, r = r in s ? [r] : r.match(dt) || [])), n = r.length;
                for (; n--;) delete s[r[n]]
            }
        },
        hasData: function (e) {
            return !Z.isEmptyObject(this.cache[e[this.expando]] || {})
        },
        discard: function (e) {
            e[this.expando] && delete this.cache[e[this.expando]]
        }
    };
    var vt = new a,
        yt = new a,
        xt = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        bt = /([A-Z])/g;
    Z.extend({
        hasData: function (e) {
            return yt.hasData(e) || vt.hasData(e)
        },
        data: function (e, t, n) {
            return yt.access(e, t, n)
        },
        removeData: function (e, t) {
            yt.remove(e, t)
        },
        _data: function (e, t, n) {
            return vt.access(e, t, n)
        },
        _removeData: function (e, t) {
            vt.remove(e, t)
        }
    }), Z.fn.extend({
        data: function (e, t) {
            var n, r, i, o = this[0],
                s = o && o.attributes;
            if (void 0 === e) {
                if (this.length && (i = yt.get(o), 1 === o.nodeType && !vt.get(o, "hasDataAttrs"))) {
                    for (n = s.length; n--;) s[n] && (r = s[n].name, 0 === r.indexOf("data-") && (r = Z.camelCase(r.slice(5)), u(o, r, i[r])));
                    vt.set(o, "hasDataAttrs", !0)
                }
                return i
            }
            return "object" == typeof e ? this.each(function () {
                yt.set(this, e)
            }) : mt(this, function (t) {
                var n, r = Z.camelCase(e);
                if (o && void 0 === t) {
                    if (n = yt.get(o, e), void 0 !== n) return n;
                    if (n = yt.get(o, r), void 0 !== n) return n;
                    if (n = u(o, r, void 0), void 0 !== n) return n
                } else this.each(function () {
                    var n = yt.get(this, r);
                    yt.set(this, r, t), -1 !== e.indexOf("-") && void 0 !== n && yt.set(this, e, t)
                })
            }, null, t, arguments.length > 1, null, !0)
        },
        removeData: function (e) {
            return this.each(function () {
                yt.remove(this, e)
            })
        }
    }), Z.extend({
        queue: function (e, t, n) {
            var r;
            return e ? (t = (t || "fx") + "queue", r = vt.get(e, t), n && (!r || Z.isArray(n) ? r = vt.access(e, t, Z.makeArray(n)) : r.push(n)), r || []) : void 0
        },
        dequeue: function (e, t) {
            t = t || "fx";
            var n = Z.queue(e, t),
                r = n.length,
                i = n.shift(),
                o = Z._queueHooks(e, t),
                s = function () {
                    Z.dequeue(e, t)
                };
            "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, s, o)), !r && o && o.empty.fire()
        },
        _queueHooks: function (e, t) {
            var n = t + "queueHooks";
            return vt.get(e, n) || vt.access(e, n, {
                empty: Z.Callbacks("once memory").add(function () {
                    vt.remove(e, [t + "queue", n])
                })
            })
        }
    }), Z.fn.extend({
        queue: function (e, t) {
            var n = 2;
            return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? Z.queue(this[0], e) : void 0 === t ? this : this.each(function () {
                var n = Z.queue(this, e, t);
                Z._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && Z.dequeue(this, e)
            })
        },
        dequeue: function (e) {
            return this.each(function () {
                Z.dequeue(this, e)
            })
        },
        clearQueue: function (e) {
            return this.queue(e || "fx", [])
        },
        promise: function (e, t) {
            var n, r = 1,
                i = Z.Deferred(),
                o = this,
                s = this.length,
                a = function () {
                    --r || i.resolveWith(o, [o])
                };
            for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; s--;) n = vt.get(o[s], e + "queueHooks"), n && n.empty && (r++, n.empty.add(a));
            return a(), i.promise(t)
        }
    });
    var wt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        Tt = ["Top", "Right", "Bottom", "Left"],
        Ct = function (e, t) {
            return e = t || e, "none" === Z.css(e, "display") || !Z.contains(e.ownerDocument, e)
        },
        Nt = /^(?:checkbox|radio)$/i;
    ! function () {
        var e = J.createDocumentFragment(),
            t = e.appendChild(J.createElement("div")),
            n = J.createElement("input");
        n.setAttribute("type", "radio"), n.setAttribute("checked", "checked"), n.setAttribute("name", "t"), t.appendChild(n), Q.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, t.innerHTML = "<textarea>x</textarea>", Q.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue
    }();
    var kt = "undefined";
    Q.focusinBubbles = "onfocusin" in e;
    var Et = /^key/,
        St = /^(?:mouse|pointer|contextmenu)|click/,
        Dt = /^(?:focusinfocus|focusoutblur)$/,
        jt = /^([^.]*)(?:\.(.+)|)$/;
    Z.event = {
        global: {},
        add: function (e, t, n, r, i) {
            var o, s, a, u, l, c, f, p, d, h, g, m = vt.get(e);
            if (m)
                for (n.handler && (o = n, n = o.handler, i = o.selector), n.guid || (n.guid = Z.guid++), (u = m.events) || (u = m.events = {}), (s = m.handle) || (s = m.handle = function (t) {
                        return typeof Z !== kt && Z.event.triggered !== t.type ? Z.event.dispatch.apply(e, arguments) : void 0
                    }), t = (t || "").match(dt) || [""], l = t.length; l--;) a = jt.exec(t[l]) || [], d = g = a[1], h = (a[2] || "").split(".").sort(), d && (f = Z.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = Z.event.special[d] || {}, c = Z.extend({
                    type: d,
                    origType: g,
                    data: r,
                    handler: n,
                    guid: n.guid,
                    selector: i,
                    needsContext: i && Z.expr.match.needsContext.test(i),
                    namespace: h.join(".")
                }, o), (p = u[d]) || (p = u[d] = [], p.delegateCount = 0, f.setup && f.setup.call(e, r, h, s) !== !1 || e.addEventListener && e.addEventListener(d, s, !1)), f.add && (f.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), Z.event.global[d] = !0)
        },
        remove: function (e, t, n, r, i) {
            var o, s, a, u, l, c, f, p, d, h, g, m = vt.hasData(e) && vt.get(e);
            if (m && (u = m.events)) {
                for (t = (t || "").match(dt) || [""], l = t.length; l--;)
                    if (a = jt.exec(t[l]) || [], d = g = a[1], h = (a[2] || "").split(".").sort(), d) {
                        for (f = Z.event.special[d] || {}, d = (r ? f.delegateType : f.bindType) || d, p = u[d] || [], a = a[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), s = o = p.length; o--;) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || a && !a.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
                        s && !p.length && (f.teardown && f.teardown.call(e, h, m.handle) !== !1 || Z.removeEvent(e, d, m.handle), delete u[d])
                    } else
                        for (d in u) Z.event.remove(e, d + t[l], n, r, !0);
                Z.isEmptyObject(u) && (delete m.handle, vt.remove(e, "events"))
            }
        },
        trigger: function (t, n, r, i) {
            var o, s, a, u, l, c, f, p = [r || J],
                d = G.call(t, "type") ? t.type : t,
                h = G.call(t, "namespace") ? t.namespace.split(".") : [];
            if (s = a = r = r || J, 3 !== r.nodeType && 8 !== r.nodeType && !Dt.test(d + Z.event.triggered) && (d.indexOf(".") >= 0 && (h = d.split("."), d = h.shift(), h.sort()), l = d.indexOf(":") < 0 && "on" + d, t = t[Z.expando] ? t : new Z.Event(d, "object" == typeof t && t), t.isTrigger = i ? 2 : 3, t.namespace = h.join("."), t.namespace_re = t.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = r), n = null == n ? [t] : Z.makeArray(n, [t]), f = Z.event.special[d] || {}, i || !f.trigger || f.trigger.apply(r, n) !== !1)) {
                if (!i && !f.noBubble && !Z.isWindow(r)) {
                    for (u = f.delegateType || d, Dt.test(u + d) || (s = s.parentNode); s; s = s.parentNode) p.push(s), a = s;
                    a === (r.ownerDocument || J) && p.push(a.defaultView || a.parentWindow || e)
                }
                for (o = 0;
                    (s = p[o++]) && !t.isPropagationStopped();) t.type = o > 1 ? u : f.bindType || d, c = (vt.get(s, "events") || {})[t.type] && vt.get(s, "handle"), c && c.apply(s, n), c = l && s[l], c && c.apply && Z.acceptData(s) && (t.result = c.apply(s, n), t.result === !1 && t.preventDefault());
                return t.type = d, i || t.isDefaultPrevented() || f._default && f._default.apply(p.pop(), n) !== !1 || !Z.acceptData(r) || l && Z.isFunction(r[d]) && !Z.isWindow(r) && (a = r[l], a && (r[l] = null), Z.event.triggered = d, r[d](), Z.event.triggered = void 0, a && (r[l] = a)), t.result
            }
        },
        dispatch: function (e) {
            e = Z.event.fix(e);
            var t, n, r, i, o, s = [],
                a = _.call(arguments),
                u = (vt.get(this, "events") || {})[e.type] || [],
                l = Z.event.special[e.type] || {};
            if (a[0] = e, e.delegateTarget = this, !l.preDispatch || l.preDispatch.call(this, e) !== !1) {
                for (s = Z.event.handlers.call(this, e, u), t = 0;
                    (i = s[t++]) && !e.isPropagationStopped();)
                    for (e.currentTarget = i.elem, n = 0;
                        (o = i.handlers[n++]) && !e.isImmediatePropagationStopped();)(!e.namespace_re || e.namespace_re.test(o.namespace)) && (e.handleObj = o, e.data = o.data, r = ((Z.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, a), void 0 !== r && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation()));
                return l.postDispatch && l.postDispatch.call(this, e), e.result
            }
        },
        handlers: function (e, t) {
            var n, r, i, o, s = [],
                a = t.delegateCount,
                u = e.target;
            if (a && u.nodeType && (!e.button || "click" !== e.type))
                for (; u !== this; u = u.parentNode || this)
                    if (u.disabled !== !0 || "click" !== e.type) {
                        for (r = [], n = 0; a > n; n++) o = t[n], i = o.selector + " ", void 0 === r[i] && (r[i] = o.needsContext ? Z(i, this).index(u) >= 0 : Z.find(i, this, null, [u]).length), r[i] && r.push(o);
                        r.length && s.push({
                            elem: u,
                            handlers: r
                        })
                    }
            return a < t.length && s.push({
                elem: this,
                handlers: t.slice(a)
            }), s
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function (e, t) {
                return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function (e, t) {
                var n, r, i, o = t.button;
                return null == e.pageX && null != t.clientX && (n = e.target.ownerDocument || J, r = n.documentElement, i = n.body, e.pageX = t.clientX + (r && r.scrollLeft || i && i.scrollLeft || 0) - (r && r.clientLeft || i && i.clientLeft || 0), e.pageY = t.clientY + (r && r.scrollTop || i && i.scrollTop || 0) - (r && r.clientTop || i && i.clientTop || 0)), e.which || void 0 === o || (e.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), e
            }
        },
        fix: function (e) {
            if (e[Z.expando]) return e;
            var t, n, r, i = e.type,
                o = e,
                s = this.fixHooks[i];
            for (s || (this.fixHooks[i] = s = St.test(i) ? this.mouseHooks : Et.test(i) ? this.keyHooks : {}), r = s.props ? this.props.concat(s.props) : this.props, e = new Z.Event(o), t = r.length; t--;) n = r[t], e[n] = o[n];
            return e.target || (e.target = J), 3 === e.target.nodeType && (e.target = e.target.parentNode), s.filter ? s.filter(e, o) : e
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function () {
                    return this !== f() && this.focus ? (this.focus(), !1) : void 0
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function () {
                    return this === f() && this.blur ? (this.blur(), !1) : void 0
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function () {
                    return "checkbox" === this.type && this.click && Z.nodeName(this, "input") ? (this.click(), !1) : void 0
                },
                _default: function (e) {
                    return Z.nodeName(e.target, "a")
                }
            },
            beforeunload: {
                postDispatch: function (e) {
                    void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                }
            }
        },
        simulate: function (e, t, n, r) {
            var i = Z.extend(new Z.Event, n, {
                type: e,
                isSimulated: !0,
                originalEvent: {}
            });
            r ? Z.event.trigger(i, null, t) : Z.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault()
        }
    }, Z.removeEvent = function (e, t, n) {
        e.removeEventListener && e.removeEventListener(t, n, !1)
    }, Z.Event = function (e, t) {
        return this instanceof Z.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && e.returnValue === !1 ? l : c) : this.type = e, t && Z.extend(this, t), this.timeStamp = e && e.timeStamp || Z.now(), void(this[Z.expando] = !0)) : new Z.Event(e, t)
    }, Z.Event.prototype = {
        isDefaultPrevented: c,
        isPropagationStopped: c,
        isImmediatePropagationStopped: c,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = l, e && e.preventDefault && e.preventDefault()
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = l, e && e.stopPropagation && e.stopPropagation()
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = l, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), this.stopPropagation()
        }
    }, Z.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (e, t) {
        Z.event.special[e] = {
            delegateType: t,
            bindType: t,
            handle: function (e) {
                var n, r = this,
                    i = e.relatedTarget,
                    o = e.handleObj;
                return (!i || i !== r && !Z.contains(r, i)) && (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n
            }
        }
    }), Q.focusinBubbles || Z.each({
        focus: "focusin",
        blur: "focusout"
    }, function (e, t) {
        var n = function (e) {
            Z.event.simulate(t, e.target, Z.event.fix(e), !0)
        };
        Z.event.special[t] = {
            setup: function () {
                var r = this.ownerDocument || this,
                    i = vt.access(r, t);
                i || r.addEventListener(e, n, !0), vt.access(r, t, (i || 0) + 1)
            },
            teardown: function () {
                var r = this.ownerDocument || this,
                    i = vt.access(r, t) - 1;
                i ? vt.access(r, t, i) : (r.removeEventListener(e, n, !0), vt.remove(r, t))
            }
        }
    }), Z.fn.extend({
        on: function (e, t, n, r, i) {
            var o, s;
            if ("object" == typeof e) {
                "string" != typeof t && (n = n || t, t = void 0);
                for (s in e) this.on(s, t, n, e[s], i);
                return this
            }
            if (null == n && null == r ? (r = t, n = t = void 0) : null == r && ("string" == typeof t ? (r = n, n = void 0) : (r = n, n = t, t = void 0)), r === !1) r = c;
            else if (!r) return this;
            return 1 === i && (o = r, r = function (e) {
                return Z().off(e), o.apply(this, arguments)
            }, r.guid = o.guid || (o.guid = Z.guid++)), this.each(function () {
                Z.event.add(this, e, r, n, t)
            })
        },
        one: function (e, t, n, r) {
            return this.on(e, t, n, r, 1)
        },
        off: function (e, t, n) {
            var r, i;
            if (e && e.preventDefault && e.handleObj) return r = e.handleObj, Z(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
            if ("object" == typeof e) {
                for (i in e) this.off(i, t, e[i]);
                return this
            }
            return (t === !1 || "function" == typeof t) && (n = t, t = void 0), n === !1 && (n = c), this.each(function () {
                Z.event.remove(this, e, n, t)
            })
        },
        trigger: function (e, t) {
            return this.each(function () {
                Z.event.trigger(e, t, this)
            })
        },
        triggerHandler: function (e, t) {
            var n = this[0];
            return n ? Z.event.trigger(e, t, n, !0) : void 0
        }
    });
    var At = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        Lt = /<([\w:]+)/,
        qt = /<|&#?\w+;/,
        Ht = /<(?:script|style|link)/i,
        Ot = /checked\s*(?:[^=]|=\s*.checked.)/i,
        Ft = /^$|\/(?:java|ecma)script/i,
        Pt = /^true\/(.*)/,
        Rt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
        Mt = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };
    Mt.optgroup = Mt.option, Mt.tbody = Mt.tfoot = Mt.colgroup = Mt.caption = Mt.thead, Mt.th = Mt.td, Z.extend({
        clone: function (e, t, n) {
            var r, i, o, s, a = e.cloneNode(!0),
                u = Z.contains(e.ownerDocument, e);
            if (!(Q.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || Z.isXMLDoc(e)))
                for (s = v(a), o = v(e), r = 0, i = o.length; i > r; r++) y(o[r], s[r]);
            if (t)
                if (n)
                    for (o = o || v(e), s = s || v(a), r = 0, i = o.length; i > r; r++) m(o[r], s[r]);
                else m(e, a);
            return s = v(a, "script"), s.length > 0 && g(s, !u && v(e, "script")), a
        },
        buildFragment: function (e, t, n, r) {
            for (var i, o, s, a, u, l, c = t.createDocumentFragment(), f = [], p = 0, d = e.length; d > p; p++)
                if (i = e[p], i || 0 === i)
                    if ("object" === Z.type(i)) Z.merge(f, i.nodeType ? [i] : i);
                    else if (qt.test(i)) {
                for (o = o || c.appendChild(t.createElement("div")), s = (Lt.exec(i) || ["", ""])[1].toLowerCase(), a = Mt[s] || Mt._default, o.innerHTML = a[1] + i.replace(At, "<$1></$2>") + a[2], l = a[0]; l--;) o = o.lastChild;
                Z.merge(f, o.childNodes), o = c.firstChild, o.textContent = ""
            } else f.push(t.createTextNode(i));
            for (c.textContent = "", p = 0; i = f[p++];)
                if ((!r || -1 === Z.inArray(i, r)) && (u = Z.contains(i.ownerDocument, i), o = v(c.appendChild(i), "script"), u && g(o), n))
                    for (l = 0; i = o[l++];) Ft.test(i.type || "") && n.push(i);
            return c
        },
        cleanData: function (e) {
            for (var t, n, r, i, o = Z.event.special, s = 0; void 0 !== (n = e[s]); s++) {
                if (Z.acceptData(n) && (i = n[vt.expando], i && (t = vt.cache[i]))) {
                    if (t.events)
                        for (r in t.events) o[r] ? Z.event.remove(n, r) : Z.removeEvent(n, r, t.handle);
                    vt.cache[i] && delete vt.cache[i]
                }
                delete yt.cache[n[yt.expando]]
            }
        }
    }), Z.fn.extend({
        text: function (e) {
            return mt(this, function (e) {
                return void 0 === e ? Z.text(this) : this.empty().each(function () {
                    (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = e)
                })
            }, null, e, arguments.length)
        },
        append: function () {
            return this.domManip(arguments, function (e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = p(this, e);
                    t.appendChild(e)
                }
            })
        },
        prepend: function () {
            return this.domManip(arguments, function (e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = p(this, e);
                    t.insertBefore(e, t.firstChild)
                }
            })
        },
        before: function () {
            return this.domManip(arguments, function (e) {
                this.parentNode && this.parentNode.insertBefore(e, this)
            })
        },
        after: function () {
            return this.domManip(arguments, function (e) {
                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
            })
        },
        remove: function (e, t) {
            for (var n, r = e ? Z.filter(e, this) : this, i = 0; null != (n = r[i]); i++) t || 1 !== n.nodeType || Z.cleanData(v(n)), n.parentNode && (t && Z.contains(n.ownerDocument, n) && g(v(n, "script")), n.parentNode.removeChild(n));
            return this
        },
        empty: function () {
            for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (Z.cleanData(v(e, !1)), e.textContent = "");
            return this
        },
        clone: function (e, t) {
            return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function () {
                return Z.clone(this, e, t)
            })
        },
        html: function (e) {
            return mt(this, function (e) {
                var t = this[0] || {},
                    n = 0,
                    r = this.length;
                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                if ("string" == typeof e && !Ht.test(e) && !Mt[(Lt.exec(e) || ["", ""])[1].toLowerCase()]) {
                    e = e.replace(At, "<$1></$2>");
                    try {
                        for (; r > n; n++) t = this[n] || {}, 1 === t.nodeType && (Z.cleanData(v(t, !1)), t.innerHTML = e);
                        t = 0
                    } catch (i) {}
                }
                t && this.empty().append(e)
            }, null, e, arguments.length)
        },
        replaceWith: function () {
            var e = arguments[0];
            return this.domManip(arguments, function (t) {
                e = this.parentNode, Z.cleanData(v(this)), e && e.replaceChild(t, this)
            }), e && (e.length || e.nodeType) ? this : this.remove()
        },
        detach: function (e) {
            return this.remove(e, !0)
        },
        domManip: function (e, t) {
            e = z.apply([], e);
            var n, r, i, o, s, a, u = 0,
                l = this.length,
                c = this,
                f = l - 1,
                p = e[0],
                g = Z.isFunction(p);
            if (g || l > 1 && "string" == typeof p && !Q.checkClone && Ot.test(p)) return this.each(function (n) {
                var r = c.eq(n);
                g && (e[0] = p.call(this, n, r.html())), r.domManip(e, t)
            });
            if (l && (n = Z.buildFragment(e, this[0].ownerDocument, !1, this), r = n.firstChild, 1 === n.childNodes.length && (n = r), r)) {
                for (i = Z.map(v(n, "script"), d), o = i.length; l > u; u++) s = n, u !== f && (s = Z.clone(s, !0, !0), o && Z.merge(i, v(s, "script"))), t.call(this[u], s, u);
                if (o)
                    for (a = i[i.length - 1].ownerDocument, Z.map(i, h), u = 0; o > u; u++) s = i[u], Ft.test(s.type || "") && !vt.access(s, "globalEval") && Z.contains(a, s) && (s.src ? Z._evalUrl && Z._evalUrl(s.src) : Z.globalEval(s.textContent.replace(Rt, "")))
            }
            return this
        }
    }), Z.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (e, t) {
        Z.fn[e] = function (e) {
            for (var n, r = [], i = Z(e), o = i.length - 1, s = 0; o >= s; s++) n = s === o ? this : this.clone(!0), Z(i[s])[t](n), X.apply(r, n.get());
            return this.pushStack(r)
        }
    });
    var Wt, $t = {},
        It = /^margin/,
        Bt = new RegExp("^(" + wt + ")(?!px)[a-z%]+$", "i"),
        _t = function (t) {
            return t.ownerDocument.defaultView.opener ? t.ownerDocument.defaultView.getComputedStyle(t, null) : e.getComputedStyle(t, null)
        };
    ! function () {
        function t() {
            s.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", s.innerHTML = "", i.appendChild(o);
            var t = e.getComputedStyle(s, null);
            n = "1%" !== t.top, r = "4px" === t.width, i.removeChild(o)
        }
        var n, r, i = J.documentElement,
            o = J.createElement("div"),
            s = J.createElement("div");
        s.style && (s.style.backgroundClip = "content-box", s.cloneNode(!0).style.backgroundClip = "", Q.clearCloneStyle = "content-box" === s.style.backgroundClip, o.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", o.appendChild(s), e.getComputedStyle && Z.extend(Q, {
            pixelPosition: function () {
                return t(), n
            },
            boxSizingReliable: function () {
                return null == r && t(), r
            },
            reliableMarginRight: function () {
                var t, n = s.appendChild(J.createElement("div"));
                return n.style.cssText = s.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", n.style.marginRight = n.style.width = "0", s.style.width = "1px", i.appendChild(o), t = !parseFloat(e.getComputedStyle(n, null).marginRight), i.removeChild(o), s.removeChild(n), t
            }
        }))
    }(), Z.swap = function (e, t, n, r) {
        var i, o, s = {};
        for (o in t) s[o] = e.style[o], e.style[o] = t[o];
        i = n.apply(e, r || []);
        for (o in t) e.style[o] = s[o];
        return i
    };
    var zt = /^(none|table(?!-c[ea]).+)/,
        Xt = new RegExp("^(" + wt + ")(.*)$", "i"),
        Ut = new RegExp("^([+-])=(" + wt + ")", "i"),
        Vt = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        },
        Yt = {
            letterSpacing: "0",
            fontWeight: "400"
        },
        Gt = ["Webkit", "O", "Moz", "ms"];
    Z.extend({
        cssHooks: {
            opacity: {
                get: function (e, t) {
                    if (t) {
                        var n = w(e, "opacity");
                        return "" === n ? "1" : n
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function (e, t, n, r) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var i, o, s, a = Z.camelCase(t),
                    u = e.style;
                return t = Z.cssProps[a] || (Z.cssProps[a] = C(u, a)), s = Z.cssHooks[t] || Z.cssHooks[a], void 0 === n ? s && "get" in s && void 0 !== (i = s.get(e, !1, r)) ? i : u[t] : (o = typeof n, "string" === o && (i = Ut.exec(n)) && (n = (i[1] + 1) * i[2] + parseFloat(Z.css(e, t)), o = "number"), null != n && n === n && ("number" !== o || Z.cssNumber[a] || (n += "px"), Q.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (u[t] = "inherit"), s && "set" in s && void 0 === (n = s.set(e, n, r)) || (u[t] = n)), void 0)
            }
        },
        css: function (e, t, n, r) {
            var i, o, s, a = Z.camelCase(t);
            return t = Z.cssProps[a] || (Z.cssProps[a] = C(e.style, a)), s = Z.cssHooks[t] || Z.cssHooks[a], s && "get" in s && (i = s.get(e, !0, n)), void 0 === i && (i = w(e, t, r)), "normal" === i && t in Yt && (i = Yt[t]), "" === n || n ? (o = parseFloat(i), n === !0 || Z.isNumeric(o) ? o || 0 : i) : i
        }
    }), Z.each(["height", "width"], function (e, t) {
        Z.cssHooks[t] = {
            get: function (e, n, r) {
                return n ? zt.test(Z.css(e, "display")) && 0 === e.offsetWidth ? Z.swap(e, Vt, function () {
                    return E(e, t, r)
                }) : E(e, t, r) : void 0
            },
            set: function (e, n, r) {
                var i = r && _t(e);
                return N(e, n, r ? k(e, t, r, "border-box" === Z.css(e, "boxSizing", !1, i), i) : 0)
            }
        }
    }), Z.cssHooks.marginRight = T(Q.reliableMarginRight, function (e, t) {
        return t ? Z.swap(e, {
            display: "inline-block"
        }, w, [e, "marginRight"]) : void 0
    }), Z.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function (e, t) {
        Z.cssHooks[e + t] = {
            expand: function (n) {
                for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; 4 > r; r++) i[e + Tt[r] + t] = o[r] || o[r - 2] || o[0];
                return i
            }
        }, It.test(e) || (Z.cssHooks[e + t].set = N)
    }), Z.fn.extend({
        css: function (e, t) {
            return mt(this, function (e, t, n) {
                var r, i, o = {},
                    s = 0;
                if (Z.isArray(t)) {
                    for (r = _t(e), i = t.length; i > s; s++) o[t[s]] = Z.css(e, t[s], !1, r);
                    return o
                }
                return void 0 !== n ? Z.style(e, t, n) : Z.css(e, t)
            }, e, t, arguments.length > 1)
        },
        show: function () {
            return S(this, !0)
        },
        hide: function () {
            return S(this)
        },
        toggle: function (e) {
            return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
                Ct(this) ? Z(this).show() : Z(this).hide()
            })
        }
    }), Z.Tween = D, D.prototype = {
        constructor: D,
        init: function (e, t, n, r, i, o) {
            this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (Z.cssNumber[n] ? "" : "px")
        },
        cur: function () {
            var e = D.propHooks[this.prop];
            return e && e.get ? e.get(this) : D.propHooks._default.get(this)
        },
        run: function (e) {
            var t, n = D.propHooks[this.prop];
            return this.pos = t = this.options.duration ? Z.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : D.propHooks._default.set(this), this
        }
    }, D.prototype.init.prototype = D.prototype, D.propHooks = {
        _default: {
            get: function (e) {
                var t;
                return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = Z.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop]
            },
            set: function (e) {
                Z.fx.step[e.prop] ? Z.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[Z.cssProps[e.prop]] || Z.cssHooks[e.prop]) ? Z.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now
            }
        }
    }, D.propHooks.scrollTop = D.propHooks.scrollLeft = {
        set: function (e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
        }
    }, Z.easing = {
        linear: function (e) {
            return e
        },
        swing: function (e) {
            return .5 - Math.cos(e * Math.PI) / 2
        }
    }, Z.fx = D.prototype.init, Z.fx.step = {};
    var Qt, Jt, Kt = /^(?:toggle|show|hide)$/,
        Zt = new RegExp("^(?:([+-])=|)(" + wt + ")([a-z%]*)$", "i"),
        en = /queueHooks$/,
        tn = [q],
        nn = {
            "*": [function (e, t) {
                var n = this.createTween(e, t),
                    r = n.cur(),
                    i = Zt.exec(t),
                    o = i && i[3] || (Z.cssNumber[e] ? "" : "px"),
                    s = (Z.cssNumber[e] || "px" !== o && +r) && Zt.exec(Z.css(n.elem, e)),
                    a = 1,
                    u = 20;
                if (s && s[3] !== o) {
                    o = o || s[3], i = i || [], s = +r || 1;
                    do a = a || ".5", s /= a, Z.style(n.elem, e, s + o); while (a !== (a = n.cur() / r) && 1 !== a && --u)
                }
                return i && (s = n.start = +s || +r || 0, n.unit = o, n.end = i[1] ? s + (i[1] + 1) * i[2] : +i[2]), n
            }]
        };
    Z.Animation = Z.extend(O, {
            tweener: function (e, t) {
                Z.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");
                for (var n, r = 0, i = e.length; i > r; r++) n = e[r], nn[n] = nn[n] || [], nn[n].unshift(t)
            },
            prefilter: function (e, t) {
                t ? tn.unshift(e) : tn.push(e)
            }
        }), Z.speed = function (e, t, n) {
            var r = e && "object" == typeof e ? Z.extend({}, e) : {
                complete: n || !n && t || Z.isFunction(e) && e,
                duration: e,
                easing: n && t || t && !Z.isFunction(t) && t
            };
            return r.duration = Z.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in Z.fx.speeds ? Z.fx.speeds[r.duration] : Z.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = "fx"), r.old = r.complete, r.complete = function () {
                Z.isFunction(r.old) && r.old.call(this), r.queue && Z.dequeue(this, r.queue)
            }, r
        }, Z.fn.extend({
            fadeTo: function (e, t, n, r) {
                return this.filter(Ct).css("opacity", 0).show().end().animate({
                    opacity: t
                }, e, n, r)
            },
            animate: function (e, t, n, r) {
                var i = Z.isEmptyObject(e),
                    o = Z.speed(t, n, r),
                    s = function () {
                        var t = O(this, Z.extend({}, e), o);
                        (i || vt.get(this, "finish")) && t.stop(!0)
                    };
                return s.finish = s, i || o.queue === !1 ? this.each(s) : this.queue(o.queue, s)
            },
            stop: function (e, t, n) {
                var r = function (e) {
                    var t = e.stop;
                    delete e.stop, t(n)
                };
                return "string" != typeof e && (n = t, t = e, e = void 0), t && e !== !1 && this.queue(e || "fx", []), this.each(function () {
                    var t = !0,
                        i = null != e && e + "queueHooks",
                        o = Z.timers,
                        s = vt.get(this);
                    if (i) s[i] && s[i].stop && r(s[i]);
                    else
                        for (i in s) s[i] && s[i].stop && en.test(i) && r(s[i]);
                    for (i = o.length; i--;) o[i].elem !== this || null != e && o[i].queue !== e || (o[i].anim.stop(n), t = !1, o.splice(i, 1));
                    (t || !n) && Z.dequeue(this, e)
                })
            },
            finish: function (e) {
                return e !== !1 && (e = e || "fx"), this.each(function () {
                    var t, n = vt.get(this),
                        r = n[e + "queue"],
                        i = n[e + "queueHooks"],
                        o = Z.timers,
                        s = r ? r.length : 0;
                    for (n.finish = !0, Z.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
                    for (t = 0; s > t; t++) r[t] && r[t].finish && r[t].finish.call(this);
                    delete n.finish
                })
            }
        }), Z.each(["toggle", "show", "hide"], function (e, t) {
            var n = Z.fn[t];
            Z.fn[t] = function (e, r, i) {
                return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(A(t, !0), e, r, i)
            }
        }), Z.each({
            slideDown: A("show"),
            slideUp: A("hide"),
            slideToggle: A("toggle"),
            fadeIn: {
                opacity: "show"
            },
            fadeOut: {
                opacity: "hide"
            },
            fadeToggle: {
                opacity: "toggle"
            }
        }, function (e, t) {
            Z.fn[e] = function (e, n, r) {
                return this.animate(t, e, n, r)
            }
        }), Z.timers = [], Z.fx.tick = function () {
            var e, t = 0,
                n = Z.timers;
            for (Qt = Z.now(); t < n.length; t++) e = n[t], e() || n[t] !== e || n.splice(t--, 1);
            n.length || Z.fx.stop(), Qt = void 0
        }, Z.fx.timer = function (e) {
            Z.timers.push(e), e() ? Z.fx.start() : Z.timers.pop()
        }, Z.fx.interval = 13, Z.fx.start = function () {
            Jt || (Jt = setInterval(Z.fx.tick, Z.fx.interval))
        }, Z.fx.stop = function () {
            clearInterval(Jt), Jt = null
        }, Z.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        }, Z.fn.delay = function (e, t) {
            return e = Z.fx ? Z.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function (t, n) {
                var r = setTimeout(t, e);
                n.stop = function () {
                    clearTimeout(r)
                }
            })
        },
        function () {
            var e = J.createElement("input"),
                t = J.createElement("select"),
                n = t.appendChild(J.createElement("option"));
            e.type = "checkbox", Q.checkOn = "" !== e.value, Q.optSelected = n.selected, t.disabled = !0, Q.optDisabled = !n.disabled, e = J.createElement("input"), e.value = "t", e.type = "radio", Q.radioValue = "t" === e.value
        }();
    var rn, on, sn = Z.expr.attrHandle;
    Z.fn.extend({
        attr: function (e, t) {
            return mt(this, Z.attr, e, t, arguments.length > 1)
        },
        removeAttr: function (e) {
            return this.each(function () {
                Z.removeAttr(this, e)
            })
        }
    }), Z.extend({
        attr: function (e, t, n) {
            var r, i, o = e.nodeType;
            return e && 3 !== o && 8 !== o && 2 !== o ? typeof e.getAttribute === kt ? Z.prop(e, t, n) : (1 === o && Z.isXMLDoc(e) || (t = t.toLowerCase(), r = Z.attrHooks[t] || (Z.expr.match.bool.test(t) ? on : rn)), void 0 === n ? r && "get" in r && null !== (i = r.get(e, t)) ? i : (i = Z.find.attr(e, t), null == i ? void 0 : i) : null !== n ? r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : void Z.removeAttr(e, t)) : void 0
        },
        removeAttr: function (e, t) {
            var n, r, i = 0,
                o = t && t.match(dt);
            if (o && 1 === e.nodeType)
                for (; n = o[i++];) r = Z.propFix[n] || n, Z.expr.match.bool.test(n) && (e[r] = !1), e.removeAttribute(n)
        },
        attrHooks: {
            type: {
                set: function (e, t) {
                    if (!Q.radioValue && "radio" === t && Z.nodeName(e, "input")) {
                        var n = e.value;
                        return e.setAttribute("type", t), n && (e.value = n), t
                    }
                }
            }
        }
    }), on = {
        set: function (e, t, n) {
            return t === !1 ? Z.removeAttr(e, n) : e.setAttribute(n, n), n
        }
    }, Z.each(Z.expr.match.bool.source.match(/\w+/g), function (e, t) {
        var n = sn[t] || Z.find.attr;
        sn[t] = function (e, t, r) {
            var i, o;
            return r || (o = sn[t], sn[t] = i, i = null != n(e, t, r) ? t.toLowerCase() : null, sn[t] = o), i
        }
    });
    var an = /^(?:input|select|textarea|button)$/i;
    Z.fn.extend({
        prop: function (e, t) {
            return mt(this, Z.prop, e, t, arguments.length > 1)
        },
        removeProp: function (e) {
            return this.each(function () {
                delete this[Z.propFix[e] || e]
            })
        }
    }), Z.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function (e, t, n) {
            var r, i, o, s = e.nodeType;
            return e && 3 !== s && 8 !== s && 2 !== s ? (o = 1 !== s || !Z.isXMLDoc(e), o && (t = Z.propFix[t] || t, i = Z.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t]) : void 0
        },
        propHooks: {
            tabIndex: {
                get: function (e) {
                    return e.hasAttribute("tabindex") || an.test(e.nodeName) || e.href ? e.tabIndex : -1
                }
            }
        }
    }), Q.optSelected || (Z.propHooks.selected = {
        get: function (e) {
            var t = e.parentNode;
            return t && t.parentNode && t.parentNode.selectedIndex, null
        }
    }), Z.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        Z.propFix[this.toLowerCase()] = this
    });
    var un = /[\t\r\n\f]/g;
    Z.fn.extend({
        addClass: function (e) {
            var t, n, r, i, o, s, a = "string" == typeof e && e,
                u = 0,
                l = this.length;
            if (Z.isFunction(e)) return this.each(function (t) {
                Z(this).addClass(e.call(this, t, this.className))
            });
            if (a)
                for (t = (e || "").match(dt) || []; l > u; u++)
                    if (n = this[u], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(un, " ") : " ")) {
                        for (o = 0; i = t[o++];) r.indexOf(" " + i + " ") < 0 && (r += i + " ");
                        s = Z.trim(r), n.className !== s && (n.className = s)
                    }
            return this
        },
        removeClass: function (e) {
            var t, n, r, i, o, s, a = 0 === arguments.length || "string" == typeof e && e,
                u = 0,
                l = this.length;
            if (Z.isFunction(e)) return this.each(function (t) {
                Z(this).removeClass(e.call(this, t, this.className))
            });
            if (a)
                for (t = (e || "").match(dt) || []; l > u; u++)
                    if (n = this[u], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(un, " ") : "")) {
                        for (o = 0; i = t[o++];)
                            for (; r.indexOf(" " + i + " ") >= 0;) r = r.replace(" " + i + " ", " ");
                        s = e ? Z.trim(r) : "", n.className !== s && (n.className = s)
                    }
            return this
        },
        toggleClass: function (e, t) {
            var n = typeof e;
            return "boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : this.each(Z.isFunction(e) ? function (n) {
                Z(this).toggleClass(e.call(this, n, this.className, t), t)
            } : function () {
                if ("string" === n)
                    for (var t, r = 0, i = Z(this), o = e.match(dt) || []; t = o[r++];) i.hasClass(t) ? i.removeClass(t) : i.addClass(t);
                else(n === kt || "boolean" === n) && (this.className && vt.set(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : vt.get(this, "__className__") || "")
            })
        },
        hasClass: function (e) {
            for (var t = " " + e + " ", n = 0, r = this.length; r > n; n++)
                if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(un, " ").indexOf(t) >= 0) return !0;
            return !1
        }
    });
    var ln = /\r/g;
    Z.fn.extend({
        val: function (e) {
            var t, n, r, i = this[0];
            return arguments.length ? (r = Z.isFunction(e), this.each(function (n) {
                var i;
                1 === this.nodeType && (i = r ? e.call(this, n, Z(this).val()) : e, null == i ? i = "" : "number" == typeof i ? i += "" : Z.isArray(i) && (i = Z.map(i, function (e) {
                    return null == e ? "" : e + ""
                })), t = Z.valHooks[this.type] || Z.valHooks[this.nodeName.toLowerCase()], t && "set" in t && void 0 !== t.set(this, i, "value") || (this.value = i))
            })) : i ? (t = Z.valHooks[i.type] || Z.valHooks[i.nodeName.toLowerCase()], t && "get" in t && void 0 !== (n = t.get(i, "value")) ? n : (n = i.value, "string" == typeof n ? n.replace(ln, "") : null == n ? "" : n)) : void 0
        }
    }), Z.extend({
        valHooks: {
            option: {
                get: function (e) {
                    var t = Z.find.attr(e, "value");
                    return null != t ? t : Z.trim(Z.text(e))
                }
            },
            select: {
                get: function (e) {
                    for (var t, n, r = e.options, i = e.selectedIndex, o = "select-one" === e.type || 0 > i, s = o ? null : [], a = o ? i + 1 : r.length, u = 0 > i ? a : o ? i : 0; a > u; u++)
                        if (n = r[u], !(!n.selected && u !== i || (Q.optDisabled ? n.disabled : null !== n.getAttribute("disabled")) || n.parentNode.disabled && Z.nodeName(n.parentNode, "optgroup"))) {
                            if (t = Z(n).val(), o) return t;
                            s.push(t)
                        }
                    return s
                },
                set: function (e, t) {
                    for (var n, r, i = e.options, o = Z.makeArray(t), s = i.length; s--;) r = i[s], (r.selected = Z.inArray(r.value, o) >= 0) && (n = !0);
                    return n || (e.selectedIndex = -1), o
                }
            }
        }
    }), Z.each(["radio", "checkbox"], function () {
        Z.valHooks[this] = {
            set: function (e, t) {
                return Z.isArray(t) ? e.checked = Z.inArray(Z(e).val(), t) >= 0 : void 0
            }
        }, Q.checkOn || (Z.valHooks[this].get = function (e) {
            return null === e.getAttribute("value") ? "on" : e.value
        })
    }), Z.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (e, t) {
        Z.fn[t] = function (e, n) {
            return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
        }
    }), Z.fn.extend({
        hover: function (e, t) {
            return this.mouseenter(e).mouseleave(t || e)
        },
        bind: function (e, t, n) {
            return this.on(e, null, t, n)
        },
        unbind: function (e, t) {
            return this.off(e, null, t)
        },
        delegate: function (e, t, n, r) {
            return this.on(t, e, n, r)
        },
        undelegate: function (e, t, n) {
            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
        }
    });
    var cn = Z.now(),
        fn = /\?/;
    Z.parseJSON = function (e) {
        return JSON.parse(e + "")
    }, Z.parseXML = function (e) {
        var t, n;
        if (!e || "string" != typeof e) return null;
        try {
            n = new DOMParser, t = n.parseFromString(e, "text/xml")
        } catch (r) {
            t = void 0
        }
        return (!t || t.getElementsByTagName("parsererror").length) && Z.error("Invalid XML: " + e), t
    };
    var pn = /#.*$/,
        dn = /([?&])_=[^&]*/,
        hn = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        gn = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        mn = /^(?:GET|HEAD)$/,
        vn = /^\/\//,
        yn = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
        xn = {},
        bn = {},
        wn = "*/".concat("*"),
        Tn = e.location.href,
        Cn = yn.exec(Tn.toLowerCase()) || [];
    Z.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Tn,
            type: "GET",
            isLocal: gn.test(Cn[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": wn,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": Z.parseJSON,
                "text xml": Z.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function (e, t) {
            return t ? R(R(e, Z.ajaxSettings), t) : R(Z.ajaxSettings, e)
        },
        ajaxPrefilter: F(xn),
        ajaxTransport: F(bn),
        ajax: function (e, t) {
            function n(e, t, n, s) {
                var u, c, v, y, b, T = t;
                2 !== x && (x = 2, a && clearTimeout(a), r = void 0, o = s || "", w.readyState = e > 0 ? 4 : 0, u = e >= 200 && 300 > e || 304 === e, n && (y = M(f, w, n)), y = W(f, y, w, u), u ? (f.ifModified && (b = w.getResponseHeader("Last-Modified"), b && (Z.lastModified[i] = b), b = w.getResponseHeader("etag"), b && (Z.etag[i] = b)), 204 === e || "HEAD" === f.type ? T = "nocontent" : 304 === e ? T = "notmodified" : (T = y.state, c = y.data, v = y.error, u = !v)) : (v = T, (e || !T) && (T = "error", 0 > e && (e = 0))), w.status = e, w.statusText = (t || T) + "", u ? h.resolveWith(p, [c, T, w]) : h.rejectWith(p, [w, T, v]), w.statusCode(m), m = void 0, l && d.trigger(u ? "ajaxSuccess" : "ajaxError", [w, f, u ? c : v]), g.fireWith(p, [w, T]), l && (d.trigger("ajaxComplete", [w, f]), --Z.active || Z.event.trigger("ajaxStop")))
            }
            "object" == typeof e && (t = e, e = void 0), t = t || {};
            var r, i, o, s, a, u, l, c, f = Z.ajaxSetup({}, t),
                p = f.context || f,
                d = f.context && (p.nodeType || p.jquery) ? Z(p) : Z.event,
                h = Z.Deferred(),
                g = Z.Callbacks("once memory"),
                m = f.statusCode || {},
                v = {},
                y = {},
                x = 0,
                b = "canceled",
                w = {
                    readyState: 0,
                    getResponseHeader: function (e) {
                        var t;
                        if (2 === x) {
                            if (!s)
                                for (s = {}; t = hn.exec(o);) s[t[1].toLowerCase()] = t[2];
                            t = s[e.toLowerCase()]
                        }
                        return null == t ? null : t
                    },
                    getAllResponseHeaders: function () {
                        return 2 === x ? o : null
                    },
                    setRequestHeader: function (e, t) {
                        var n = e.toLowerCase();
                        return x || (e = y[n] = y[n] || e, v[e] = t), this
                    },
                    overrideMimeType: function (e) {
                        return x || (f.mimeType = e), this
                    },
                    statusCode: function (e) {
                        var t;
                        if (e)
                            if (2 > x)
                                for (t in e) m[t] = [m[t], e[t]];
                            else w.always(e[w.status]);
                        return this
                    },
                    abort: function (e) {
                        var t = e || b;
                        return r && r.abort(t), n(0, t), this
                    }
                };
            if (h.promise(w).complete = g.add, w.success = w.done, w.error = w.fail, f.url = ((e || f.url || Tn) + "").replace(pn, "").replace(vn, Cn[1] + "//"), f.type = t.method || t.type || f.method || f.type, f.dataTypes = Z.trim(f.dataType || "*").toLowerCase().match(dt) || [""], null == f.crossDomain && (u = yn.exec(f.url.toLowerCase()), f.crossDomain = !(!u || u[1] === Cn[1] && u[2] === Cn[2] && (u[3] || ("http:" === u[1] ? "80" : "443")) === (Cn[3] || ("http:" === Cn[1] ? "80" : "443")))), f.data && f.processData && "string" != typeof f.data && (f.data = Z.param(f.data, f.traditional)), P(xn, f, t, w), 2 === x) return w;
            l = Z.event && f.global, l && 0 === Z.active++ && Z.event.trigger("ajaxStart"), f.type = f.type.toUpperCase(), f.hasContent = !mn.test(f.type), i = f.url, f.hasContent || (f.data && (i = f.url += (fn.test(i) ? "&" : "?") + f.data, delete f.data), f.cache === !1 && (f.url = dn.test(i) ? i.replace(dn, "$1_=" + cn++) : i + (fn.test(i) ? "&" : "?") + "_=" + cn++)), f.ifModified && (Z.lastModified[i] && w.setRequestHeader("If-Modified-Since", Z.lastModified[i]), Z.etag[i] && w.setRequestHeader("If-None-Match", Z.etag[i])), (f.data && f.hasContent && f.contentType !== !1 || t.contentType) && w.setRequestHeader("Content-Type", f.contentType), w.setRequestHeader("Accept", f.dataTypes[0] && f.accepts[f.dataTypes[0]] ? f.accepts[f.dataTypes[0]] + ("*" !== f.dataTypes[0] ? ", " + wn + "; q=0.01" : "") : f.accepts["*"]);
            for (c in f.headers) w.setRequestHeader(c, f.headers[c]);
            if (f.beforeSend && (f.beforeSend.call(p, w, f) === !1 || 2 === x)) return w.abort();
            b = "abort";
            for (c in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) w[c](f[c]);
            if (r = P(bn, f, t, w)) {
                w.readyState = 1, l && d.trigger("ajaxSend", [w, f]), f.async && f.timeout > 0 && (a = setTimeout(function () {
                    w.abort("timeout")
                }, f.timeout));
                try {
                    x = 1, r.send(v, n)
                } catch (T) {
                    if (!(2 > x)) throw T;
                    n(-1, T)
                }
            } else n(-1, "No Transport");
            return w
        },
        getJSON: function (e, t, n) {
            return Z.get(e, t, n, "json")
        },
        getScript: function (e, t) {
            return Z.get(e, void 0, t, "script")
        }
    }), Z.each(["get", "post"], function (e, t) {
        Z[t] = function (e, n, r, i) {
            return Z.isFunction(n) && (i = i || r, r = n, n = void 0), Z.ajax({
                url: e,
                type: t,
                dataType: i,
                data: n,
                success: r
            })
        }
    }), Z._evalUrl = function (e) {
        return Z.ajax({
            url: e,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            "throws": !0
        })
    }, Z.fn.extend({
        wrapAll: function (e) {
            var t;
            return Z.isFunction(e) ? this.each(function (t) {
                Z(this).wrapAll(e.call(this, t))
            }) : (this[0] && (t = Z(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
                for (var e = this; e.firstElementChild;) e = e.firstElementChild;
                return e
            }).append(this)), this)
        },
        wrapInner: function (e) {
            return this.each(Z.isFunction(e) ? function (t) {
                Z(this).wrapInner(e.call(this, t))
            } : function () {
                var t = Z(this),
                    n = t.contents();
                n.length ? n.wrapAll(e) : t.append(e)
            })
        },
        wrap: function (e) {
            var t = Z.isFunction(e);
            return this.each(function (n) {
                Z(this).wrapAll(t ? e.call(this, n) : e)
            })
        },
        unwrap: function () {
            return this.parent().each(function () {
                Z.nodeName(this, "body") || Z(this).replaceWith(this.childNodes)
            }).end()
        }
    }), Z.expr.filters.hidden = function (e) {
        return e.offsetWidth <= 0 && e.offsetHeight <= 0
    }, Z.expr.filters.visible = function (e) {
        return !Z.expr.filters.hidden(e)
    };
    var Nn = /%20/g,
        kn = /\[\]$/,
        En = /\r?\n/g,
        Sn = /^(?:submit|button|image|reset|file)$/i,
        Dn = /^(?:input|select|textarea|keygen)/i;
    Z.param = function (e, t) {
        var n, r = [],
            i = function (e, t) {
                t = Z.isFunction(t) ? t() : null == t ? "" : t, r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
            };
        if (void 0 === t && (t = Z.ajaxSettings && Z.ajaxSettings.traditional), Z.isArray(e) || e.jquery && !Z.isPlainObject(e)) Z.each(e, function () {
            i(this.name, this.value)
        });
        else
            for (n in e) $(n, e[n], t, i);
        return r.join("&").replace(Nn, "+")
    }, Z.fn.extend({
        serialize: function () {
            return Z.param(this.serializeArray())
        },
        serializeArray: function () {
            return this.map(function () {
                var e = Z.prop(this, "elements");
                return e ? Z.makeArray(e) : this
            }).filter(function () {
                var e = this.type;
                return this.name && !Z(this).is(":disabled") && Dn.test(this.nodeName) && !Sn.test(e) && (this.checked || !Nt.test(e))
            }).map(function (e, t) {
                var n = Z(this).val();
                return null == n ? null : Z.isArray(n) ? Z.map(n, function (e) {
                    return {
                        name: t.name,
                        value: e.replace(En, "\r\n")
                    }
                }) : {
                    name: t.name,
                    value: n.replace(En, "\r\n")
                }
            }).get()
        }
    }), Z.ajaxSettings.xhr = function () {
        try {
            return new XMLHttpRequest
        } catch (e) {}
    };
    var jn = 0,
        An = {},
        Ln = {
            0: 200,
            1223: 204
        },
        qn = Z.ajaxSettings.xhr();
    e.attachEvent && e.attachEvent("onunload", function () {
        for (var e in An) An[e]()
    }), Q.cors = !!qn && "withCredentials" in qn, Q.ajax = qn = !!qn, Z.ajaxTransport(function (e) {
        var t;
        return Q.cors || qn && !e.crossDomain ? {
            send: function (n, r) {
                var i, o = e.xhr(),
                    s = ++jn;
                if (o.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields)
                    for (i in e.xhrFields) o[i] = e.xhrFields[i];
                e.mimeType && o.overrideMimeType && o.overrideMimeType(e.mimeType), e.crossDomain || n["X-Requested-With"] || (n["X-Requested-With"] = "XMLHttpRequest");
                for (i in n) o.setRequestHeader(i, n[i]);
                t = function (e) {
                    return function () {
                        t && (delete An[s], t = o.onload = o.onerror = null, "abort" === e ? o.abort() : "error" === e ? r(o.status, o.statusText) : r(Ln[o.status] || o.status, o.statusText, "string" == typeof o.responseText ? {
                            text: o.responseText
                        } : void 0, o.getAllResponseHeaders()))
                    }
                }, o.onload = t(), o.onerror = t("error"), t = An[s] = t("abort");
                try {
                    o.send(e.hasContent && e.data || null)
                } catch (a) {
                    if (t) throw a
                }
            },
            abort: function () {
                t && t()
            }
        } : void 0
    }), Z.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function (e) {
                return Z.globalEval(e), e
            }
        }
    }), Z.ajaxPrefilter("script", function (e) {
        void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
    }), Z.ajaxTransport("script", function (e) {
        if (e.crossDomain) {
            var t, n;
            return {
                send: function (r, i) {
                    t = Z("<script>").prop({
                        async: !0,
                        charset: e.scriptCharset,
                        src: e.url
                    }).on("load error", n = function (e) {
                        t.remove(), n = null, e && i("error" === e.type ? 404 : 200, e.type)
                    }), J.head.appendChild(t[0])
                },
                abort: function () {
                    n && n()
                }
            }
        }
    });
    var Hn = [],
        On = /(=)\?(?=&|$)|\?\?/;
    Z.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            var e = Hn.pop() || Z.expando + "_" + cn++;
            return this[e] = !0, e
        }
    }), Z.ajaxPrefilter("json jsonp", function (t, n, r) {
        var i, o, s, a = t.jsonp !== !1 && (On.test(t.url) ? "url" : "string" == typeof t.data && !(t.contentType || "").indexOf("application/x-www-form-urlencoded") && On.test(t.data) && "data");
        return a || "jsonp" === t.dataTypes[0] ? (i = t.jsonpCallback = Z.isFunction(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, a ? t[a] = t[a].replace(On, "$1" + i) : t.jsonp !== !1 && (t.url += (fn.test(t.url) ? "&" : "?") + t.jsonp + "=" + i), t.converters["script json"] = function () {
            return s || Z.error(i + " was not called"), s[0]
        }, t.dataTypes[0] = "json", o = e[i], e[i] = function () {
            s = arguments
        }, r.always(function () {
            e[i] = o, t[i] && (t.jsonpCallback = n.jsonpCallback, Hn.push(i)), s && Z.isFunction(o) && o(s[0]), s = o = void 0
        }), "script") : void 0
    }), Z.parseHTML = function (e, t, n) {
        if (!e || "string" != typeof e) return null;
        "boolean" == typeof t && (n = t, t = !1), t = t || J;
        var r = st.exec(e),
            i = !n && [];
        return r ? [t.createElement(r[1])] : (r = Z.buildFragment([e], t, i), i && i.length && Z(i).remove(), Z.merge([], r.childNodes))
    };
    var Fn = Z.fn.load;
    Z.fn.load = function (e, t, n) {
        if ("string" != typeof e && Fn) return Fn.apply(this, arguments);
        var r, i, o, s = this,
            a = e.indexOf(" ");
        return a >= 0 && (r = Z.trim(e.slice(a)), e = e.slice(0, a)), Z.isFunction(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), s.length > 0 && Z.ajax({
            url: e,
            type: i,
            dataType: "html",
            data: t
        }).done(function (e) {
            o = arguments, s.html(r ? Z("<div>").append(Z.parseHTML(e)).find(r) : e)
        }).complete(n && function (e, t) {
            s.each(n, o || [e.responseText, t, e])
        }), this
    }, Z.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
        Z.fn[t] = function (e) {
            return this.on(t, e)
        }
    }), Z.expr.filters.animated = function (e) {
        return Z.grep(Z.timers, function (t) {
            return e === t.elem
        }).length
    };
    var Pn = e.document.documentElement;
    Z.offset = {
        setOffset: function (e, t, n) {
            var r, i, o, s, a, u, l, c = Z.css(e, "position"),
                f = Z(e),
                p = {};
            "static" === c && (e.style.position = "relative"), a = f.offset(), o = Z.css(e, "top"), u = Z.css(e, "left"), l = ("absolute" === c || "fixed" === c) && (o + u).indexOf("auto") > -1, l ? (r = f.position(), s = r.top, i = r.left) : (s = parseFloat(o) || 0, i = parseFloat(u) || 0), Z.isFunction(t) && (t = t.call(e, n, a)), null != t.top && (p.top = t.top - a.top + s), null != t.left && (p.left = t.left - a.left + i), "using" in t ? t.using.call(e, p) : f.css(p)
        }
    }, Z.fn.extend({
        offset: function (e) {
            if (arguments.length) return void 0 === e ? this : this.each(function (t) {
                Z.offset.setOffset(this, e, t)
            });
            var t, n, r = this[0],
                i = {
                    top: 0,
                    left: 0
                },
                o = r && r.ownerDocument;
            return o ? (t = o.documentElement, Z.contains(t, r) ? (typeof r.getBoundingClientRect !== kt && (i = r.getBoundingClientRect()), n = I(o), {
                top: i.top + n.pageYOffset - t.clientTop,
                left: i.left + n.pageXOffset - t.clientLeft
            }) : i) : void 0
        },
        position: function () {
            if (this[0]) {
                var e, t, n = this[0],
                    r = {
                        top: 0,
                        left: 0
                    };
                return "fixed" === Z.css(n, "position") ? t = n.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), Z.nodeName(e[0], "html") || (r = e.offset()), r.top += Z.css(e[0], "borderTopWidth", !0), r.left += Z.css(e[0], "borderLeftWidth", !0)), {
                    top: t.top - r.top - Z.css(n, "marginTop", !0),
                    left: t.left - r.left - Z.css(n, "marginLeft", !0)
                }
            }
        },
        offsetParent: function () {
            return this.map(function () {
                for (var e = this.offsetParent || Pn; e && !Z.nodeName(e, "html") && "static" === Z.css(e, "position");) e = e.offsetParent;
                return e || Pn
            })
        }
    }), Z.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function (t, n) {
        var r = "pageYOffset" === n;
        Z.fn[t] = function (i) {
            return mt(this, function (t, i, o) {
                var s = I(t);
                return void 0 === o ? s ? s[n] : t[i] : void(s ? s.scrollTo(r ? e.pageXOffset : o, r ? o : e.pageYOffset) : t[i] = o)
            }, t, i, arguments.length, null)
        }
    }), Z.each(["top", "left"], function (e, t) {
        Z.cssHooks[t] = T(Q.pixelPosition, function (e, n) {
            return n ? (n = w(e, t), Bt.test(n) ? Z(e).position()[t] + "px" : n) : void 0
        })
    }), Z.each({
        Height: "height",
        Width: "width"
    }, function (e, t) {
        Z.each({
            padding: "inner" + e,
            content: t,
            "": "outer" + e
        }, function (n, r) {
            Z.fn[r] = function (r, i) {
                var o = arguments.length && (n || "boolean" != typeof r),
                    s = n || (r === !0 || i === !0 ? "margin" : "border");
                return mt(this, function (t, n, r) {
                    var i;
                    return Z.isWindow(t) ? t.document.documentElement["client" + e] : 9 === t.nodeType ? (i = t.documentElement, Math.max(t.body["scroll" + e], i["scroll" + e], t.body["offset" + e], i["offset" + e], i["client" + e])) : void 0 === r ? Z.css(t, n, s) : Z.style(t, n, r, s)
                }, t, o ? r : void 0, o, null)
            }
        })
    }), Z.fn.size = function () {
        return this.length
    }, Z.fn.andSelf = Z.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () {
        return Z
    });
    var Rn = e.jQuery,
        Mn = e.$;
    return Z.noConflict = function (t) {
        return e.$ === Z && (e.$ = Mn), t && e.jQuery === Z && (e.jQuery = Rn), Z
    }, typeof t === kt && (e.jQuery = e.$ = Z), Z
});
! function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t(e.THREE = e.THREE || {})
}(this, function (e) {
    function t() {}

    function i(e, t) {
        this.x = e || 0, this.y = t || 0
    }

    function n(e, t, r, a, o, s, c, h, l, u) {
        Object.defineProperty(this, "id", {
            value: wa++
        }), this.uuid = _a.generateUUID(), this.name = "", this.image = void 0 !== e ? e : n.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : n.DEFAULT_MAPPING, this.wrapS = void 0 !== r ? r : 1001, this.wrapT = void 0 !== a ? a : 1001, this.magFilter = void 0 !== o ? o : 1006, this.minFilter = void 0 !== s ? s : 1008, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== c ? c : 1023, this.type = void 0 !== h ? h : 1009, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== u ? u : 3e3, this.version = 0, this.onUpdate = null
    }

    function r(e, t, i, n) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
    }

    function a(e, t, i) {
        this.uuid = _a.generateUUID(), this.width = e, this.height = t, this.scissor = new r(0, 0, e, t), this.scissorTest = !1, this.viewport = new r(0, 0, e, t), i = i || {}, void 0 === i.minFilter && (i.minFilter = 1006), this.texture = new n(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.depthBuffer = void 0 !== i.depthBuffer ? i.depthBuffer : !0, this.stencilBuffer = void 0 !== i.stencilBuffer ? i.stencilBuffer : !0, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }

    function o(e, t, i) {
        a.call(this, e, t, i), this.activeMipMapLevel = this.activeCubeFace = 0
    }

    function s(e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
    }

    function c(e, t, i) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0
    }

    function h() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function l(e, t, i, r, a, o, s, c, h, l, u, p) {
        n.call(this, null, o, s, c, h, l, r, a, u, p), this.image = {
            data: e,
            width: t,
            height: i
        }, this.magFilter = void 0 !== h ? h : 1003, this.minFilter = void 0 !== l ? l : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1
    }

    function u(e, t, i, r, a, o, s, c, h, l) {
        e = void 0 !== e ? e : [], n.call(this, e, void 0 !== t ? t : 301, i, r, a, o, s, c, h, l), this.flipY = !1
    }

    function p(e, t, i) {
        var n = e[0];
        if (0 >= n || n > 0) return e;
        var r = t * i,
            a = Ta[r];
        if (void 0 === a && (a = new Float32Array(r), Ta[r] = a), 0 !== t)
            for (n.toArray(a, 0), n = 1, r = 0; n !== t; ++n) r += i, e[n].toArray(a, r);
        return a
    }

    function d(e, t) {
        var i = Sa[t];
        void 0 === i && (i = new Int32Array(t), Sa[t] = i);
        for (var n = 0; n !== t; ++n) i[n] = e.allocTextureUnit();
        return i
    }

    function f(e, t) {
        e.uniform1f(this.addr, t)
    }

    function m(e, t) {
        e.uniform1i(this.addr, t)
    }

    function g(e, t) {
        void 0 === t.x ? e.uniform2fv(this.addr, t) : e.uniform2f(this.addr, t.x, t.y)
    }

    function v(e, t) {
        void 0 !== t.x ? e.uniform3f(this.addr, t.x, t.y, t.z) : void 0 !== t.r ? e.uniform3f(this.addr, t.r, t.g, t.b) : e.uniform3fv(this.addr, t)
    }

    function y(e, t) {
        void 0 === t.x ? e.uniform4fv(this.addr, t) : e.uniform4f(this.addr, t.x, t.y, t.z, t.w)
    }

    function x(e, t) {
        e.uniformMatrix2fv(this.addr, !1, t.elements || t)
    }

    function b(e, t) {
        void 0 === t.elements ? e.uniformMatrix3fv(this.addr, !1, t) : (Ra.set(t.elements), e.uniformMatrix3fv(this.addr, !1, Ra))
    }

    function _(e, t) {
        void 0 === t.elements ? e.uniformMatrix4fv(this.addr, !1, t) : (Aa.set(t.elements), e.uniformMatrix4fv(this.addr, !1, Aa))
    }

    function w(e, t, i) {
        var n = i.allocTextureUnit();
        e.uniform1i(this.addr, n), i.setTexture2D(t || Ma, n)
    }

    function M(e, t, i) {
        var n = i.allocTextureUnit();
        e.uniform1i(this.addr, n), i.setTextureCube(t || Ea, n)
    }

    function E(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function T(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function S(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function A(e) {
        switch (e) {
            case 5126:
                return f;
            case 35664:
                return g;
            case 35665:
                return v;
            case 35666:
                return y;
            case 35674:
                return x;
            case 35675:
                return b;
            case 35676:
                return _;
            case 35678:
            case 36198:
                return w;
            case 35680:
                return M;
            case 5124:
            case 35670:
                return m;
            case 35667:
            case 35671:
                return E;
            case 35668:
            case 35672:
                return T;
            case 35669:
            case 35673:
                return S
        }
    }

    function R(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function L(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function P(e, t) {
        e.uniform2fv(this.addr, p(t, this.size, 2))
    }

    function C(e, t) {
        e.uniform3fv(this.addr, p(t, this.size, 3))
    }

    function I(e, t) {
        e.uniform4fv(this.addr, p(t, this.size, 4))
    }

    function U(e, t) {
        e.uniformMatrix2fv(this.addr, !1, p(t, this.size, 4))
    }

    function N(e, t) {
        e.uniformMatrix3fv(this.addr, !1, p(t, this.size, 9))
    }

    function D(e, t) {
        e.uniformMatrix4fv(this.addr, !1, p(t, this.size, 16))
    }

    function O(e, t, i) {
        var n = t.length,
            r = d(i, n);
        for (e.uniform1iv(this.addr, r), e = 0; e !== n; ++e) i.setTexture2D(t[e] || Ma, r[e])
    }

    function F(e, t, i) {
        var n = t.length,
            r = d(i, n);
        for (e.uniform1iv(this.addr, r), e = 0; e !== n; ++e) i.setTextureCube(t[e] || Ea, r[e])
    }

    function B(e) {
        switch (e) {
            case 5126:
                return R;
            case 35664:
                return P;
            case 35665:
                return C;
            case 35666:
                return I;
            case 35674:
                return U;
            case 35675:
                return N;
            case 35676:
                return D;
            case 35678:
                return O;
            case 35680:
                return F;
            case 5124:
            case 35670:
                return L;
            case 35667:
            case 35671:
                return E;
            case 35668:
            case 35672:
                return T;
            case 35669:
            case 35673:
                return S
        }
    }

    function z(e, t, i) {
        this.id = e, this.addr = i, this.setValue = A(t.type)
    }

    function G(e, t, i) {
        this.id = e, this.addr = i, this.size = t.size, this.setValue = B(t.type)
    }

    function H(e) {
        this.id = e, this.seq = [], this.map = {}
    }

    function V(e, t, i) {
        this.seq = [], this.map = {}, this.renderer = i, i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (var n = 0; i > n; ++n) {
            var r = e.getActiveUniform(t, n),
                a = e.getUniformLocation(t, r.name),
                o = this,
                s = r.name,
                c = s.length;
            for (La.lastIndex = 0;;) {
                var h = La.exec(s),
                    l = La.lastIndex,
                    u = h[1],
                    p = h[3];
                if ("]" === h[2] && (u |= 0), void 0 === p || "[" === p && l + 2 === c) {
                    s = o, r = void 0 === p ? new z(u, r, a) : new G(u, r, a), s.seq.push(r), s.map[r.id] = r;
                    break
                }
                p = o.map[u], void 0 === p && (p = new H(u), u = o, o = p, u.seq.push(o), u.map[o.id] = o), o = p
            }
        }
    }

    function k(e, t, i) {
        return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
    }

    function j(e, t) {
        this.min = void 0 !== e ? e : new i(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new i(-1 / 0, -1 / 0)
    }

    function W(e, t) {
        var n, r, a, o, s, h, l, u, p, d, f, m, g, v, y, x, b = e.context,
            _ = e.state;
        this.render = function (w, M, E) {
            if (0 !== t.length) {
                w = new c;
                var T = E.w / E.z,
                    S = .5 * E.z,
                    A = .5 * E.w,
                    R = 16 / E.w,
                    L = new i(R * T, R),
                    P = new c(1, 1, 0),
                    C = new i(1, 1),
                    I = new j;
                if (I.min.set(E.x, E.y), I.max.set(E.x + (E.z - 16), E.y + (E.w - 16)), void 0 === v) {
                    var R = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                        U = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    f = b.createBuffer(), m = b.createBuffer(), b.bindBuffer(b.ARRAY_BUFFER, f), b.bufferData(b.ARRAY_BUFFER, R, b.STATIC_DRAW), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, m), b.bufferData(b.ELEMENT_ARRAY_BUFFER, U, b.STATIC_DRAW), y = b.createTexture(), x = b.createTexture(), _.bindTexture(b.TEXTURE_2D, y), b.texImage2D(b.TEXTURE_2D, 0, b.RGB, 16, 16, 0, b.RGB, b.UNSIGNED_BYTE, null), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST), _.bindTexture(b.TEXTURE_2D, x), b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 16, 16, 0, b.RGBA, b.UNSIGNED_BYTE, null), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
                    var R = g = {
                            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                            fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                        },
                        U = b.createProgram(),
                        N = b.createShader(b.FRAGMENT_SHADER),
                        D = b.createShader(b.VERTEX_SHADER),
                        O = "precision " + e.getPrecision() + " float;\n";
                    b.shaderSource(N, O + R.fragmentShader), b.shaderSource(D, O + R.vertexShader), b.compileShader(N), b.compileShader(D), b.attachShader(U, N), b.attachShader(U, D), b.linkProgram(U), v = U, p = b.getAttribLocation(v, "position"), d = b.getAttribLocation(v, "uv"), n = b.getUniformLocation(v, "renderType"), r = b.getUniformLocation(v, "map"), a = b.getUniformLocation(v, "occlusionMap"), o = b.getUniformLocation(v, "opacity"), s = b.getUniformLocation(v, "color"), h = b.getUniformLocation(v, "scale"), l = b.getUniformLocation(v, "rotation"), u = b.getUniformLocation(v, "screenPosition")
                }
                for (b.useProgram(v), _.initAttributes(), _.enableAttribute(p), _.enableAttribute(d), _.disableUnusedAttributes(), b.uniform1i(a, 0), b.uniform1i(r, 1), b.bindBuffer(b.ARRAY_BUFFER, f), b.vertexAttribPointer(p, 2, b.FLOAT, !1, 16, 0), b.vertexAttribPointer(d, 2, b.FLOAT, !1, 16, 8), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, m), _.disable(b.CULL_FACE), _.buffers.depth.setMask(!1), U = 0, N = t.length; N > U; U++)
                    if (R = 16 / E.w, L.set(R * T, R), D = t[U], w.set(D.matrixWorld.elements[12], D.matrixWorld.elements[13], D.matrixWorld.elements[14]), w.applyMatrix4(M.matrixWorldInverse), w.applyMatrix4(M.projectionMatrix), P.copy(w), C.x = E.x + P.x * S + S - 8, C.y = E.y + P.y * A + A - 8, !0 === I.containsPoint(C)) {
                        _.activeTexture(b.TEXTURE0), _.bindTexture(b.TEXTURE_2D, null), _.activeTexture(b.TEXTURE1), _.bindTexture(b.TEXTURE_2D, y), b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGB, C.x, C.y, 16, 16, 0), b.uniform1i(n, 0), b.uniform2f(h, L.x, L.y), b.uniform3f(u, P.x, P.y, P.z), _.disable(b.BLEND), _.enable(b.DEPTH_TEST), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), _.activeTexture(b.TEXTURE0), _.bindTexture(b.TEXTURE_2D, x), b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGBA, C.x, C.y, 16, 16, 0), b.uniform1i(n, 1), _.disable(b.DEPTH_TEST), _.activeTexture(b.TEXTURE1), _.bindTexture(b.TEXTURE_2D, y), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), D.positionScreen.copy(P), D.customUpdateCallback ? D.customUpdateCallback(D) : D.updateLensFlares(), b.uniform1i(n, 2), _.enable(b.BLEND);
                        for (var O = 0, F = D.lensFlares.length; F > O; O++) {
                            var B = D.lensFlares[O];
                            .001 < B.opacity && .001 < B.scale && (P.x = B.x, P.y = B.y, P.z = B.z, R = B.size * B.scale / E.w, L.x = R * T, L.y = R, b.uniform3f(u, P.x, P.y, P.z), b.uniform2f(h, L.x, L.y), b.uniform1f(l, B.rotation), b.uniform1f(o, B.opacity), b.uniform3f(s, B.color.r, B.color.g, B.color.b), _.setBlending(B.blending, B.blendEquation, B.blendSrc, B.blendDst), e.setTexture2D(B.texture, 1), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0))
                        }
                    }
                _.enable(b.CULL_FACE), _.enable(b.DEPTH_TEST), _.buffers.depth.setMask(!0), e.resetGLState()
            }
        }
    }

    function X(e, t) {
        function i(e, t) {
            return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : t.id - e.id
        }
        var r, a, o, h, l, u, p, d, f, m, g, v, y, x, b, _, w, M, E, T, S, A = e.context,
            R = e.state,
            L = new c,
            P = new s,
            C = new c;
        this.render = function (s, c) {
            if (0 !== t.length) {
                if (void 0 === T) {
                    var I = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                        U = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    M = A.createBuffer(), E = A.createBuffer(), A.bindBuffer(A.ARRAY_BUFFER, M), A.bufferData(A.ARRAY_BUFFER, I, A.STATIC_DRAW), A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, E), A.bufferData(A.ELEMENT_ARRAY_BUFFER, U, A.STATIC_DRAW);
                    var I = A.createProgram(),
                        U = A.createShader(A.VERTEX_SHADER),
                        N = A.createShader(A.FRAGMENT_SHADER);
                    A.shaderSource(U, ["precision " + e.getPrecision() + " float;", "#define SHADER_NAME SpriteMaterial\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), A.shaderSource(N, ["precision " + e.getPrecision() + " float;", "#define SHADER_NAME SpriteMaterial\nuniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), A.compileShader(U), A.compileShader(N), A.attachShader(I, U), A.attachShader(I, N), A.linkProgram(I), T = I, _ = A.getAttribLocation(T, "position"), w = A.getAttribLocation(T, "uv"), r = A.getUniformLocation(T, "uvOffset"), a = A.getUniformLocation(T, "uvScale"), o = A.getUniformLocation(T, "rotation"), h = A.getUniformLocation(T, "scale"), l = A.getUniformLocation(T, "color"), u = A.getUniformLocation(T, "map"), p = A.getUniformLocation(T, "opacity"), d = A.getUniformLocation(T, "modelViewMatrix"), f = A.getUniformLocation(T, "projectionMatrix"), m = A.getUniformLocation(T, "fogType"), g = A.getUniformLocation(T, "fogDensity"), v = A.getUniformLocation(T, "fogNear"), y = A.getUniformLocation(T, "fogFar"), x = A.getUniformLocation(T, "fogColor"), b = A.getUniformLocation(T, "alphaTest"), I = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), I.width = 8, I.height = 8, U = I.getContext("2d"), U.fillStyle = "white", U.fillRect(0, 0, 8, 8), S = new n(I), S.needsUpdate = !0
                }
                A.useProgram(T), R.initAttributes(), R.enableAttribute(_), R.enableAttribute(w), R.disableUnusedAttributes(), R.disable(A.CULL_FACE), R.enable(A.BLEND), A.bindBuffer(A.ARRAY_BUFFER, M), A.vertexAttribPointer(_, 2, A.FLOAT, !1, 16, 0), A.vertexAttribPointer(w, 2, A.FLOAT, !1, 16, 8), A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, E), A.uniformMatrix4fv(f, !1, c.projectionMatrix.elements), R.activeTexture(A.TEXTURE0), A.uniform1i(u, 0), U = I = 0, (N = s.fog) ? (A.uniform3f(x, N.color.r, N.color.g, N.color.b), N.isFog ? (A.uniform1f(v, N.near), A.uniform1f(y, N.far), A.uniform1i(m, 1), U = I = 1) : N.isFogExp2 && (A.uniform1f(g, N.density), A.uniform1i(m, 2), U = I = 2)) : (A.uniform1i(m, 0), U = I = 0);
                for (var N = 0, D = t.length; D > N; N++) {
                    var O = t[N];
                    O.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, O.matrixWorld), O.z = -O.modelViewMatrix.elements[14]
                }
                t.sort(i);
                for (var F = [], N = 0, D = t.length; D > N; N++) {
                    var O = t[N],
                        B = O.material;
                    if (!1 !== B.visible) {
                        O.onBeforeRender(e, s, c, void 0, B, void 0), A.uniform1f(b, B.alphaTest), A.uniformMatrix4fv(d, !1, O.modelViewMatrix.elements), O.matrixWorld.decompose(L, P, C), F[0] = C.x, F[1] = C.y;
                        var z = 0;
                        s.fog && B.fog && (z = U), I !== z && (A.uniform1i(m, z), I = z), null !== B.map ? (A.uniform2f(r, B.map.offset.x, B.map.offset.y), A.uniform2f(a, B.map.repeat.x, B.map.repeat.y)) : (A.uniform2f(r, 0, 0), A.uniform2f(a, 1, 1)), A.uniform1f(p, B.opacity), A.uniform3f(l, B.color.r, B.color.g, B.color.b), A.uniform1f(o, B.rotation), A.uniform2fv(h, F), R.setBlending(B.blending, B.blendEquation, B.blendSrc, B.blendDst, B.blendEquationAlpha, B.blendSrcAlpha, B.blendDstAlpha, B.premultipliedAlpha), R.buffers.depth.setTest(B.depthTest), R.buffers.depth.setMask(B.depthWrite), B.map ? e.setTexture2D(B.map, 0) : e.setTexture2D(S, 0), A.drawElements(A.TRIANGLES, 6, A.UNSIGNED_SHORT, 0), O.onAfterRender(e, s, c, void 0, B, void 0)
                    }
                }
                R.enable(A.CULL_FACE), e.resetGLState()
            }
        }
    }

    function q() {
        Object.defineProperty(this, "id", {
            value: Da++
        }), this.uuid = _a.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.shading = 2, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.needsUpdate = this.visible = !0
    }

    function Y(e) {
        q.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
    }

    function Z(e) {
        q.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(e)
    }

    function J(e, t) {
        this.min = void 0 !== e ? e : new c(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new c(-1 / 0, -1 / 0, -1 / 0)
    }

    function Q(e, t) {
        this.center = void 0 !== e ? e : new c, this.radius = void 0 !== t ? t : 0
    }

    function K() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    function $(e, t) {
        this.normal = void 0 !== e ? e : new c(1, 0, 0), this.constant = void 0 !== t ? t : 0
    }

    function et(e, t, i, n, r, a) {
        this.planes = [void 0 !== e ? e : new $, void 0 !== t ? t : new $, void 0 !== i ? i : new $, void 0 !== n ? n : new $, void 0 !== r ? r : new $, void 0 !== a ? a : new $]
    }

    function tt(e, t, n, o) {
        function s(t, i, n, r) {
            var a, o = t.geometry;
            a = b;
            var s = t.customDepthMaterial;
            return n && (a = _, s = t.customDistanceMaterial), s ? a = s : (s = !1, i.morphTargets && (o && o.isBufferGeometry ? s = o.morphAttributes && o.morphAttributes.position && 0 < o.morphAttributes.position.length : o && o.isGeometry && (s = o.morphTargets && 0 < o.morphTargets.length)), t.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t), t = t.isSkinnedMesh && i.skinning, o = 0, s && (o |= 1), t && (o |= 2), a = a[o]), e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (o = a.uuid, s = i.uuid, t = w[o], void 0 === t && (t = {}, w[o] = t), o = t[s], void 0 === o && (o = a.clone(), t[s] = o), a = o), a.visible = i.visible, a.wireframe = i.wireframe, s = i.side, C.renderSingleSided && 2 == s && (s = 0), C.renderReverseSided && (0 === s ? s = 1 : 1 === s && (s = 0)), a.side = s, a.clipShadows = i.clipShadows, a.clippingPlanes = i.clippingPlanes, a.wireframeLinewidth = i.wireframeLinewidth, a.linewidth = i.linewidth, n && void 0 !== a.uniforms.lightPos && a.uniforms.lightPos.value.copy(r), a
        }

        function l(t, i, r, a) {
            if (!1 !== t.visible) {
                if (t.layers.test(i.layers) && (t.isMesh || t.isLine || t.isPoints) && t.castShadow && (!t.frustumCulled || d.intersectsObject(t))) {
                    t.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, t.matrixWorld);
                    var o = n.update(t),
                        c = t.material;
                    if (Array.isArray(c))
                        for (var h = o.groups, u = 0, p = h.length; p > u; u++) {
                            var f = h[u],
                                m = c[f.materialIndex];
                            m && m.visible && (m = s(t, m, a, x), e.renderBufferDirect(r, null, o, m, t, f))
                        } else c.visible && (m = s(t, c, a, x), e.renderBufferDirect(r, null, o, m, t, null))
                }
                for (t = t.children, o = 0, c = t.length; c > o; o++) l(t[o], i, r, a)
            }
        }
        var u = e.context,
            p = e.state,
            d = new et,
            f = new h,
            m = t.shadows,
            g = new i,
            v = new i(o.maxTextureSize, o.maxTextureSize),
            y = new c,
            x = new c,
            b = Array(4),
            _ = Array(4),
            w = {},
            M = [new c(1, 0, 0), new c(-1, 0, 0), new c(0, 0, 1), new c(0, 0, -1), new c(0, 1, 0), new c(0, -1, 0)],
            E = [new c(0, 1, 0), new c(0, 1, 0), new c(0, 1, 0), new c(0, 1, 0), new c(0, 0, 1), new c(0, 0, -1)],
            T = [new r, new r, new r, new r, new r, new r];
        t = new Z, t.depthPacking = 3201, t.clipping = !0, o = Na.distanceRGBA;
        for (var S = Ia.clone(o.uniforms), A = 0; 4 !== A; ++A) {
            var R = 0 !== (1 & A),
                L = 0 !== (2 & A),
                P = t.clone();
            P.morphTargets = R, P.skinning = L, b[A] = P, R = new Y({
                defines: {
                    USE_SHADOWMAP: ""
                },
                uniforms: S,
                vertexShader: o.vertexShader,
                fragmentShader: o.fragmentShader,
                morphTargets: R,
                skinning: L,
                clipping: !0
            }), _[A] = R
        }
        var C = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.renderSingleSided = this.renderReverseSided = !0, this.render = function (t, i) {
            if (!1 !== C.enabled && (!1 !== C.autoUpdate || !1 !== C.needsUpdate) && 0 !== m.length) {
                p.disable(u.BLEND), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
                for (var n, r = 0, o = m.length; o > r; r++) {
                    var s = m[r];
                    n = s.shadow;
                    var c = s && s.isPointLight;
                    if (void 0 === n) console.warn("THREE.WebGLShadowMap:", s, "has no shadow.");
                    else {
                        var h = n.camera;
                        if (g.copy(n.mapSize), g.min(v), c) {
                            var b = g.x,
                                _ = g.y;
                            T[0].set(2 * b, _, b, _), T[1].set(0, _, b, _), T[2].set(3 * b, _, b, _), T[3].set(b, _, b, _), T[4].set(3 * b, 0, b, _), T[5].set(b, 0, b, _), g.x *= 4, g.y *= 2
                        }
                        for (null === n.map && (n.map = new a(g.x, g.y, {
                                minFilter: 1003,
                                magFilter: 1003,
                                format: 1023
                            }), n.map.texture.name = s.name + ".shadowMap", h.updateProjectionMatrix()), n.isSpotLightShadow && n.update(s), b = n.map, _ = n.matrix, x.setFromMatrixPosition(s.matrixWorld), h.position.copy(x), c ? (n = 6, _.makeTranslation(-x.x, -x.y, -x.z)) : (n = 1, y.setFromMatrixPosition(s.target.matrixWorld), h.lookAt(y), h.updateMatrixWorld(), _.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), _.multiply(h.projectionMatrix), _.multiply(h.matrixWorldInverse)), e.setRenderTarget(b), e.clear(), s = 0; n > s; s++) c && (y.copy(h.position), y.add(M[s]), h.up.copy(E[s]), h.lookAt(y), h.updateMatrixWorld(), p.viewport(T[s])), f.multiplyMatrices(h.projectionMatrix, h.matrixWorldInverse), d.setFromMatrix(f), l(t, i, h, c)
                    }
                }
                r = e.getClearColor(), o = e.getClearAlpha(), e.setClearColor(r, o), C.needsUpdate = !1
            }
        }
    }

    function it(e) {
        var t = {};
        return {
            get: function (e) {
                return e.isInterleavedBufferAttribute && (e = e.data), t[e.uuid]
            },
            remove: function (i) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var n = t[i.uuid];
                n && (e.deleteBuffer(n.buffer), delete t[i.uuid])
            },
            update: function (i, n) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var r = t[i.uuid];
                if (void 0 === r) {
                    var r = i.uuid,
                        a = i,
                        o = a.array,
                        s = a.dynamic ? e.DYNAMIC_DRAW : e.STATIC_DRAW,
                        c = e.createBuffer();
                    e.bindBuffer(n, c), e.bufferData(n, o, s), a.onUploadCallback(), s = e.FLOAT, o instanceof Float32Array ? s = e.FLOAT : o instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : o instanceof Uint16Array ? s = e.UNSIGNED_SHORT : o instanceof Int16Array ? s = e.SHORT : o instanceof Uint32Array ? s = e.UNSIGNED_INT : o instanceof Int32Array ? s = e.INT : o instanceof Int8Array ? s = e.BYTE : o instanceof Uint8Array && (s = e.UNSIGNED_BYTE), t[r] = {
                        buffer: c,
                        type: s,
                        bytesPerElement: o.BYTES_PER_ELEMENT,
                        version: a.version
                    }
                } else r.version < i.version && (a = i, o = a.array, c = a.updateRange, e.bindBuffer(n, r.buffer), !1 === a.dynamic ? e.bufferData(n, o, e.STATIC_DRAW) : -1 === c.count ? e.bufferSubData(n, 0, o) : 0 === c.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(n, c.offset * o.BYTES_PER_ELEMENT, o.subarray(c.offset, c.offset + c.count)), c.count = -1), r.version = i.version)
            }
        }
    }

    function nt(e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || nt.DefaultOrder
    }

    function rt() {
        this.mask = 1
    }

    function at() {
        Object.defineProperty(this, "id", {
            value: Oa++
        }), this.uuid = _a.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = at.DefaultUp.clone();
        var e = new c,
            t = new nt,
            i = new s,
            n = new c(1, 1, 1);
        t.onChange(function () {
            i.setFromEuler(t, !1)
        }), i.onChange(function () {
            t.setFromQuaternion(i, void 0, !1)
        }), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: e
            },
            rotation: {
                enumerable: !0,
                value: t
            },
            quaternion: {
                enumerable: !0,
                value: i
            },
            scale: {
                enumerable: !0,
                value: n
            },
            modelViewMatrix: {
                value: new h
            },
            normalMatrix: {
                value: new K
            }
        }), this.matrix = new h, this.matrixWorld = new h, this.matrixAutoUpdate = at.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new rt, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function ot() {
        at.call(this), this.type = "Camera", this.matrixWorldInverse = new h, this.projectionMatrix = new h
    }

    function st(e, t, i, n, r, a) {
        ot.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
    }

    function ct(e, t, i, n) {
        ot.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function ht(e, t, i, n, r, a) {
        this.a = e, this.b = t, this.c = i, this.normal = n && n.isVector3 ? n : new c, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new k, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
    }

    function lt() {
        Object.defineProperty(this, "id", {
            value: Fa++
        }), this.uuid = _a.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
    }

    function ut(e, t, i) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.uuid = _a.generateUUID(), this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.onUploadCallback = function () {}, this.version = 0
    }

    function pt(e, t) {
        ut.call(this, new Int8Array(e), t)
    }

    function dt(e, t) {
        ut.call(this, new Uint8Array(e), t)
    }

    function ft(e, t) {
        ut.call(this, new Uint8ClampedArray(e), t)
    }

    function mt(e, t) {
        ut.call(this, new Int16Array(e), t)
    }

    function gt(e, t) {
        ut.call(this, new Uint16Array(e), t)
    }

    function vt(e, t) {
        ut.call(this, new Int32Array(e), t)
    }

    function yt(e, t) {
        ut.call(this, new Uint32Array(e), t)
    }

    function xt(e, t) {
        ut.call(this, new Float32Array(e), t)
    }

    function bt(e, t) {
        ut.call(this, new Float64Array(e), t)
    }

    function _t() {
        this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }

    function wt(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], i = 1, n = e.length; n > i; ++i) e[i] > t && (t = e[i]);
        return t
    }

    function Mt() {
        Object.defineProperty(this, "id", {
            value: Fa++
        }), this.uuid = _a.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }
    }

    function Et(e, t, i, n, r, a) {
        lt.call(this), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: a
        }, this.fromBufferGeometry(new Tt(e, t, i, n, r, a)), this.mergeVertices()
    }

    function Tt(e, t, i, n, r, a) {
        function o(e, t, i, n, r, a, o, m, g, v, y) {
            var x = a / g,
                b = o / v,
                _ = a / 2,
                w = o / 2,
                M = m / 2;
            o = g + 1;
            var E, T, S = v + 1,
                A = a = 0,
                R = new c;
            for (T = 0; S > T; T++) {
                var L = T * b - w;
                for (E = 0; o > E; E++) R[e] = (E * x - _) * n, R[t] = L * r, R[i] = M, l.push(R.x, R.y, R.z), R[e] = 0, R[t] = 0, R[i] = m > 0 ? 1 : -1, u.push(R.x, R.y, R.z), p.push(E / g), p.push(1 - T / v), a += 1
            }
            for (T = 0; v > T; T++)
                for (E = 0; g > E; E++) e = d + E + o * (T + 1), t = d + (E + 1) + o * (T + 1), i = d + (E + 1) + o * T, h.push(d + E + o * T, e, i), h.push(e, t, i), A += 6;
            s.addGroup(f, A, y), f += A, d += a
        }
        Mt.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: a
        };
        var s = this;
        n = Math.floor(n) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1;
        var h = [],
            l = [],
            u = [],
            p = [],
            d = 0,
            f = 0;
        o("z", "y", "x", -1, -1, i, t, e, a, r, 0), o("z", "y", "x", 1, -1, i, t, -e, a, r, 1), o("x", "z", "y", 1, 1, e, i, t, n, a, 2), o("x", "z", "y", 1, -1, e, i, -t, n, a, 3), o("x", "y", "z", 1, -1, e, t, i, n, r, 4), o("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(h), this.addAttribute("position", new xt(l, 3)), this.addAttribute("normal", new xt(u, 3)), this.addAttribute("uv", new xt(p, 2))
    }

    function St(e, t, i, n) {
        lt.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        }, this.fromBufferGeometry(new At(e, t, i, n)), this.mergeVertices()
    }

    function At(e, t, i, n) {
        Mt.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        };
        var r = e / 2,
            a = t / 2;
        i = Math.floor(i) || 1, n = Math.floor(n) || 1;
        var o = i + 1,
            s = n + 1,
            c = e / i,
            h = t / n,
            l = [],
            u = [],
            p = [],
            d = [];
        for (e = 0; s > e; e++) {
            var f = e * h - a;
            for (t = 0; o > t; t++) u.push(t * c - r, -f, 0), p.push(0, 0, 1), d.push(t / i), d.push(1 - e / n)
        }
        for (e = 0; n > e; e++)
            for (t = 0; i > t; t++) r = t + o * (e + 1), a = t + 1 + o * (e + 1), s = t + 1 + o * e, l.push(t + o * e, r, s), l.push(r, a, s);
        this.setIndex(l), this.addAttribute("position", new xt(u, 3)), this.addAttribute("normal", new xt(p, 3)), this.addAttribute("uv", new xt(d, 2))
    }

    function Rt(e) {
        q.call(this), this.type = "MeshBasicMaterial", this.color = new k(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function Lt(e, t) {
        this.origin = void 0 !== e ? e : new c, this.direction = void 0 !== t ? t : new c
    }

    function Pt(e, t) {
        this.start = void 0 !== e ? e : new c, this.end = void 0 !== t ? t : new c
    }

    function Ct(e, t, i) {
        this.a = void 0 !== e ? e : new c, this.b = void 0 !== t ? t : new c, this.c = void 0 !== i ? i : new c
    }

    function It(e, t) {
        at.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new Mt, this.material = void 0 !== t ? t : new Rt({
            color: 16777215 * Math.random()
        }), this.drawMode = 0, this.updateMorphTargets()
    }

    function Ut(e, t, i, n) {
        function r(e, i) {
            t.buffers.color.setClear(e.r, e.g, e.b, i, n)
        }
        var a, o, s, c, h = new k(0),
            l = 0;
        return {
            getClearColor: function () {
                return h
            },
            setClearColor: function (e, t) {
                h.set(e), l = void 0 !== t ? t : 1, r(h, l)
            },
            getClearAlpha: function () {
                return l
            },
            setClearAlpha: function (e) {
                l = e, r(h, l)
            },
            render: function (t, n, u) {
                t = t.background, null === t ? r(h, l) : t && t.isColor && (r(t, 1), u = !0), (e.autoClear || u) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), t && t.isCubeTexture ? (void 0 === s && (s = new ct, c = new It(new Tt(5, 5, 5), new Y({
                    uniforms: Na.cube.uniforms,
                    vertexShader: Na.cube.vertexShader,
                    fragmentShader: Na.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))), s.projectionMatrix.copy(n.projectionMatrix), s.matrixWorld.extractRotation(n.matrixWorld), s.matrixWorldInverse.getInverse(s.matrixWorld), c.material.uniforms.tCube.value = t, c.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, c.matrixWorld), i.update(c), e.renderBufferDirect(s, null, c.geometry, c.material, c, null)) : t && t.isTexture && (void 0 === a && (a = new st(-1, 1, 1, -1, 0, 1), o = new It(new At(2, 2), new Rt({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))), o.material.map = t, i.update(o), e.renderBufferDirect(a, null, o.geometry, o.material, o, null))
            }
        }
    }

    function Nt(e, t) {
        return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function Dt(e, t) {
        return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function Ot() {
        var e = [],
            t = -1,
            i = [],
            n = -1;
        return {
            opaque: e,
            transparent: i,
            init: function () {
                n = t = -1
            },
            push: function (r, a, o, s, c) {
                var h, l;
                o.transparent ? (h = i, l = ++n) : (h = e, l = ++t), (l = h[l]) ? (l.id = r.id, l.object = r, l.geometry = a, l.material = o, l.program = o.program, l.renderOrder = r.renderOrder, l.z = s, l.group = c) : (l = {
                    id: r.id,
                    object: r,
                    geometry: a,
                    material: o,
                    program: o.program,
                    renderOrder: r.renderOrder,
                    z: s,
                    group: c
                }, h.push(l))
            },
            finish: function () {
                e.length = t + 1, i.length = n + 1
            },
            sort: function () {
                e.sort(Nt), i.sort(Dt)
            }
        }
    }

    function Ft() {
        var e = {};
        return {
            get: function (t, i) {
                var n = t.id + "," + i.id,
                    r = e[n];
                return void 0 === r && (r = new Ot, e[n] = r), r
            },
            dispose: function () {
                e = {}
            }
        }
    }

    function Bt(e, t, i) {
        var n, r, a;
        this.setMode = function (e) {
            n = e
        }, this.setIndex = function (e) {
            r = e.type, a = e.bytesPerElement
        }, this.render = function (t, o) {
            e.drawElements(n, o, r, t * a), i.calls++, i.vertices += o, n === e.TRIANGLES && (i.faces += o / 3)
        }, this.renderInstances = function (o, s, c) {
            var h = t.get("ANGLE_instanced_arrays");
            null === h ? console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (h.drawElementsInstancedANGLE(n, c, r, s * a, o.maxInstancedCount), i.calls++, i.vertices += c * o.maxInstancedCount, n === e.TRIANGLES && (i.faces += o.maxInstancedCount * c / 3))
        }
    }

    function zt(e, t, i) {
        var n;
        this.setMode = function (e) {
            n = e
        }, this.render = function (t, r) {
            e.drawArrays(n, t, r), i.calls++, i.vertices += r, n === e.TRIANGLES && (i.faces += r / 3)
        }, this.renderInstances = function (r, a, o) {
            var s = t.get("ANGLE_instanced_arrays");
            if (null === s) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            else {
                var c = r.attributes.position;
                c.isInterleavedBufferAttribute ? (o = c.data.count, s.drawArraysInstancedANGLE(n, 0, o, r.maxInstancedCount)) : s.drawArraysInstancedANGLE(n, a, o, r.maxInstancedCount), i.calls++, i.vertices += o * r.maxInstancedCount, n === e.TRIANGLES && (i.faces += r.maxInstancedCount * o / 3)
            }
        }
    }

    function Gt(e, t, i) {
        function n(e) {
            e = e.target;
            var o = r[e.id];
            null !== o.index && t.remove(o.index);
            for (var s in o.attributes) t.remove(o.attributes[s]);
            e.removeEventListener("dispose", n), delete r[e.id], (s = a[e.id]) && (t.remove(s), delete a[e.id]), (s = a[o.id]) && (t.remove(s), delete a[o.id]), i.geometries--
        }
        var r = {},
            a = {};
        return {
            get: function (e, t) {
                var a = r[t.id];
                return a ? a : (t.addEventListener("dispose", n), t.isBufferGeometry ? a = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Mt).setFromObject(e)), a = t._bufferGeometry), r[t.id] = a, i.geometries++, a)
            },
            update: function (i) {
                var n = i.index,
                    r = i.attributes;
                null !== n && t.update(n, e.ELEMENT_ARRAY_BUFFER);
                for (var a in r) t.update(r[a], e.ARRAY_BUFFER);
                i = i.morphAttributes;
                for (a in i)
                    for (var n = i[a], r = 0, o = n.length; o > r; r++) t.update(n[r], e.ARRAY_BUFFER)
            },
            getWireframeAttribute: function (i) {
                var n = a[i.id];
                if (n) return n;
                var n = [],
                    r = i.index,
                    o = i.attributes;
                if (null !== r)
                    for (var r = r.array, o = 0, s = r.length; s > o; o += 3) {
                        var c = r[o + 0],
                            h = r[o + 1],
                            l = r[o + 2];
                        n.push(c, h, h, l, l, c)
                    } else
                        for (r = o.position.array, o = 0, s = r.length / 3 - 1; s > o; o += 3) c = o + 0, h = o + 1, l = o + 2, n.push(c, h, h, l, l, c);
                return n = new(65535 < wt(n) ? yt : gt)(n, 1), t.update(n, e.ELEMENT_ARRAY_BUFFER), a[i.id] = n
            }
        }
    }

    function Ht() {
        var e = {};
        return {
            get: function (t) {
                if (void 0 !== e[t.id]) return e[t.id];
                var n;
                switch (t.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new c,
                            color: new k,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new c,
                            direction: new c,
                            color: new k,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new c,
                            color: new k,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new c,
                            skyColor: new k,
                            groundColor: new k
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new k,
                            position: new c,
                            halfWidth: new c,
                            halfHeight: new c
                        }
                }
                return e[t.id] = n
            }
        }
    }

    function Vt(e, t, i) {
        var n = {};
        return {
            update: function (e) {
                var r = i.frame,
                    a = e.geometry,
                    o = t.get(e, a);
                return n[o.id] !== r && (a.isGeometry && o.updateFromObject(e), t.update(o), n[o.id] = r), o
            },
            clear: function () {
                n = {}
            }
        }
    }

    function kt(e) {
        e = e.split("\n");
        for (var t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
        return e.join("\n")
    }

    function jt(e, t, i) {
        var n = e.createShader(t);
        return e.shaderSource(n, i), e.compileShader(n), !1 === e.getShaderParameter(n, e.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t === e.VERTEX_SHADER ? "vertex" : "fragment", e.getShaderInfoLog(n), kt(i)), n
    }

    function Wt(e) {
        switch (e) {
            case 3e3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw Error("unsupported encoding: " + e)
        }
    }

    function Xt(e, t) {
        var i = Wt(t);
        return "vec4 " + e + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
    }

    function qt(e, t) {
        var i = Wt(t);
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
    }

    function Yt(e, t) {
        var i;
        switch (t) {
            case 1:
                i = "Linear";
                break;
            case 2:
                i = "Reinhard";
                break;
            case 3:
                i = "Uncharted2";
                break;
            case 4:
                i = "OptimizedCineon";
                break;
            default:
                throw Error("unsupported toneMapping: " + t)
        }
        return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
    }

    function Zt(e, t, i) {
        return e = e || {}, [e.derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Qt).join("\n")
    }

    function Jt(e) {
        var t, i = [];
        for (t in e) {
            var n = e[t];
            !1 !== n && i.push("#define " + t + " " + n)
        }
        return i.join("\n")
    }

    function Qt(e) {
        return "" !== e
    }

    function Kt(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }

    function $t(e) {
        return e.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function (e, t) {
            var i = Ua[t];
            if (void 0 === i) throw Error("Can not resolve #include <" + t + ">");
            return $t(i)
        })
    }

    function ei(e) {
        return e.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function (e, t, i, n) {
            for (e = "", t = parseInt(t); t < parseInt(i); t++) e += n.replace(/\[ i \]/g, "[ " + t + " ]");
            return e
        })
    }

    function ti(e, t, i, n, r) {
        var a = e.context,
            o = i.extensions,
            s = i.defines,
            c = n.vertexShader,
            h = n.fragmentShader,
            l = "SHADOWMAP_TYPE_BASIC";
        1 === r.shadowMapType ? l = "SHADOWMAP_TYPE_PCF" : 2 === r.shadowMapType && (l = "SHADOWMAP_TYPE_PCF_SOFT");
        var u = "ENVMAP_TYPE_CUBE",
            p = "ENVMAP_MODE_REFLECTION",
            d = "ENVMAP_BLENDING_MULTIPLY";
        if (r.envMap) {
            switch (i.envMap.mapping) {
                case 301:
                case 302:
                    u = "ENVMAP_TYPE_CUBE";
                    break;
                case 306:
                case 307:
                    u = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case 303:
                case 304:
                    u = "ENVMAP_TYPE_EQUIREC";
                    break;
                case 305:
                    u = "ENVMAP_TYPE_SPHERE"
            }
            switch (i.envMap.mapping) {
                case 302:
                case 304:
                    p = "ENVMAP_MODE_REFRACTION"
            }
            switch (i.combine) {
                case 0:
                    d = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    d = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    d = "ENVMAP_BLENDING_ADD"
            }
        }
        var f = 0 < e.gammaFactor ? e.gammaFactor : 1,
            o = Zt(o, r, e.extensions),
            m = Jt(s),
            g = a.createProgram();
        i.isRawShaderMaterial ? (s = [m, "\n"].filter(Qt).join("\n"), n = [o, m, "\n"].filter(Qt).join("\n")) : (s = ["precision " + r.precision + " float;", "precision " + r.precision + " int;", "#define SHADER_NAME " + n.name, m, r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + f, "#define MAX_BONES " + r.maxBones, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + p : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.vertexColors ? "#define USE_COLOR" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.skinning ? "#define USE_SKINNING" : "", r.useVertexTexture ? "#define BONE_TEXTURE" : "", r.morphTargets ? "#define USE_MORPHTARGETS" : "", r.morphNormals && !1 === r.flatShading ? "#define USE_MORPHNORMALS" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + r.numClippingPlanes, r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + l : "", r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && e.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Qt).join("\n"), n = [o, "precision " + r.precision + " float;", "precision " + r.precision + " int;", "#define SHADER_NAME " + n.name, m, r.alphaTest ? "#define ALPHATEST " + r.alphaTest : "", "#define GAMMA_FACTOR " + f, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + u : "", r.envMap ? "#define " + p : "", r.envMap ? "#define " + d : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.vertexColors ? "#define USE_COLOR" : "", r.gradientMap ? "#define USE_GRADIENTMAP" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + r.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (r.numClippingPlanes - r.numClipIntersection), r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + l : "", r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && e.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", r.envMap && e.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== r.toneMapping ? "#define TONE_MAPPING" : "", 0 !== r.toneMapping ? Ua.tonemapping_pars_fragment : "", 0 !== r.toneMapping ? Yt("toneMapping", r.toneMapping) : "", r.dithering ? "#define DITHERING" : "", r.outputEncoding || r.mapEncoding || r.envMapEncoding || r.emissiveMapEncoding ? Ua.encodings_pars_fragment : "", r.mapEncoding ? Xt("mapTexelToLinear", r.mapEncoding) : "", r.envMapEncoding ? Xt("envMapTexelToLinear", r.envMapEncoding) : "", r.emissiveMapEncoding ? Xt("emissiveMapTexelToLinear", r.emissiveMapEncoding) : "", r.outputEncoding ? qt("linearToOutputTexel", r.outputEncoding) : "", r.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Qt).join("\n")), c = $t(c), c = Kt(c, r), h = $t(h), h = Kt(h, r), i.isShaderMaterial || (c = ei(c), h = ei(h)), h = n + h, c = jt(a, a.VERTEX_SHADER, s + c), h = jt(a, a.FRAGMENT_SHADER, h), a.attachShader(g, c), a.attachShader(g, h), void 0 !== i.index0AttributeName ? a.bindAttribLocation(g, 0, i.index0AttributeName) : !0 === r.morphTargets && a.bindAttribLocation(g, 0, "position"), a.linkProgram(g), r = a.getProgramInfoLog(g), l = a.getShaderInfoLog(c), u = a.getShaderInfoLog(h), d = p = !0, !1 === a.getProgramParameter(g, a.LINK_STATUS) ? (p = !1, console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(g, a.VALIDATE_STATUS), "gl.getProgramInfoLog", r, l, u)) : "" !== r ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", r) : ("" === l || "" === u) && (d = !1), d && (this.diagnostics = {
            runnable: p,
            material: i,
            programLog: r,
            vertexShader: {
                log: l,
                prefix: s
            },
            fragmentShader: {
                log: u,
                prefix: n
            }
        }), a.deleteShader(c), a.deleteShader(h);
        var v;
        this.getUniforms = function () {
            return void 0 === v && (v = new V(a, g, e)), v
        };
        var y;
        return this.getAttributes = function () {
            if (void 0 === y) {
                for (var e = {}, t = a.getProgramParameter(g, a.ACTIVE_ATTRIBUTES), i = 0; t > i; i++) {
                    var n = a.getActiveAttrib(g, i).name;
                    e[n] = a.getAttribLocation(g, n)
                }
                y = e
            }
            return y
        }, this.destroy = function () {
            a.deleteProgram(g), this.program = void 0
        }, Object.defineProperties(this, {
            uniforms: {
                get: function () {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                }
            },
            attributes: {
                get: function () {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                }
            }
        }), this.id = Ba++, this.code = t, this.usedTimes = 1, this.program = g, this.vertexShader = c, this.fragmentShader = h, this
    }

    function ii(e, t) {
        function i(e, t) {
            var i;
            return e ? e.isTexture ? i = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = e.texture.encoding) : i = 3e3, 3e3 === i && t && (i = 3007), i
        }
        var n = [],
            r = {
                MeshDepthMaterial: "depth",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points"
            },
            a = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
        this.getParameters = function (n, a, o, s, c, h) {
            var l, u = r[n.type];
            if (h.isSkinnedMesh)
                if (l = h.skeleton.bones, t.floatVertexTextures) l = 1024;
                else {
                    var p = Math.min(Math.floor((t.maxVertexUniforms - 20) / 4), l.length);
                    p < l.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + l.length + " bones. This GPU supports " + p + "."), l = 0) : l = p
                }
            else l = 0;
            p = e.getPrecision(), null !== n.precision && (p = t.getMaxPrecision(n.precision), p !== n.precision && console.warn("THREE.WebGLProgram.getParameters:", n.precision, "not supported, using", p, "instead."));
            var d = e.getRenderTarget();
            return {
                shaderID: u,
                precision: p,
                supportsVertexTextures: t.vertexTextures,
                outputEncoding: i(d ? d.texture : null, e.gammaOutput),
                map: !!n.map,
                mapEncoding: i(n.map, e.gammaInput),
                envMap: !!n.envMap,
                envMapMode: n.envMap && n.envMap.mapping,
                envMapEncoding: i(n.envMap, e.gammaInput),
                envMapCubeUV: !!n.envMap && (306 === n.envMap.mapping || 307 === n.envMap.mapping),
                lightMap: !!n.lightMap,
                aoMap: !!n.aoMap,
                emissiveMap: !!n.emissiveMap,
                emissiveMapEncoding: i(n.emissiveMap, e.gammaInput),
                bumpMap: !!n.bumpMap,
                normalMap: !!n.normalMap,
                displacementMap: !!n.displacementMap,
                roughnessMap: !!n.roughnessMap,
                metalnessMap: !!n.metalnessMap,
                specularMap: !!n.specularMap,
                alphaMap: !!n.alphaMap,
                gradientMap: !!n.gradientMap,
                combine: n.combine,
                vertexColors: n.vertexColors,
                fog: !!o,
                useFog: n.fog,
                fogExp: o && o.isFogExp2,
                flatShading: 1 === n.shading,
                sizeAttenuation: n.sizeAttenuation,
                logarithmicDepthBuffer: t.logarithmicDepthBuffer,
                skinning: n.skinning && l > 0,
                maxBones: l,
                useVertexTexture: t.floatVertexTextures,
                morphTargets: n.morphTargets,
                morphNormals: n.morphNormals,
                maxMorphTargets: e.maxMorphTargets,
                maxMorphNormals: e.maxMorphNormals,
                numDirLights: a.directional.length,
                numPointLights: a.point.length,
                numSpotLights: a.spot.length,
                numRectAreaLights: a.rectArea.length,
                numHemiLights: a.hemi.length,
                numClippingPlanes: s,
                numClipIntersection: c,
                dithering: n.dithering,
                shadowMapEnabled: e.shadowMap.enabled && h.receiveShadow && 0 < a.shadows.length,
                shadowMapType: e.shadowMap.type,
                toneMapping: e.toneMapping,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: n.premultipliedAlpha,
                alphaTest: n.alphaTest,
                doubleSided: 2 === n.side,
                flipSided: 1 === n.side,
                depthPacking: void 0 !== n.depthPacking ? n.depthPacking : !1
            }
        }, this.getProgramCode = function (t, i) {
            var n = [];
            if (i.shaderID ? n.push(i.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)
                for (var r in t.defines) n.push(r), n.push(t.defines[r]);
            for (r = 0; r < a.length; r++) n.push(i[a[r]]);
            return n.push(t.onBeforeCompile.toString()), n.push(e.gammaOutput), n.join()
        }, this.acquireProgram = function (t, i, r, a) {
            for (var o, s = 0, c = n.length; c > s; s++) {
                var h = n[s];
                if (h.code === a) {
                    o = h, ++o.usedTimes;
                    break
                }
            }
            return void 0 === o && (o = new ti(e, a, t, i, r), n.push(o)), o
        }, this.releaseProgram = function (e) {
            if (0 === --e.usedTimes) {
                var t = n.indexOf(e);
                n[t] = n[n.length - 1], n.pop(), e.destroy()
            }
        }, this.programs = n
    }

    function ni(e, t, i, n, r, a, o) {
        function s(e, t) {
            if (e.width > t || e.height > t) {
                var i = t / Math.max(e.width, e.height),
                    n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                return n.width = Math.floor(e.width * i), n.height = Math.floor(e.height * i), n.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, n.width, n.height), console.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + n.width + "x" + n.height, e), n
            }
            return e
        }

        function c(e) {
            return _a.isPowerOfTwo(e.width) && _a.isPowerOfTwo(e.height)
        }

        function h(e, t) {
            return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
        }

        function l(t) {
            return 1003 === t || 1004 === t || 1005 === t ? e.NEAREST : e.LINEAR
        }

        function u(t) {
            t = t.target, t.removeEventListener("dispose", u);
            e: {
                var i = n.get(t);
                if (t.image && i.__image__webglTextureCube) e.deleteTexture(i.__image__webglTextureCube);
                else {
                    if (void 0 === i.__webglInit) break e;
                    e.deleteTexture(i.__webglTexture)
                }
                n.remove(t)
            }
            o.textures--
        }

        function p(t) {
            t = t.target, t.removeEventListener("dispose", p);
            var i = n.get(t),
                r = n.get(t.texture);
            if (t) {
                if (void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
                    for (r = 0; 6 > r; r++) e.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[r]);
                else e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer);
                n.remove(t.texture), n.remove(t)
            }
            o.textures--
        }

        function d(t, l) {
            var p = n.get(t);
            if (0 < t.version && p.__version !== t.version) {
                var d = t.image;
                if (void 0 === d) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", t);
                else {
                    if (!1 !== d.complete) {
                        void 0 === p.__webglInit && (p.__webglInit = !0, t.addEventListener("dispose", u), p.__webglTexture = e.createTexture(), o.textures++), i.activeTexture(e.TEXTURE0 + l), i.bindTexture(e.TEXTURE_2D, p.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, t.unpackAlignment);
                        var m = s(t.image, r.maxTextureSize);
                        if ((1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter) && !1 === c(m))
                            if (d = m, d instanceof HTMLImageElement || d instanceof HTMLCanvasElement) {
                                var g = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                                g.width = _a.nearestPowerOfTwo(d.width), g.height = _a.nearestPowerOfTwo(d.height), g.getContext("2d").drawImage(d, 0, 0, g.width, g.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + d.width + "x" + d.height + "). Resized to " + g.width + "x" + g.height, d), m = g
                            } else m = d;
                        var d = c(m),
                            g = a(t.format),
                            y = a(t.type);
                        f(e.TEXTURE_2D, t, d);
                        var x = t.mipmaps;
                        if (t.isDepthTexture) {
                            if (x = e.DEPTH_COMPONENT, 1015 === t.type) {
                                if (!v) throw Error("Float Depth Texture only supported in WebGL2.0");
                                x = e.DEPTH_COMPONENT32F
                            } else v && (x = e.DEPTH_COMPONENT16);
                            1026 === t.format && x === e.DEPTH_COMPONENT && 1012 !== t.type && 1014 !== t.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), t.type = 1012, y = a(t.type)), 1027 === t.format && (x = e.DEPTH_STENCIL, 1020 !== t.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), t.type = 1020, y = a(t.type))), i.texImage2D(e.TEXTURE_2D, 0, x, m.width, m.height, 0, g, y, null)
                        } else if (t.isDataTexture)
                            if (0 < x.length && d) {
                                for (var b = 0, _ = x.length; _ > b; b++) m = x[b], i.texImage2D(e.TEXTURE_2D, b, g, m.width, m.height, 0, g, y, m.data);
                                t.generateMipmaps = !1
                            } else i.texImage2D(e.TEXTURE_2D, 0, g, m.width, m.height, 0, g, y, m.data);
                        else if (t.isCompressedTexture)
                            for (b = 0, _ = x.length; _ > b; b++) m = x[b], 1023 !== t.format && 1022 !== t.format ? -1 < i.getCompressedTextureFormats().indexOf(g) ? i.compressedTexImage2D(e.TEXTURE_2D, b, g, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(e.TEXTURE_2D, b, g, m.width, m.height, 0, g, y, m.data);
                        else if (0 < x.length && d) {
                            for (b = 0, _ = x.length; _ > b; b++) m = x[b], i.texImage2D(e.TEXTURE_2D, b, g, g, y, m);
                            t.generateMipmaps = !1
                        } else i.texImage2D(e.TEXTURE_2D, 0, g, g, y, m);
                        return h(t, d) && e.generateMipmap(e.TEXTURE_2D), p.__version = t.version, t.onUpdate && t.onUpdate(t), void 0
                    }
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", t)
                }
            }
            i.activeTexture(e.TEXTURE0 + l), i.bindTexture(e.TEXTURE_2D, p.__webglTexture)
        }

        function f(i, o, s) {
            s ? (e.texParameteri(i, e.TEXTURE_WRAP_S, a(o.wrapS)), e.texParameteri(i, e.TEXTURE_WRAP_T, a(o.wrapT)), e.texParameteri(i, e.TEXTURE_MAG_FILTER, a(o.magFilter)), e.texParameteri(i, e.TEXTURE_MIN_FILTER, a(o.minFilter))) : (e.texParameteri(i, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(i, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), 1001 === o.wrapS && 1001 === o.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", o), e.texParameteri(i, e.TEXTURE_MAG_FILTER, l(o.magFilter)), e.texParameteri(i, e.TEXTURE_MIN_FILTER, l(o.minFilter)), 1003 !== o.minFilter && 1006 !== o.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", o)), !(s = t.get("EXT_texture_filter_anisotropic")) || 1015 === o.type && null === t.get("OES_texture_float_linear") || 1016 === o.type && null === t.get("OES_texture_half_float_linear") || !(1 < o.anisotropy || n.get(o).__currentAnisotropy) || (e.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), n.get(o).__currentAnisotropy = o.anisotropy)
        }

        function m(t, r, o, s) {
            var c = a(r.texture.format),
                h = a(r.texture.type);
            i.texImage2D(s, 0, c, r.width, r.height, 0, c, h, null), e.bindFramebuffer(e.FRAMEBUFFER, t), e.framebufferTexture2D(e.FRAMEBUFFER, o, s, n.get(r.texture).__webglTexture, 0), e.bindFramebuffer(e.FRAMEBUFFER, null)
        }

        function g(t, i) {
            e.bindRenderbuffer(e.RENDERBUFFER, t), i.depthBuffer && !i.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, i.width, i.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)) : i.depthBuffer && i.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, i.width, i.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)) : e.renderbufferStorage(e.RENDERBUFFER, e.RGBA4, i.width, i.height), e.bindRenderbuffer(e.RENDERBUFFER, null)
        }
        var v = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext;
        this.setTexture2D = d, this.setTextureCube = function (t, l) {
            var p = n.get(t);
            if (6 === t.image.length)
                if (0 < t.version && p.__version !== t.version) {
                    p.__image__webglTextureCube || (t.addEventListener("dispose", u), p.__image__webglTextureCube = e.createTexture(), o.textures++), i.activeTexture(e.TEXTURE0 + l), i.bindTexture(e.TEXTURE_CUBE_MAP, p.__image__webglTextureCube), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t.flipY);
                    for (var d = t && t.isCompressedTexture, m = t.image[0] && t.image[0].isDataTexture, g = [], v = 0; 6 > v; v++) g[v] = d || m ? m ? t.image[v].image : t.image[v] : s(t.image[v], r.maxCubemapSize);
                    var y = c(g[0]),
                        x = a(t.format),
                        b = a(t.type);
                    for (f(e.TEXTURE_CUBE_MAP, t, y), v = 0; 6 > v; v++)
                        if (d)
                            for (var _, w = g[v].mipmaps, M = 0, E = w.length; E > M; M++) _ = w[M], 1023 !== t.format && 1022 !== t.format ? -1 < i.getCompressedTextureFormats().indexOf(x) ? i.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + v, M, x, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + v, M, x, _.width, _.height, 0, x, b, _.data);
                        else m ? i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + v, 0, x, g[v].width, g[v].height, 0, x, b, g[v].data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + v, 0, x, x, b, g[v]);
                    h(t, y) && e.generateMipmap(e.TEXTURE_CUBE_MAP), p.__version = t.version, t.onUpdate && t.onUpdate(t)
                } else i.activeTexture(e.TEXTURE0 + l), i.bindTexture(e.TEXTURE_CUBE_MAP, p.__image__webglTextureCube)
        }, this.setTextureCubeDynamic = function (t, r) {
            i.activeTexture(e.TEXTURE0 + r), i.bindTexture(e.TEXTURE_CUBE_MAP, n.get(t).__webglTexture)
        }, this.setupRenderTarget = function (t) {
            var r = n.get(t),
                a = n.get(t.texture);
            t.addEventListener("dispose", p), a.__webglTexture = e.createTexture(), o.textures++;
            var s = !0 === t.isWebGLRenderTargetCube,
                l = c(t);
            if (s) {
                r.__webglFramebuffer = [];
                for (var u = 0; 6 > u; u++) r.__webglFramebuffer[u] = e.createFramebuffer()
            } else r.__webglFramebuffer = e.createFramebuffer();
            if (s) {
                for (i.bindTexture(e.TEXTURE_CUBE_MAP, a.__webglTexture), f(e.TEXTURE_CUBE_MAP, t.texture, l), u = 0; 6 > u; u++) m(r.__webglFramebuffer[u], t, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + u);
                h(t.texture, l) && e.generateMipmap(e.TEXTURE_CUBE_MAP), i.bindTexture(e.TEXTURE_CUBE_MAP, null)
            } else i.bindTexture(e.TEXTURE_2D, a.__webglTexture), f(e.TEXTURE_2D, t.texture, l), m(r.__webglFramebuffer, t, e.COLOR_ATTACHMENT0, e.TEXTURE_2D), h(t.texture, l) && e.generateMipmap(e.TEXTURE_2D), i.bindTexture(e.TEXTURE_2D, null);
            if (t.depthBuffer) {
                if (r = n.get(t), a = !0 === t.isWebGLRenderTargetCube, t.depthTexture) {
                    if (a) throw Error("target.depthTexture not supported in Cube render targets");
                    if (t && t.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported!");
                    if (e.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer), !t.depthTexture || !t.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    if (n.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), d(t.depthTexture, 0), r = n.get(t.depthTexture).__webglTexture, 1026 === t.depthTexture.format) e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, r, 0);
                    else {
                        if (1027 !== t.depthTexture.format) throw Error("Unknown depthTexture format");
                        e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, r, 0)
                    }
                } else if (a)
                    for (r.__webglDepthbuffer = [], a = 0; 6 > a; a++) e.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[a]), r.__webglDepthbuffer[a] = e.createRenderbuffer(), g(r.__webglDepthbuffer[a], t);
                else e.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), g(r.__webglDepthbuffer, t);
                e.bindFramebuffer(e.FRAMEBUFFER, null)
            }
        }, this.updateRenderTargetMipmap = function (t) {
            var r = t.texture,
                a = c(t);
            h(r, a) && (t = t.isWebGLRenderTargetCube ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D, r = n.get(r).__webglTexture, i.bindTexture(t, r), e.generateMipmap(t), i.bindTexture(t, null))
        }
    }

    function ri() {
        var e = {};
        return {
            get: function (t) {
                t = t.uuid;
                var i = e[t];
                return void 0 === i && (i = {}, e[t] = i), i
            },
            remove: function (t) {
                delete e[t.uuid]
            },
            clear: function () {
                e = {}
            }
        }
    }

    function ai(e, t, i) {
        function n(t, i, n) {
            var r = new Uint8Array(4),
                a = e.createTexture();
            for (e.bindTexture(t, a), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST), t = 0; n > t; t++) e.texImage2D(i + t, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, r);
            return a
        }

        function a(t) {
            !0 !== x[t] && (e.enable(t), x[t] = !0)
        }

        function o(t) {
            !1 !== x[t] && (e.disable(t), x[t] = !1)
        }

        function s(t, n, r, s, c, h, l, u) {
            0 !== t ? a(e.BLEND) : o(e.BLEND), 5 === t || t === _ && u === R || (2 === t ? u ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE, e.ONE, e.ONE)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE)) : 3 === t ? u ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR)) : 4 === t ? u ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.SRC_COLOR)) : u ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)), _ = t, R = u), 5 === t ? (c = c || n, h = h || r, l = l || s, (n !== w || c !== T) && (e.blendEquationSeparate(i(n), i(c)), w = n, T = c), (r !== M || s !== E || h !== S || l !== A) && (e.blendFuncSeparate(i(r), i(s), i(h), i(l)), M = r, E = s, S = h, A = l)) : A = S = T = E = M = w = null
        }

        function c(t) {
            L !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), L = t)
        }

        function h(t) {
            0 !== t ? (a(e.CULL_FACE), t !== P && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : o(e.CULL_FACE), P = t
        }

        function l(t, i, n) {
            t ? (a(e.POLYGON_OFFSET_FILL), (I !== i || U !== n) && (e.polygonOffset(i, n), I = i, U = n)) : o(e.POLYGON_OFFSET_FILL)
        }

        function u(t) {
            void 0 === t && (t = e.TEXTURE0 + D - 1), F !== t && (e.activeTexture(t), F = t)
        }
        var p = new function () {
                var t = !1,
                    i = new r,
                    n = null,
                    a = new r;
                return {
                    setMask: function (i) {
                        n === i || t || (e.colorMask(i, i, i, i), n = i)
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (t, n, r, o, s) {
                        !0 === s && (t *= o, n *= o, r *= o), i.set(t, n, r, o), !1 === a.equals(i) && (e.clearColor(t, n, r, o), a.copy(i))
                    },
                    reset: function () {
                        t = !1, n = null, a.set(0, 0, 0, 1)
                    }
                }
            },
            d = new function () {
                var t = !1,
                    i = null,
                    n = null,
                    r = null;
                return {
                    setTest: function (t) {
                        t ? a(e.DEPTH_TEST) : o(e.DEPTH_TEST)
                    },
                    setMask: function (n) {
                        i === n || t || (e.depthMask(n), i = n)
                    },
                    setFunc: function (t) {
                        if (n !== t) {
                            if (t) switch (t) {
                                case 0:
                                    e.depthFunc(e.NEVER);
                                    break;
                                case 1:
                                    e.depthFunc(e.ALWAYS);
                                    break;
                                case 2:
                                    e.depthFunc(e.LESS);
                                    break;
                                case 3:
                                    e.depthFunc(e.LEQUAL);
                                    break;
                                case 4:
                                    e.depthFunc(e.EQUAL);
                                    break;
                                case 5:
                                    e.depthFunc(e.GEQUAL);
                                    break;
                                case 6:
                                    e.depthFunc(e.GREATER);
                                    break;
                                case 7:
                                    e.depthFunc(e.NOTEQUAL);
                                    break;
                                default:
                                    e.depthFunc(e.LEQUAL)
                            } else e.depthFunc(e.LEQUAL);
                            n = t
                        }
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (t) {
                        r !== t && (e.clearDepth(t), r = t)
                    },
                    reset: function () {
                        t = !1, r = n = i = null
                    }
                }
            },
            f = new function () {
                var t = !1,
                    i = null,
                    n = null,
                    r = null,
                    s = null,
                    c = null,
                    h = null,
                    l = null,
                    u = null;
                return {
                    setTest: function (t) {
                        t ? a(e.STENCIL_TEST) : o(e.STENCIL_TEST)
                    },
                    setMask: function (n) {
                        i === n || t || (e.stencilMask(n), i = n)
                    },
                    setFunc: function (t, i, a) {
                        (n !== t || r !== i || s !== a) && (e.stencilFunc(t, i, a), n = t, r = i, s = a)
                    },
                    setOp: function (t, i, n) {
                        (c !== t || h !== i || l !== n) && (e.stencilOp(t, i, n), c = t, h = i, l = n)
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (t) {
                        u !== t && (e.clearStencil(t), u = t)
                    },
                    reset: function () {
                        t = !1, u = l = h = c = s = r = n = i = null
                    }
                }
            },
            m = e.getParameter(e.MAX_VERTEX_ATTRIBS),
            g = new Uint8Array(m),
            v = new Uint8Array(m),
            y = new Uint8Array(m),
            x = {},
            b = null,
            _ = null,
            w = null,
            M = null,
            E = null,
            T = null,
            S = null,
            A = null,
            R = !1,
            L = null,
            P = null,
            C = null,
            I = null,
            U = null,
            N = null,
            D = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            m = parseFloat(/^WebGL\ ([0-9])/.exec(e.getParameter(e.VERSION))[1]),
            O = 1 <= parseFloat(m),
            F = null,
            B = {},
            z = new r,
            G = new r,
            H = {};
        return H[e.TEXTURE_2D] = n(e.TEXTURE_2D, e.TEXTURE_2D, 1), H[e.TEXTURE_CUBE_MAP] = n(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), {
            buffers: {
                color: p,
                depth: d,
                stencil: f
            },
            init: function () {
                p.setClear(0, 0, 0, 1), d.setClear(1), f.setClear(0), a(e.DEPTH_TEST), d.setFunc(3), c(!1), h(1), a(e.CULL_FACE), a(e.BLEND), s(1)
            },
            initAttributes: function () {
                for (var e = 0, t = g.length; t > e; e++) g[e] = 0
            },
            enableAttribute: function (i) {
                g[i] = 1, 0 === v[i] && (e.enableVertexAttribArray(i), v[i] = 1), 0 !== y[i] && (t.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, 0), y[i] = 0)
            },
            enableAttributeAndDivisor: function (i, n) {
                g[i] = 1, 0 === v[i] && (e.enableVertexAttribArray(i), v[i] = 1), y[i] !== n && (t.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, n), y[i] = n)
            },
            disableUnusedAttributes: function () {
                for (var t = 0, i = v.length; t !== i; ++t) v[t] !== g[t] && (e.disableVertexAttribArray(t), v[t] = 0)
            },
            enable: a,
            disable: o,
            getCompressedTextureFormats: function () {
                if (null === b && (b = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1")))
                    for (var i = e.getParameter(e.COMPRESSED_TEXTURE_FORMATS), n = 0; n < i.length; n++) b.push(i[n]);
                return b
            },
            setBlending: s,
            setMaterial: function (t) {
                2 === t.side ? o(e.CULL_FACE) : a(e.CULL_FACE), c(1 === t.side), !0 === t.transparent ? s(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha) : s(0), d.setFunc(t.depthFunc), d.setTest(t.depthTest), d.setMask(t.depthWrite), p.setMask(t.colorWrite), l(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
            },
            setFlipSided: c,
            setCullFace: h,
            setLineWidth: function (t) {
                t !== C && (O && e.lineWidth(t), C = t)
            },
            setPolygonOffset: l,
            getScissorTest: function () {
                return N
            },
            setScissorTest: function (t) {
                (N = t) ? a(e.SCISSOR_TEST): o(e.SCISSOR_TEST)
            },
            activeTexture: u,
            bindTexture: function (t, i) {
                null === F && u();
                var n = B[F];
                void 0 === n && (n = {
                    type: void 0,
                    texture: void 0
                }, B[F] = n), (n.type !== t || n.texture !== i) && (e.bindTexture(t, i || H[t]), n.type = t, n.texture = i)
            },
            compressedTexImage2D: function () {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage2D: function () {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            scissor: function (t) {
                !1 === z.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), z.copy(t))
            },
            viewport: function (t) {
                !1 === G.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), G.copy(t))
            },
            reset: function () {
                for (var t = 0; t < v.length; t++) 1 === v[t] && (e.disableVertexAttribArray(t), v[t] = 0);
                x = {}, F = b = null, B = {}, P = L = _ = null, p.reset(), d.reset(), f.reset()
            }
        }
    }

    function oi(e, t, i) {
        function n(t) {
            if ("highp" === t) {
                if (0 < e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision && 0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision) return "highp";
                t = "mediump"
            }
            return "mediump" === t && 0 < e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision && 0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
        }
        var r, a = void 0 !== i.precision ? i.precision : "highp",
            o = n(a);
        o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o), i = !0 === i.logarithmicDepthBuffer && !!t.get("EXT_frag_depth");
        var o = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
            s = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            c = e.getParameter(e.MAX_TEXTURE_SIZE),
            h = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
            l = e.getParameter(e.MAX_VERTEX_ATTRIBS),
            u = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
            p = e.getParameter(e.MAX_VARYING_VECTORS),
            d = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
            f = s > 0,
            m = !!t.get("OES_texture_float");
        return {
            getMaxAnisotropy: function () {
                if (void 0 !== r) return r;
                var i = t.get("EXT_texture_filter_anisotropic");
                return r = null !== i ? e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: n,
            precision: a,
            logarithmicDepthBuffer: i,
            maxTextures: o,
            maxVertexTextures: s,
            maxTextureSize: c,
            maxCubemapSize: h,
            maxAttributes: l,
            maxVertexUniforms: u,
            maxVaryings: p,
            maxFragmentUniforms: d,
            vertexTextures: f,
            floatFragmentTextures: m,
            floatVertexTextures: f && m
        }
    }

    function si(e) {
        ct.call(this), this.cameras = e || []
    }

    function ci(e) {
        var t = this,
            i = null,
            n = null;
        "VRFrameData" in window && (n = new window.VRFrameData);
        var a = new h,
            o = new h,
            s = new h,
            c = new ct;
        c.bounds = new r(0, 0, .5, 1), c.layers.enable(1);
        var l = new ct;
        l.bounds = new r(.5, 0, .5, 1), l.layers.enable(2);
        var u = new si([c, l]);
        u.layers.enable(1), u.layers.enable(2);
        var p, d;
        window.addEventListener("vrdisplaypresentchange", function () {
            if (i.isPresenting) {
                var n = i.getEyeParameters("left"),
                    r = n.renderWidth,
                    n = n.renderHeight;
                d = e.getPixelRatio(), p = e.getSize(), e.setDrawingBufferSize(2 * r, n, 1)
            } else t.enabled && e.setDrawingBufferSize(p.width, p.height, d)
        }, !1), this.standing = this.enabled = !1, this.getDevice = function () {
            return i
        }, this.setDevice = function (e) {
            void 0 !== e && (i = e)
        }, this.getCamera = function (e) {
            if (null === i) return e;
            i.depthNear = e.near, i.depthFar = e.far, i.getFrameData(n);
            var t = n.pose;
            return null !== t.position ? e.position.fromArray(t.position) : e.position.set(0, 0, 0), null !== t.orientation && e.quaternion.fromArray(t.orientation), e.updateMatrixWorld(), t = i.stageParameters, this.standing && t && (o.fromArray(t.sittingToStandingTransform), s.getInverse(o), e.matrixWorld.multiply(o), e.matrixWorldInverse.multiply(s)), !1 === i.isPresenting ? e : (u.matrixWorld.copy(e.matrixWorld), u.matrixWorldInverse.copy(e.matrixWorldInverse), c.matrixWorldInverse.fromArray(n.leftViewMatrix), l.matrixWorldInverse.fromArray(n.rightViewMatrix), this.standing && t && (c.matrixWorldInverse.multiply(s), l.matrixWorldInverse.multiply(s)), e = e.parent, null !== e && (a.getInverse(e.matrixWorld), c.matrixWorldInverse.multiply(a), l.matrixWorldInverse.multiply(a)), c.matrixWorld.getInverse(c.matrixWorldInverse), l.matrixWorld.getInverse(l.matrixWorldInverse), c.projectionMatrix.fromArray(n.leftProjectionMatrix), l.projectionMatrix.fromArray(n.rightProjectionMatrix), u.projectionMatrix.copy(c.projectionMatrix), e = i.getLayers(), e.length && (e = e[0], null !== e.leftBounds && 4 === e.leftBounds.length && c.bounds.fromArray(e.leftBounds), null !== e.rightBounds && 4 === e.rightBounds.length && l.bounds.fromArray(e.rightBounds)), u)
        }, this.getStandingMatrix = function () {
            return o
        }, this.submitFrame = function () {
            i && i.isPresenting && i.submitFrame()
        }
    }

    function hi(e) {
        var t = {};
        return {
            get: function (i) {
                if (void 0 !== t[i]) return t[i];
                var n;
                switch (i) {
                    case "WEBGL_depth_texture":
                        n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    case "WEBGL_compressed_texture_etc1":
                        n = e.getExtension("WEBGL_compressed_texture_etc1");
                        break;
                    default:
                        n = e.getExtension(i)
                }
                return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), t[i] = n
            }
        }
    }

    function li() {
        function e() {
            h.value !== n && (h.value = n, h.needsUpdate = r > 0), i.numPlanes = r, i.numIntersection = 0
        }

        function t(e, t, n, r) {
            var a = null !== e ? e.length : 0,
                o = null;
            if (0 !== a) {
                if (o = h.value, !0 !== r || null === o)
                    for (r = n + 4 * a, t = t.matrixWorldInverse, c.getNormalMatrix(t), (null === o || o.length < r) && (o = new Float32Array(r)), r = 0; r !== a; ++r, n += 4) s.copy(e[r]).applyMatrix4(t, c), s.normal.toArray(o, n), o[n + 3] = s.constant;
                h.value = o, h.needsUpdate = !0
            }
            return i.numPlanes = a, o
        }
        var i = this,
            n = null,
            r = 0,
            a = !1,
            o = !1,
            s = new $,
            c = new K,
            h = {
                value: null,
                needsUpdate: !1
            };
        this.uniform = h, this.numIntersection = this.numPlanes = 0, this.init = function (e, i, o) {
            var s = 0 !== e.length || i || 0 !== r || a;
            return a = i, n = t(e, o, 0), r = e.length, s
        }, this.beginShadows = function () {
            o = !0, t(null)
        }, this.endShadows = function () {
            o = !1, e()
        }, this.setState = function (i, s, c, l, u, p) {
            if (!a || null === i || 0 === i.length || o && !c) o ? t(null) : e();
            else {
                c = o ? 0 : r;
                var d = 4 * c,
                    f = u.clippingState || null;
                for (h.value = f, f = t(i, l, d, p), i = 0; i !== d; ++i) f[i] = n[i];
                u.clippingState = f, this.numIntersection = s ? this.numPlanes : 0, this.numPlanes += c
            }
        }
    }

    function ui(e) {
        function t() {
            xt.init(), xt.scissor(k.copy(K).multiplyScalar(Q)), xt.viewport(q.copy(nt).multiplyScalar(Q))
        }

        function i() {
            G = D = null, z = "", B = -1, xt.reset()
        }

        function n(e) {
            e.preventDefault(), i(), t(), bt.clear(), Tt.clear()
        }

        function a(e) {
            e = e.target, e.removeEventListener("dispose", a), o(e), bt.remove(e)
        }

        function o(e) {
            var t = bt.get(e).program;
            e.program = void 0, void 0 !== t && St.releaseProgram(t)
        }

        function s(e, t, i) {
            e.render(function (e) {
                N.renderBufferImmediate(e, t, i)
            })
        }

        function u(e, t) {
            return Math.abs(t[0]) - Math.abs(e[0])
        }

        function p(e, t, i) {
            if (e.visible) {
                if (e.layers.test(t.layers))
                    if (e.isLight) L.push(e);
                    else if (e.isSprite) e.frustumCulled && !rt.intersectsSprite(e) || I.push(e);
                else if (e.isLensFlare) U.push(e);
                else if (e.isImmediateRenderObject) i && ht.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ct), P.push(e, null, e.material, ht.z, null);
                else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || rt.intersectsObject(e))) {
                    i && ht.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ct);
                    var n = Tt.update(e),
                        r = e.material;
                    if (Array.isArray(r))
                        for (var a = n.groups, o = 0, s = a.length; s > o; o++) {
                            var c = a[o],
                                h = r[c.materialIndex];
                            h && h.visible && P.push(e, n, h, ht.z, c)
                        } else r.visible && P.push(e, n, r, ht.z, null)
                }
                for (e = e.children, o = 0, s = e.length; s > o; o++) p(e[o], t, i)
            }
        }

        function d(e, t, i, n) {
            for (var r = 0, a = e.length; a > r; r++) {
                var o = e[r],
                    s = o.object,
                    c = o.geometry,
                    h = void 0 === n ? o.material : n,
                    o = o.group;
                if (i.isArrayCamera) {
                    H = i;
                    for (var l = i.cameras, u = 0, p = l.length; p > u; u++) {
                        var d = l[u];
                        if (s.layers.test(d.layers)) {
                            var m = d.bounds,
                                g = m.x * Z,
                                v = m.y * J,
                                y = m.z * Z,
                                m = m.w * J;
                            N.setViewport(g, v, y, m), N.setScissor(g, v, y, m), N.setScissorTest(!0), f(s, t, d, c, h, o)
                        }
                    }
                } else H = null, f(s, t, i, c, h, o)
            }
        }

        function f(e, t, i, n, r, a) {
            if (e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.onBeforeRender(N, t, i, n, r, a), e.isImmediateRenderObject) {
                xt.setMaterial(r);
                var o = g(i, t.fog, r, e);
                z = "", s(e, o, r)
            } else N.renderBufferDirect(i, t.fog, n, r, e, a);
            e.onAfterRender(N, t, i, n, r, a)
        }

        function m(e, t, i) {
            var n = bt.get(e);
            i = St.getParameters(e, pt, t, at.numPlanes, at.numIntersection, i);
            var r = St.getProgramCode(e, i),
                s = n.program,
                c = !0;
            if (void 0 === s) e.addEventListener("dispose", a);
            else if (s.code !== r) o(e);
            else {
                if (void 0 !== i.shaderID) return;
                c = !1
            }
            if (c && (i.shaderID ? (s = Na[i.shaderID], n.shader = {
                    name: e.type,
                    uniforms: Ia.clone(s.uniforms),
                    vertexShader: s.vertexShader,
                    fragmentShader: s.fragmentShader
                }) : n.shader = {
                    name: e.type,
                    uniforms: e.uniforms,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader
                }, e.onBeforeCompile(n.shader), s = St.acquireProgram(e, n.shader, i, r), n.program = s, e.program = s), i = s.getAttributes(), e.morphTargets)
                for (r = e.numSupportedMorphTargets = 0; r < N.maxMorphTargets; r++) 0 <= i["morphTarget" + r] && e.numSupportedMorphTargets++;
            if (e.morphNormals)
                for (r = e.numSupportedMorphNormals = 0; r < N.maxMorphNormals; r++) 0 <= i["morphNormal" + r] && e.numSupportedMorphNormals++;
            i = n.shader.uniforms, (!e.isShaderMaterial && !e.isRawShaderMaterial || !0 === e.clipping) && (n.numClippingPlanes = at.numPlanes, n.numIntersection = at.numIntersection, i.clippingPlanes = at.uniform), n.fog = t, n.lightsHash = pt.hash, e.lights && (i.ambientLightColor.value = pt.ambient, i.directionalLights.value = pt.directional, i.spotLights.value = pt.spot, i.rectAreaLights.value = pt.rectArea, i.pointLights.value = pt.point, i.hemisphereLights.value = pt.hemi, i.directionalShadowMap.value = pt.directionalShadowMap, i.directionalShadowMatrix.value = pt.directionalShadowMatrix, i.spotShadowMap.value = pt.spotShadowMap, i.spotShadowMatrix.value = pt.spotShadowMatrix, i.pointShadowMap.value = pt.pointShadowMap, i.pointShadowMatrix.value = pt.pointShadowMatrix), e = n.program.getUniforms(), e = V.seqWithValue(e.seq, i), n.uniformsList = e
        }

        function g(e, t, i, n) {
            Y = 0;
            var r = bt.get(i);
            ot && (st || e !== G) && at.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, e, r, e === G && i.id === B), !1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== t ? i.needsUpdate = !0 : i.lights && r.lightsHash !== pt.hash ? i.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === at.numPlanes && r.numIntersection === at.numIntersection || (i.needsUpdate = !0)), i.needsUpdate && (m(i, t, n), i.needsUpdate = !1);
            var a = !1,
                o = !1,
                s = !1,
                c = r.program,
                h = c.getUniforms(),
                u = r.shader.uniforms;
            if (c.id !== D && (mt.useProgram(c.program), D = c.id, s = o = a = !0), i.id !== B && (B = i.id, o = !0), (a || e !== G) && (h.setValue(mt, "projectionMatrix", e.projectionMatrix), yt.logarithmicDepthBuffer && h.setValue(mt, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), G !== (H || e) && (G = H || e, s = o = !0), (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && (a = h.map.cameraPosition, void 0 !== a && a.setValue(mt, ht.setFromMatrixPosition(e.matrixWorld))), (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && h.setValue(mt, "viewMatrix", e.matrixWorldInverse)), i.skinning && (h.setOptional(mt, n, "bindMatrix"), h.setOptional(mt, n, "bindMatrixInverse"), e = n.skeleton))
                if (a = e.bones, yt.floatVertexTextures) {
                    if (void 0 === e.boneTexture) {
                        var a = Math.sqrt(4 * a.length),
                            a = _a.nextPowerOfTwo(Math.ceil(a)),
                            a = Math.max(a, 4),
                            p = new Float32Array(a * a * 4);
                        p.set(e.boneMatrices);
                        var d = new l(p, a, a, 1023, 1015);
                        e.boneMatrices = p, e.boneTexture = d, e.boneTextureSize = a
                    }
                    h.setValue(mt, "boneTexture", e.boneTexture), h.setValue(mt, "boneTextureSize", e.boneTextureSize)
                } else h.setOptional(mt, e, "boneMatrices");
            if (o) {
                if (h.setValue(mt, "toneMappingExposure", N.toneMappingExposure), h.setValue(mt, "toneMappingWhitePoint", N.toneMappingWhitePoint), i.lights && (o = s, u.ambientLightColor.needsUpdate = o, u.directionalLights.needsUpdate = o, u.pointLights.needsUpdate = o, u.spotLights.needsUpdate = o, u.rectAreaLights.needsUpdate = o, u.hemisphereLights.needsUpdate = o), t && i.fog && (u.fogColor.value = t.color, t.isFog ? (u.fogNear.value = t.near, u.fogFar.value = t.far) : t.isFogExp2 && (u.fogDensity.value = t.density)), i.isMeshBasicMaterial || i.isMeshLambertMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.isMeshNormalMaterial || i.isMeshDepthMaterial) {
                    u.opacity.value = i.opacity, u.diffuse.value = i.color, i.emissive && u.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), u.map.value = i.map, u.specularMap.value = i.specularMap, u.alphaMap.value = i.alphaMap, i.lightMap && (u.lightMap.value = i.lightMap, u.lightMapIntensity.value = i.lightMapIntensity), i.aoMap && (u.aoMap.value = i.aoMap, u.aoMapIntensity.value = i.aoMapIntensity);
                    var f;
                    i.map ? f = i.map : i.specularMap ? f = i.specularMap : i.displacementMap ? f = i.displacementMap : i.normalMap ? f = i.normalMap : i.bumpMap ? f = i.bumpMap : i.roughnessMap ? f = i.roughnessMap : i.metalnessMap ? f = i.metalnessMap : i.alphaMap ? f = i.alphaMap : i.emissiveMap && (f = i.emissiveMap), void 0 !== f && (f.isWebGLRenderTarget && (f = f.texture), t = f.offset, f = f.repeat, u.offsetRepeat.value.set(t.x, t.y, f.x, f.y)), u.envMap.value = i.envMap, u.flipEnvMap.value = i.envMap && i.envMap.isCubeTexture ? -1 : 1, u.reflectivity.value = i.reflectivity, u.refractionRatio.value = i.refractionRatio
                }
                i.isLineBasicMaterial ? (u.diffuse.value = i.color, u.opacity.value = i.opacity) : i.isLineDashedMaterial ? (u.diffuse.value = i.color, u.opacity.value = i.opacity, u.dashSize.value = i.dashSize, u.totalSize.value = i.dashSize + i.gapSize, u.scale.value = i.scale) : i.isPointsMaterial ? (u.diffuse.value = i.color, u.opacity.value = i.opacity, u.size.value = i.size * Q, u.scale.value = .5 * J, u.map.value = i.map, null !== i.map && (f = i.map.offset, i = i.map.repeat, u.offsetRepeat.value.set(f.x, f.y, i.x, i.y))) : i.isMeshLambertMaterial ? i.emissiveMap && (u.emissiveMap.value = i.emissiveMap) : i.isMeshToonMaterial ? (v(u, i), i.gradientMap && (u.gradientMap.value = i.gradientMap)) : i.isMeshPhongMaterial ? v(u, i) : i.isMeshPhysicalMaterial ? (u.clearCoat.value = i.clearCoat, u.clearCoatRoughness.value = i.clearCoatRoughness, y(u, i)) : i.isMeshStandardMaterial ? y(u, i) : i.isMeshDepthMaterial ? i.displacementMap && (u.displacementMap.value = i.displacementMap, u.displacementScale.value = i.displacementScale, u.displacementBias.value = i.displacementBias) : i.isMeshNormalMaterial && (i.bumpMap && (u.bumpMap.value = i.bumpMap, u.bumpScale.value = i.bumpScale), i.normalMap && (u.normalMap.value = i.normalMap, u.normalScale.value.copy(i.normalScale)), i.displacementMap && (u.displacementMap.value = i.displacementMap, u.displacementScale.value = i.displacementScale, u.displacementBias.value = i.displacementBias)), void 0 !== u.ltcMat && (u.ltcMat.value = Ca.LTC_MAT_TEXTURE), void 0 !== u.ltcMag && (u.ltcMag.value = Ca.LTC_MAG_TEXTURE), V.upload(mt, r.uniformsList, u, N)
            }
            return h.setValue(mt, "modelViewMatrix", n.modelViewMatrix), h.setValue(mt, "normalMatrix", n.normalMatrix), h.setValue(mt, "modelMatrix", n.matrixWorld), c
        }

        function v(e, t) {
            e.specular.value = t.specular, e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
        }

        function y(e, t) {
            e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }

        function x(e, t) {
            var i, n, r, a, o, s, c, h = 0,
                l = 0,
                u = 0,
                p = t.matrixWorldInverse,
                d = 0,
                f = 0,
                m = 0,
                g = 0,
                v = 0;
            for (i = 0, n = e.length; n > i; i++)
                if (r = e[i], a = r.color, o = r.intensity, s = r.distance, c = r.shadow && r.shadow.map ? r.shadow.map.texture : null, r.isAmbientLight) h += a.r * o, l += a.g * o, u += a.b * o;
                else if (r.isDirectionalLight) {
                var y = At.get(r);
                y.color.copy(r.color).multiplyScalar(r.intensity), y.direction.setFromMatrixPosition(r.matrixWorld), ht.setFromMatrixPosition(r.target.matrixWorld), y.direction.sub(ht), y.direction.transformDirection(p), (y.shadow = r.castShadow) && (a = r.shadow, y.shadowBias = a.bias, y.shadowRadius = a.radius, y.shadowMapSize = a.mapSize), pt.directionalShadowMap[d] = c, pt.directionalShadowMatrix[d] = r.shadow.matrix, pt.directional[d] = y, d++
            } else r.isSpotLight ? (y = At.get(r), y.position.setFromMatrixPosition(r.matrixWorld), y.position.applyMatrix4(p), y.color.copy(a).multiplyScalar(o), y.distance = s, y.direction.setFromMatrixPosition(r.matrixWorld), ht.setFromMatrixPosition(r.target.matrixWorld), y.direction.sub(ht), y.direction.transformDirection(p), y.coneCos = Math.cos(r.angle), y.penumbraCos = Math.cos(r.angle * (1 - r.penumbra)), y.decay = 0 === r.distance ? 0 : r.decay, (y.shadow = r.castShadow) && (a = r.shadow, y.shadowBias = a.bias, y.shadowRadius = a.radius, y.shadowMapSize = a.mapSize), pt.spotShadowMap[m] = c, pt.spotShadowMatrix[m] = r.shadow.matrix, pt.spot[m] = y, m++) : r.isRectAreaLight ? (y = At.get(r), y.color.copy(a).multiplyScalar(o / (r.width * r.height)), y.position.setFromMatrixPosition(r.matrixWorld), y.position.applyMatrix4(p), ut.identity(), lt.copy(r.matrixWorld), lt.premultiply(p), ut.extractRotation(lt), y.halfWidth.set(.5 * r.width, 0, 0), y.halfHeight.set(0, .5 * r.height, 0), y.halfWidth.applyMatrix4(ut), y.halfHeight.applyMatrix4(ut), pt.rectArea[g] = y, g++) : r.isPointLight ? (y = At.get(r), y.position.setFromMatrixPosition(r.matrixWorld), y.position.applyMatrix4(p), y.color.copy(r.color).multiplyScalar(r.intensity), y.distance = r.distance, y.decay = 0 === r.distance ? 0 : r.decay, (y.shadow = r.castShadow) && (a = r.shadow, y.shadowBias = a.bias, y.shadowRadius = a.radius, y.shadowMapSize = a.mapSize), pt.pointShadowMap[f] = c, pt.pointShadowMatrix[f] = r.shadow.matrix, pt.point[f] = y, f++) : r.isHemisphereLight && (y = At.get(r), y.direction.setFromMatrixPosition(r.matrixWorld), y.direction.transformDirection(p), y.direction.normalize(), y.skyColor.copy(r.color).multiplyScalar(o), y.groundColor.copy(r.groundColor).multiplyScalar(o), pt.hemi[v] = y, v++);
            pt.ambient[0] = h, pt.ambient[1] = l, pt.ambient[2] = u, pt.directional.length = d, pt.spot.length = m, pt.rectArea.length = g, pt.point.length = f, pt.hemi.length = v, pt.hash = d + "," + f + "," + m + "," + g + "," + v + "," + pt.shadows.length
        }

        function b(e) {
            var t;
            if (1e3 === e) return mt.REPEAT;
            if (1001 === e) return mt.CLAMP_TO_EDGE;
            if (1002 === e) return mt.MIRRORED_REPEAT;
            if (1003 === e) return mt.NEAREST;
            if (1004 === e) return mt.NEAREST_MIPMAP_NEAREST;
            if (1005 === e) return mt.NEAREST_MIPMAP_LINEAR;
            if (1006 === e) return mt.LINEAR;
            if (1007 === e) return mt.LINEAR_MIPMAP_NEAREST;
            if (1008 === e) return mt.LINEAR_MIPMAP_LINEAR;
            if (1009 === e) return mt.UNSIGNED_BYTE;
            if (1017 === e) return mt.UNSIGNED_SHORT_4_4_4_4;
            if (1018 === e) return mt.UNSIGNED_SHORT_5_5_5_1;
            if (1019 === e) return mt.UNSIGNED_SHORT_5_6_5;
            if (1010 === e) return mt.BYTE;
            if (1011 === e) return mt.SHORT;
            if (1012 === e) return mt.UNSIGNED_SHORT;
            if (1013 === e) return mt.INT;
            if (1014 === e) return mt.UNSIGNED_INT;
            if (1015 === e) return mt.FLOAT;
            if (1016 === e && (t = vt.get("OES_texture_half_float"), null !== t)) return t.HALF_FLOAT_OES;
            if (1021 === e) return mt.ALPHA;
            if (1022 === e) return mt.RGB;
            if (1023 === e) return mt.RGBA;
            if (1024 === e) return mt.LUMINANCE;
            if (1025 === e) return mt.LUMINANCE_ALPHA;
            if (1026 === e) return mt.DEPTH_COMPONENT;
            if (1027 === e) return mt.DEPTH_STENCIL;
            if (100 === e) return mt.FUNC_ADD;
            if (101 === e) return mt.FUNC_SUBTRACT;
            if (102 === e) return mt.FUNC_REVERSE_SUBTRACT;
            if (200 === e) return mt.ZERO;
            if (201 === e) return mt.ONE;
            if (202 === e) return mt.SRC_COLOR;
            if (203 === e) return mt.ONE_MINUS_SRC_COLOR;
            if (204 === e) return mt.SRC_ALPHA;
            if (205 === e) return mt.ONE_MINUS_SRC_ALPHA;
            if (206 === e) return mt.DST_ALPHA;
            if (207 === e) return mt.ONE_MINUS_DST_ALPHA;
            if (208 === e) return mt.DST_COLOR;
            if (209 === e) return mt.ONE_MINUS_DST_COLOR;
            if (210 === e) return mt.SRC_ALPHA_SATURATE;
            if ((2001 === e || 2002 === e || 2003 === e || 2004 === e) && (t = vt.get("WEBGL_compressed_texture_s3tc"), null !== t)) {
                if (2001 === e) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (2002 === e) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (2003 === e) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (2004 === e) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if ((2100 === e || 2101 === e || 2102 === e || 2103 === e) && (t = vt.get("WEBGL_compressed_texture_pvrtc"), null !== t)) {
                if (2100 === e) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (2101 === e) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (2102 === e) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (2103 === e) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (2151 === e && (t = vt.get("WEBGL_compressed_texture_etc1"), null !== t)) return t.COMPRESSED_RGB_ETC1_WEBGL;
            if ((103 === e || 104 === e) && (t = vt.get("EXT_blend_minmax"), null !== t)) {
                if (103 === e) return t.MIN_EXT;
                if (104 === e) return t.MAX_EXT
            }
            return 1020 === e && (t = vt.get("WEBGL_depth_texture"), null !== t) ? t.UNSIGNED_INT_24_8_WEBGL : 0
        }
        console.log("THREE.WebGLRenderer", "86"), e = e || {};
        var _ = void 0 !== e.canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            w = void 0 !== e.context ? e.context : null,
            M = void 0 !== e.alpha ? e.alpha : !1,
            E = void 0 !== e.depth ? e.depth : !0,
            T = void 0 !== e.stencil ? e.stencil : !0,
            S = void 0 !== e.antialias ? e.antialias : !1,
            A = void 0 !== e.premultipliedAlpha ? e.premultipliedAlpha : !0,
            R = void 0 !== e.preserveDrawingBuffer ? e.preserveDrawingBuffer : !1,
            L = [],
            P = null,
            C = new Float32Array(8),
            I = [],
            U = [];
        this.domElement = _, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var N = this,
            D = null,
            O = null,
            F = null,
            B = -1,
            z = "",
            G = null,
            H = null,
            k = new r,
            j = null,
            q = new r,
            Y = 0,
            Z = _.width,
            J = _.height,
            Q = 1,
            K = new r(0, 0, Z, J),
            $ = !1,
            nt = new r(0, 0, Z, J),
            rt = new et,
            at = new li,
            ot = !1,
            st = !1,
            ct = new h,
            ht = new c,
            lt = new h,
            ut = new h,
            pt = {
                hash: "",
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                shadows: []
            },
            dt = {
                geometries: 0,
                textures: 0
            },
            ft = {
                frame: 0,
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            };
        this.info = {
            render: ft,
            memory: dt,
            programs: null
        };
        var mt;
        try {
            if (M = {
                    alpha: M,
                    depth: E,
                    stencil: T,
                    antialias: S,
                    premultipliedAlpha: A,
                    preserveDrawingBuffer: R
                }, mt = w || _.getContext("webgl", M) || _.getContext("experimental-webgl", M), null === mt) {
                if (null !== _.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
                throw "Error creating WebGL context."
            }
            void 0 === mt.getShaderPrecisionFormat && (mt.getShaderPrecisionFormat = function () {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }), _.addEventListener("webglcontextlost", n, !1)
        } catch (gt) {
            console.error("THREE.WebGLRenderer: " + gt)
        }
        var vt = new hi(mt);
        vt.get("WEBGL_depth_texture"), vt.get("OES_texture_float"), vt.get("OES_texture_float_linear"), vt.get("OES_texture_half_float"), vt.get("OES_texture_half_float_linear"), vt.get("OES_standard_derivatives"), vt.get("ANGLE_instanced_arrays"), vt.get("OES_element_index_uint") && (Mt.MaxIndex = 4294967296);
        var yt = new oi(mt, vt, e),
            xt = new ai(mt, vt, b),
            bt = new ri,
            _t = new ni(mt, vt, xt, bt, yt, b, dt),
            wt = new it(mt),
            Et = new Gt(mt, wt, dt),
            Tt = new Vt(mt, Et, ft),
            St = new ii(this, yt),
            At = new Ht,
            Rt = new Ft,
            Lt = new Ut(this, xt, Tt, A),
            Pt = new ci(this);
        this.info.programs = St.programs;
        var Ct = new zt(mt, vt, ft),
            It = new Bt(mt, vt, ft);
        t(), this.context = mt, this.capabilities = yt, this.extensions = vt, this.properties = bt, this.renderLists = Rt, this.state = xt, this.vr = Pt;
        var Nt = new tt(this, pt, Tt, yt);
        this.shadowMap = Nt;
        var Dt = new X(this, I),
            Ot = new W(this, U);
        this.getContext = function () {
            return mt
        }, this.getContextAttributes = function () {
            return mt.getContextAttributes()
        }, this.forceContextLoss = function () {
            var e = vt.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.getMaxAnisotropy = function () {
            return yt.getMaxAnisotropy()
        }, this.getPrecision = function () {
            return yt.precision
        }, this.getPixelRatio = function () {
            return Q
        }, this.setPixelRatio = function (e) {
            void 0 !== e && (Q = e, this.setSize(Z, J, !1))
        }, this.getSize = function () {
            return {
                width: Z,
                height: J
            }
        }, this.setSize = function (e, t, i) {
            var n = Pt.getDevice();
            n && n.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Z = e, J = t, _.width = e * Q, _.height = t * Q, !1 !== i && (_.style.width = e + "px", _.style.height = t + "px"), this.setViewport(0, 0, e, t))
        }, this.getDrawingBufferSize = function () {
            return {
                width: Z * Q,
                height: J * Q
            }
        }, this.setDrawingBufferSize = function (e, t, i) {
            Z = e, J = t, Q = i, _.width = e * i, _.height = t * i, this.setViewport(0, 0, e, t)
        }, this.setViewport = function (e, t, i, n) {
            nt.set(e, J - t - n, i, n), xt.viewport(q.copy(nt).multiplyScalar(Q))
        }, this.setScissor = function (e, t, i, n) {
            K.set(e, J - t - n, i, n), xt.scissor(k.copy(K).multiplyScalar(Q))
        }, this.setScissorTest = function (e) {
            xt.setScissorTest($ = e)
        }, this.getClearColor = Lt.getClearColor, this.setClearColor = Lt.setClearColor, this.getClearAlpha = Lt.getClearAlpha, this.setClearAlpha = Lt.setClearAlpha, this.clear = function (e, t, i) {
            var n = 0;
            (void 0 === e || e) && (n |= mt.COLOR_BUFFER_BIT), (void 0 === t || t) && (n |= mt.DEPTH_BUFFER_BIT), (void 0 === i || i) && (n |= mt.STENCIL_BUFFER_BIT), mt.clear(n)
        }, this.clearColor = function () {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
        }, this.clearTarget = function (e, t, i, n) {
            this.setRenderTarget(e), this.clear(t, i, n)
        }, this.resetGLState = i, this.dispose = function () {
            _.removeEventListener("webglcontextlost", n, !1), Rt.dispose()
        }, this.renderBufferImmediate = function (e, t, i) {
            xt.initAttributes();
            var n = bt.get(e);
            if (e.hasPositions && !n.position && (n.position = mt.createBuffer()), e.hasNormals && !n.normal && (n.normal = mt.createBuffer()), e.hasUvs && !n.uv && (n.uv = mt.createBuffer()), e.hasColors && !n.color && (n.color = mt.createBuffer()), t = t.getAttributes(), e.hasPositions && (mt.bindBuffer(mt.ARRAY_BUFFER, n.position), mt.bufferData(mt.ARRAY_BUFFER, e.positionArray, mt.DYNAMIC_DRAW), xt.enableAttribute(t.position), mt.vertexAttribPointer(t.position, 3, mt.FLOAT, !1, 0, 0)), e.hasNormals) {
                if (mt.bindBuffer(mt.ARRAY_BUFFER, n.normal), !i.isMeshPhongMaterial && !i.isMeshStandardMaterial && !i.isMeshNormalMaterial && 1 === i.shading)
                    for (var r = 0, a = 3 * e.count; a > r; r += 9) {
                        var o = e.normalArray,
                            s = (o[r + 0] + o[r + 3] + o[r + 6]) / 3,
                            c = (o[r + 1] + o[r + 4] + o[r + 7]) / 3,
                            h = (o[r + 2] + o[r + 5] + o[r + 8]) / 3;
                        o[r + 0] = s, o[r + 1] = c, o[r + 2] = h, o[r + 3] = s, o[r + 4] = c, o[r + 5] = h, o[r + 6] = s, o[r + 7] = c, o[r + 8] = h
                    }
                mt.bufferData(mt.ARRAY_BUFFER, e.normalArray, mt.DYNAMIC_DRAW), xt.enableAttribute(t.normal), mt.vertexAttribPointer(t.normal, 3, mt.FLOAT, !1, 0, 0)
            }
            e.hasUvs && i.map && (mt.bindBuffer(mt.ARRAY_BUFFER, n.uv), mt.bufferData(mt.ARRAY_BUFFER, e.uvArray, mt.DYNAMIC_DRAW), xt.enableAttribute(t.uv), mt.vertexAttribPointer(wt.uv, 2, mt.FLOAT, !1, 0, 0)), e.hasColors && 0 !== i.vertexColors && (mt.bindBuffer(mt.ARRAY_BUFFER, n.color), mt.bufferData(mt.ARRAY_BUFFER, e.colorArray, mt.DYNAMIC_DRAW), xt.enableAttribute(t.color), mt.vertexAttribPointer(t.color, 3, mt.FLOAT, !1, 0, 0)), xt.disableUnusedAttributes(), mt.drawArrays(mt.TRIANGLES, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function (e, t, i, n, r, a) {
            xt.setMaterial(n);
            var o = g(e, t, n, r);
            e = i.id + "_" + o.id + "_" + (!0 === n.wireframe);
            var s = !1;
            if (e !== z && (z = e, s = !0), t = r.morphTargetInfluences, void 0 !== t) {
                var c = [];
                e = 0;
                for (var h = t.length; h > e; e++) s = t[e], c.push([s, e]);
                c.sort(u), 8 < c.length && (c.length = 8);
                var l = i.morphAttributes;
                for (e = 0, h = c.length; h > e; e++) s = c[e], C[e] = s[0], 0 !== s[0] ? (t = s[1], !0 === n.morphTargets && l.position && i.addAttribute("morphTarget" + e, l.position[t]), !0 === n.morphNormals && l.normal && i.addAttribute("morphNormal" + e, l.normal[t])) : (!0 === n.morphTargets && i.removeAttribute("morphTarget" + e), !0 === n.morphNormals && i.removeAttribute("morphNormal" + e));
                for (e = c.length, t = C.length; t > e; e++) C[e] = 0;
                o.getUniforms().setValue(mt, "morphTargetInfluences", C), s = !0
            }
            t = i.index, h = i.attributes.position, c = 1, !0 === n.wireframe && (t = Et.getWireframeAttribute(i), c = 2);
            var p;
            if (e = Ct, null !== t && (p = wt.get(t), e = It, e.setIndex(p)), s) {
                if (s = void 0, i && i.isInstancedBufferGeometry && null === vt.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    void 0 === s && (s = 0), xt.initAttributes();
                    var d, l = i.attributes,
                        o = o.getAttributes(),
                        f = n.defaultAttributeValues;
                    for (d in o) {
                        var m = o[d];
                        if (m >= 0) {
                            var v = l[d];
                            if (void 0 !== v) {
                                var y = v.normalized,
                                    x = v.itemSize,
                                    b = wt.get(v),
                                    _ = b.buffer,
                                    w = b.type,
                                    b = b.bytesPerElement;
                                if (v.isInterleavedBufferAttribute) {
                                    var M = v.data,
                                        E = M.stride,
                                        v = v.offset;
                                    M && M.isInstancedInterleavedBuffer ? (xt.enableAttributeAndDivisor(m, M.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = M.meshPerAttribute * M.count)) : xt.enableAttribute(m), mt.bindBuffer(mt.ARRAY_BUFFER, _), mt.vertexAttribPointer(m, x, w, y, E * b, (s * E + v) * b)
                                } else v.isInstancedBufferAttribute ? (xt.enableAttributeAndDivisor(m, v.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = v.meshPerAttribute * v.count)) : xt.enableAttribute(m), mt.bindBuffer(mt.ARRAY_BUFFER, _), mt.vertexAttribPointer(m, x, w, y, 0, s * x * b)
                            } else if (void 0 !== f && (y = f[d], void 0 !== y)) switch (y.length) {
                                case 2:
                                    mt.vertexAttrib2fv(m, y);
                                    break;
                                case 3:
                                    mt.vertexAttrib3fv(m, y);
                                    break;
                                case 4:
                                    mt.vertexAttrib4fv(m, y);
                                    break;
                                default:
                                    mt.vertexAttrib1fv(m, y)
                            }
                        }
                    }
                    xt.disableUnusedAttributes()
                }
                null !== t && mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, p.buffer)
            }
            if (p = 0, null !== t ? p = t.count : void 0 !== h && (p = h.count), t = i.drawRange.start * c, h = null !== a ? a.start * c : 0, d = Math.max(t, h), a = Math.max(0, Math.min(p, t + i.drawRange.count * c, h + (null !== a ? a.count * c : 1 / 0)) - 1 - d + 1), 0 !== a) {
                if (r.isMesh)
                    if (!0 === n.wireframe) xt.setLineWidth(n.wireframeLinewidth * (null === O ? Q : 1)), e.setMode(mt.LINES);
                    else switch (r.drawMode) {
                        case 0:
                            e.setMode(mt.TRIANGLES);
                            break;
                        case 1:
                            e.setMode(mt.TRIANGLE_STRIP);
                            break;
                        case 2:
                            e.setMode(mt.TRIANGLE_FAN)
                    } else r.isLine ? (n = n.linewidth, void 0 === n && (n = 1), xt.setLineWidth(n * (null === O ? Q : 1)), r.isLineSegments ? e.setMode(mt.LINES) : r.isLineLoop ? e.setMode(mt.LINE_LOOP) : e.setMode(mt.LINE_STRIP)) : r.isPoints && e.setMode(mt.POINTS);
                i && i.isInstancedBufferGeometry ? 0 < i.maxInstancedCount && e.renderInstances(i, d, a) : e.render(d, a)
            }
        }, this.compile = function (e, t) {
            L = [], e.traverse(function (e) {
                e.isLight && L.push(e)
            }), x(L, t), e.traverse(function (t) {
                if (t.material)
                    if (Array.isArray(t.material))
                        for (var i = 0; i < t.material.length; i++) m(t.material[i], e.fog, t);
                    else m(t.material, e.fog, t)
            })
        }, this.animate = function (e) {
            function t() {
                e(), (Pt.getDevice() || window).requestAnimationFrame(t)
            }(Pt.getDevice() || window).requestAnimationFrame(t)
        }, this.render = function (e, t, i, n) {
            if (t && t.isCamera) {
                z = "", B = -1, G = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), Pt.enabled && (t = Pt.getCamera(t)), ct.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), rt.setFromMatrix(ct), L.length = 0, I.length = 0, U.length = 0, st = this.localClippingEnabled, ot = at.init(this.clippingPlanes, st, t), P = Rt.get(e, t), P.init(), p(e, t, N.sortObjects), P.finish(), !0 === N.sortObjects && P.sort(), ot && at.beginShadows();
                for (var r = L, a = 0, o = 0, s = r.length; s > o; o++) {
                    var c = r[o];
                    c.castShadow && (pt.shadows[a] = c, a++)
                }
                pt.shadows.length = a, Nt.render(e, t), x(L, t), ot && at.endShadows(), ft.frame++, ft.calls = 0, ft.vertices = 0, ft.faces = 0, ft.points = 0, void 0 === i && (i = null), this.setRenderTarget(i), Lt.render(e, t, n), n = P.opaque, r = P.transparent, e.overrideMaterial ? (a = e.overrideMaterial, n.length && d(n, e, t, a), r.length && d(r, e, t, a)) : (n.length && d(n, e, t), r.length && d(r, e, t)), Dt.render(e, t), Ot.render(e, t, q), i && _t.updateRenderTargetMipmap(i), xt.buffers.depth.setTest(!0), xt.buffers.depth.setMask(!0), xt.buffers.color.setMask(!0), t.isArrayCamera && N.setScissorTest(!1), Pt.enabled && Pt.submitFrame()
            } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.setFaceCulling = function (e, t) {
            xt.setCullFace(e), xt.setFlipSided(0 === t)
        }, this.allocTextureUnit = function () {
            var e = Y;
            return e >= yt.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e + " texture units while this GPU supports only " + yt.maxTextures), Y += 1, e
        }, this.setTexture2D = function () {
            var e = !1;
            return function (t, i) {
                t && t.isWebGLRenderTarget && (e || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), _t.setTexture2D(t, i)
            }
        }(), this.setTexture = function () {
            var e = !1;
            return function (t, i) {
                e || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), e = !0), _t.setTexture2D(t, i)
            }
        }(), this.setTextureCube = function () {
            var e = !1;
            return function (t, i) {
                t && t.isWebGLRenderTargetCube && (e || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? _t.setTextureCube(t, i) : _t.setTextureCubeDynamic(t, i)
            }
        }(), this.getRenderTarget = function () {
            return O
        }, this.setRenderTarget = function (e) {
            (O = e) && void 0 === bt.get(e).__webglFramebuffer && _t.setupRenderTarget(e);
            var t, i = e && e.isWebGLRenderTargetCube;
            e ? (t = bt.get(e), t = i ? t.__webglFramebuffer[e.activeCubeFace] : t.__webglFramebuffer, k.copy(e.scissor), j = e.scissorTest, q.copy(e.viewport)) : (t = null, k.copy(K).multiplyScalar(Q), j = $, q.copy(nt).multiplyScalar(Q)), F !== t && (mt.bindFramebuffer(mt.FRAMEBUFFER, t), F = t), xt.scissor(k), xt.setScissorTest(j), xt.viewport(q), i && (i = bt.get(e.texture), mt.framebufferTexture2D(mt.FRAMEBUFFER, mt.COLOR_ATTACHMENT0, mt.TEXTURE_CUBE_MAP_POSITIVE_X + e.activeCubeFace, i.__webglTexture, e.activeMipMapLevel))
        }, this.readRenderTargetPixels = function (e, t, i, n, r, a) {
            if (e && e.isWebGLRenderTarget) {
                var o = bt.get(e).__webglFramebuffer;
                if (o) {
                    var s = !1;
                    o !== F && (mt.bindFramebuffer(mt.FRAMEBUFFER, o), s = !0);
                    try {
                        var c = e.texture,
                            h = c.format,
                            l = c.type;
                        1023 !== h && b(h) !== mt.getParameter(mt.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === l || b(l) === mt.getParameter(mt.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === l && (vt.get("OES_texture_float") || vt.get("WEBGL_color_buffer_float")) || 1016 === l && vt.get("EXT_color_buffer_half_float") ? mt.checkFramebufferStatus(mt.FRAMEBUFFER) === mt.FRAMEBUFFER_COMPLETE ? t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - r && mt.readPixels(t, i, n, r, b(h), b(l), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                    } finally {
                        s && mt.bindFramebuffer(mt.FRAMEBUFFER, F)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }
    }

    function pi(e, t) {
        this.name = "", this.color = new k(e), this.density = void 0 !== t ? t : 25e-5
    }

    function di(e, t, i) {
        this.name = "", this.color = new k(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3
    }

    function fi() {
        at.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0
    }

    function mi(e, t, i, n, r) {
        at.call(this), this.lensFlares = [], this.positionScreen = new c, this.customUpdateCallback = void 0, void 0 !== e && this.add(e, t, i, n, r)
    }

    function gi(e) {
        q.call(this), this.type = "SpriteMaterial", this.color = new k(16777215), this.map = null, this.rotation = 0, this.lights = this.fog = !1, this.setValues(e)
    }

    function vi(e) {
        at.call(this), this.type = "Sprite", this.material = void 0 !== e ? e : new gi
    }

    function yi() {
        at.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }

    function xi(e, t) {
        if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
        else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var i = 0, n = this.bones.length; n > i; i++) this.boneInverses.push(new h)
        }
    }

    function bi() {
        at.call(this), this.type = "Bone"
    }

    function _i(e, t) {
        It.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new h, this.bindMatrixInverse = new h;
        var i = this.initBones(),
            i = new xi(i);
        this.bind(i, this.matrixWorld), this.normalizeSkinWeights()
    }

    function wi(e) {
        q.call(this), this.type = "LineBasicMaterial", this.color = new k(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(e)
    }

    function Mi(e, t, i) {
        return 1 === i ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new Ei(e, t)) : (at.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new Mt, this.material = void 0 !== t ? t : new wi({
            color: 16777215 * Math.random()
        }), void 0)
    }

    function Ei(e, t) {
        Mi.call(this, e, t), this.type = "LineSegments"
    }

    function Ti(e, t) {
        Mi.call(this, e, t), this.type = "LineLoop"
    }

    function Si(e) {
        q.call(this), this.type = "PointsMaterial", this.color = new k(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(e)
    }

    function Ai(e, t) {
        at.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new Mt, this.material = void 0 !== t ? t : new Si({
            color: 16777215 * Math.random()
        })
    }

    function Ri() {
        at.call(this), this.type = "Group"
    }

    function Li(e, t, i, r, a, o, s, c, h) {
        function l() {
            requestAnimationFrame(l), e.readyState >= e.HAVE_CURRENT_DATA && (u.needsUpdate = !0)
        }
        n.call(this, e, t, i, r, a, o, s, c, h), this.generateMipmaps = !1;
        var u = this;
        l()
    }

    function Pi(e, t, i, r, a, o, s, c, h, l, u, p) {
        n.call(this, null, o, s, c, h, l, r, a, u, p), this.image = {
            width: t,
            height: i
        }, this.mipmaps = e, this.generateMipmaps = this.flipY = !1
    }

    function Ci(e, t, i, r, a, o, s, c, h) {
        n.call(this, e, t, i, r, a, o, s, c, h), this.needsUpdate = !0
    }

    function Ii(e, t, i, r, a, o, s, c, h, l) {
        if (l = void 0 !== l ? l : 1026, 1026 !== l && 1027 !== l) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && 1026 === l && (i = 1012), void 0 === i && 1027 === l && (i = 1020), n.call(this, null, r, a, o, s, c, l, i, h), this.image = {
            width: e,
            height: t
        }, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== c ? c : 1003, this.generateMipmaps = this.flipY = !1
    }

    function Ui(e) {
        Mt.call(this), this.type = "WireframeGeometry";
        var t, i, n, r, a, o, s = [],
            h = [0, 0],
            l = {},
            u = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var p = e.faces;
            for (t = 0, n = p.length; n > t; t++) {
                var d = p[t];
                for (i = 0; 3 > i; i++) a = d[u[i]], o = d[u[(i + 1) % 3]], h[0] = Math.min(a, o), h[1] = Math.max(a, o), a = h[0] + "," + h[1], void 0 === l[a] && (l[a] = {
                    index1: h[0],
                    index2: h[1]
                })
            }
            for (a in l) t = l[a], u = e.vertices[t.index1], s.push(u.x, u.y, u.z), u = e.vertices[t.index2], s.push(u.x, u.y, u.z)
        } else if (e && e.isBufferGeometry) {
            var f, u = new c;
            if (null !== e.index) {
                for (p = e.attributes.position, d = e.index, f = e.groups, 0 === f.length && (f = [{
                        start: 0,
                        count: d.count,
                        materialIndex: 0
                    }]), e = 0, r = f.length; r > e; ++e)
                    for (t = f[e], i = t.start, n = t.count, t = i, n = i + n; n > t; t += 3)
                        for (i = 0; 3 > i; i++) a = d.getX(t + i), o = d.getX(t + (i + 1) % 3), h[0] = Math.min(a, o), h[1] = Math.max(a, o), a = h[0] + "," + h[1], void 0 === l[a] && (l[a] = {
                            index1: h[0],
                            index2: h[1]
                        });
                for (a in l) t = l[a], u.fromBufferAttribute(p, t.index1), s.push(u.x, u.y, u.z), u.fromBufferAttribute(p, t.index2), s.push(u.x, u.y, u.z)
            } else
                for (p = e.attributes.position, t = 0, n = p.count / 3; n > t; t++)
                    for (i = 0; 3 > i; i++) l = 3 * t + i, u.fromBufferAttribute(p, l), s.push(u.x, u.y, u.z), l = 3 * t + (i + 1) % 3, u.fromBufferAttribute(p, l), s.push(u.x, u.y, u.z)
        }
        this.addAttribute("position", new xt(s, 3))
    }

    function Ni(e, t, i) {
        lt.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: i
        }, this.fromBufferGeometry(new Di(e, t, i)), this.mergeVertices()
    }

    function Di(e, t, i) {
        Mt.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: i
        };
        var n, r, a = [],
            o = [],
            s = [],
            h = [],
            l = new c,
            u = new c,
            p = new c,
            d = new c,
            f = new c,
            m = t + 1;
        for (n = 0; i >= n; n++) {
            var g = n / i;
            for (r = 0; t >= r; r++) {
                var v = r / t,
                    u = e(v, g, u);
                o.push(u.x, u.y, u.z), v - 1e-5 >= 0 ? (p = e(v - 1e-5, g, p), d.subVectors(u, p)) : (p = e(v + 1e-5, g, p), d.subVectors(p, u)), g - 1e-5 >= 0 ? (p = e(v, g - 1e-5, p), f.subVectors(u, p)) : (p = e(v, g + 1e-5, p), f.subVectors(p, u)), l.crossVectors(d, f).normalize(), s.push(l.x, l.y, l.z), h.push(v, g)
            }
        }
        for (n = 0; i > n; n++)
            for (r = 0; t > r; r++) e = n * m + r + 1, l = (n + 1) * m + r + 1, u = (n + 1) * m + r, a.push(n * m + r, e, u), a.push(e, l, u);
        this.setIndex(a), this.addAttribute("position", new xt(o, 3)), this.addAttribute("normal", new xt(s, 3)), this.addAttribute("uv", new xt(h, 2))
    }

    function Oi(e, t, i, n) {
        lt.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: n
        }, this.fromBufferGeometry(new Fi(e, t, i, n)), this.mergeVertices()
    }

    function Fi(e, t, n, r) {
        function a(e) {
            h.push(e.x, e.y, e.z)
        }

        function o(t, i) {
            var n = 3 * t;
            i.x = e[n + 0], i.y = e[n + 1], i.z = e[n + 2]
        }

        function s(e, t, i, n) {
            0 > n && 1 === e.x && (l[t] = e.x - 1), 0 === i.x && 0 === i.z && (l[t] = n / 2 / Math.PI + .5)
        }
        Mt.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: r
        }, n = n || 1, r = r || 0;
        var h = [],
            l = [];
        ! function (e) {
            for (var i = new c, n = new c, r = new c, s = 0; s < t.length; s += 3) {
                o(t[s + 0], i), o(t[s + 1], n), o(t[s + 2], r);
                var h, l, u = i,
                    p = n,
                    d = r,
                    f = Math.pow(2, e),
                    m = [];
                for (h = 0; f >= h; h++) {
                    m[h] = [];
                    var g = u.clone().lerp(d, h / f),
                        v = p.clone().lerp(d, h / f),
                        y = f - h;
                    for (l = 0; y >= l; l++) m[h][l] = 0 === l && h === f ? g : g.clone().lerp(v, l / y)
                }
                for (h = 0; f > h; h++)
                    for (l = 0; 2 * (f - h) - 1 > l; l++) u = Math.floor(l / 2), 0 === l % 2 ? (a(m[h][u + 1]), a(m[h + 1][u]), a(m[h][u])) : (a(m[h][u + 1]), a(m[h + 1][u + 1]), a(m[h + 1][u]))
            }
        }(r),
        function (e) {
            for (var t = new c, i = 0; i < h.length; i += 3) t.x = h[i + 0], t.y = h[i + 1], t.z = h[i + 2], t.normalize().multiplyScalar(e), h[i + 0] = t.x, h[i + 1] = t.y, h[i + 2] = t.z
        }(n),
        function () {
            for (var e = new c, t = 0; t < h.length; t += 3) e.x = h[t + 0], e.y = h[t + 1], e.z = h[t + 2], l.push(Math.atan2(e.z, -e.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5));
            for (var e = new c, t = new c, n = new c, r = new c, a = new i, o = new i, u = new i, p = 0, d = 0; p < h.length; p += 9, d += 6) {
                e.set(h[p + 0], h[p + 1], h[p + 2]), t.set(h[p + 3], h[p + 4], h[p + 5]), n.set(h[p + 6], h[p + 7], h[p + 8]), a.set(l[d + 0], l[d + 1]), o.set(l[d + 2], l[d + 3]), u.set(l[d + 4], l[d + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                var f = Math.atan2(r.z, -r.x);
                s(a, d + 0, e, f), s(o, d + 2, t, f), s(u, d + 4, n, f)
            }
            for (e = 0; e < l.length; e += 6) t = l[e + 0], n = l[e + 2], r = l[e + 4], a = Math.min(t, n, r), .9 < Math.max(t, n, r) && .1 > a && (.2 > t && (l[e + 0] += 1), .2 > n && (l[e + 2] += 1), .2 > r && (l[e + 4] += 1))
        }(), this.addAttribute("position", new xt(h, 3)), this.addAttribute("normal", new xt(h.slice(), 3)), this.addAttribute("uv", new xt(l, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function Bi(e, t) {
        lt.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new zi(e, t)), this.mergeVertices()
    }

    function zi(e, t) {
        Fi.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function Gi(e, t) {
        lt.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new Hi(e, t)), this.mergeVertices()
    }

    function Hi(e, t) {
        Fi.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function Vi(e, t) {
        lt.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ki(e, t)), this.mergeVertices()
    }

    function ki(e, t) {
        var i = (1 + Math.sqrt(5)) / 2;
        Fi.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function ji(e, t) {
        lt.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new Wi(e, t)), this.mergeVertices()
    }

    function Wi(e, t) {
        var i = (1 + Math.sqrt(5)) / 2,
            n = 1 / i;
        Fi.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function Xi(e, t, i, n, r, a) {
        lt.call(this), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: n,
            closed: r
        }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed."), e = new qi(e, t, i, n, r), this.tangents = e.tangents, this.normals = e.normals, this.binormals = e.binormals, this.fromBufferGeometry(e), this.mergeVertices()
    }

    function qi(e, t, n, r, a) {
        function o(i) {
            var a = e.getPointAt(i / t),
                o = s.normals[i];
            for (i = s.binormals[i], l = 0; r >= l; l++) {
                var c = l / r * Math.PI * 2,
                    h = Math.sin(c),
                    c = -Math.cos(c);
                p.x = c * o.x + h * i.x, p.y = c * o.y + h * i.y, p.z = c * o.z + h * i.z, p.normalize(), m.push(p.x, p.y, p.z), u.x = a.x + n * p.x, u.y = a.y + n * p.y, u.z = a.z + n * p.z, f.push(u.x, u.y, u.z)
            }
        }
        Mt.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: r,
            closed: a
        }, t = t || 64, n = n || 1, r = r || 8, a = a || !1;
        var s = e.computeFrenetFrames(t, a);
        this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
        var h, l, u = new c,
            p = new c,
            d = new i,
            f = [],
            m = [],
            g = [],
            v = [];
        for (h = 0; t > h; h++) o(h);
        for (o(!1 === a ? t : 0), h = 0; t >= h; h++)
            for (l = 0; r >= l; l++) d.x = h / t, d.y = l / r, g.push(d.x, d.y);
        ! function () {
            for (l = 1; t >= l; l++)
                for (h = 1; r >= h; h++) {
                    var e = (r + 1) * l + (h - 1),
                        i = (r + 1) * l + h,
                        n = (r + 1) * (l - 1) + h;
                    v.push((r + 1) * (l - 1) + (h - 1), e, n), v.push(e, i, n)
                }
        }(), this.setIndex(v), this.addAttribute("position", new xt(f, 3)), this.addAttribute("normal", new xt(m, 3)), this.addAttribute("uv", new xt(g, 2))
    }

    function Yi(e, t, i, n, r, a, o) {
        lt.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: a
        }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Zi(e, t, i, n, r, a)), this.mergeVertices()
    }

    function Zi(e, t, i, n, r, a) {
        function o(e, t, i, n, r) {
            var a = Math.sin(e);
            t = i / t * e, i = Math.cos(t), r.x = n * (2 + i) * .5 * Math.cos(e), r.y = n * (2 + i) * a * .5, r.z = n * Math.sin(t) * .5
        }
        Mt.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: a
        }, e = e || 100, t = t || 40, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, a = a || 3;
        var s, h, l = [],
            u = [],
            p = [],
            d = [],
            f = new c,
            m = new c,
            g = new c,
            v = new c,
            y = new c,
            x = new c,
            b = new c;
        for (s = 0; i >= s; ++s)
            for (h = s / i * r * Math.PI * 2, o(h, r, a, e, g), o(h + .01, r, a, e, v), x.subVectors(v, g), b.addVectors(v, g), y.crossVectors(x, b), b.crossVectors(y, x), y.normalize(), b.normalize(), h = 0; n >= h; ++h) {
                var _ = h / n * Math.PI * 2,
                    w = -t * Math.cos(_),
                    _ = t * Math.sin(_);
                f.x = g.x + (w * b.x + _ * y.x), f.y = g.y + (w * b.y + _ * y.y), f.z = g.z + (w * b.z + _ * y.z), u.push(f.x, f.y, f.z), m.subVectors(f, g).normalize(), p.push(m.x, m.y, m.z), d.push(s / i), d.push(h / n)
            }
        for (h = 1; i >= h; h++)
            for (s = 1; n >= s; s++) e = (n + 1) * h + (s - 1), t = (n + 1) * h + s, r = (n + 1) * (h - 1) + s, l.push((n + 1) * (h - 1) + (s - 1), e, r), l.push(e, t, r);
        this.setIndex(l), this.addAttribute("position", new xt(u, 3)), this.addAttribute("normal", new xt(p, 3)), this.addAttribute("uv", new xt(d, 2))
    }

    function Ji(e, t, i, n, r) {
        lt.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, this.fromBufferGeometry(new Qi(e, t, i, n, r)), this.mergeVertices()
    }

    function Qi(e, t, i, n, r) {
        Mt.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, e = e || 100, t = t || 40, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
        var a, o, s = [],
            h = [],
            l = [],
            u = [],
            p = new c,
            d = new c,
            f = new c;
        for (a = 0; i >= a; a++)
            for (o = 0; n >= o; o++) {
                var m = o / n * r,
                    g = a / i * Math.PI * 2;
                d.x = (e + t * Math.cos(g)) * Math.cos(m), d.y = (e + t * Math.cos(g)) * Math.sin(m), d.z = t * Math.sin(g), h.push(d.x, d.y, d.z), p.x = e * Math.cos(m), p.y = e * Math.sin(m), f.subVectors(d, p).normalize(), l.push(f.x, f.y, f.z), u.push(o / n), u.push(a / i)
            }
        for (a = 1; i >= a; a++)
            for (o = 1; n >= o; o++) e = (n + 1) * (a - 1) + o - 1, t = (n + 1) * (a - 1) + o, r = (n + 1) * a + o, s.push((n + 1) * a + o - 1, e, r), s.push(e, t, r);
        this.setIndex(s), this.addAttribute("position", new xt(h, 3)), this.addAttribute("normal", new xt(l, 3)), this.addAttribute("uv", new xt(u, 2))
    }

    function Ki(e, t) {
        lt.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, this.fromBufferGeometry(new $i(e, t)), this.mergeVertices()
    }

    function $i(e, t) {
        "undefined" != typeof e && (Mt.call(this), this.type = "ExtrudeBufferGeometry", e = Array.isArray(e) ? e : [e], this.addShapeList(e, t), this.computeVertexNormals())
    }

    function en(e, t) {
        lt.call(this), this.type = "TextGeometry", this.parameters = {
            text: e,
            parameters: t
        }, this.fromBufferGeometry(new tn(e, t)), this.mergeVertices()
    }

    function tn(e, t) {
        t = t || {};
        var i = t.font;
        return i && i.isFont ? (i = i.generateShapes(e, t.size, t.curveSegments), t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), $i.call(this, i, t), this.type = "TextBufferGeometry", void 0) : (console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new lt)
    }

    function nn(e, t, i, n, r, a, o) {
        lt.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: a,
            thetaLength: o
        }, this.fromBufferGeometry(new rn(e, t, i, n, r, a, o)), this.mergeVertices()
    }

    function rn(e, t, i, n, r, a, o) {
        Mt.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: a,
            thetaLength: o
        }, e = e || 50, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : Math.PI;
        var s, h, l = a + o,
            u = 0,
            p = [],
            d = new c,
            f = new c,
            m = [],
            g = [],
            v = [],
            y = [];
        for (h = 0; i >= h; h++) {
            var x = [],
                b = h / i;
            for (s = 0; t >= s; s++) {
                var _ = s / t;
                d.x = -e * Math.cos(n + _ * r) * Math.sin(a + b * o), d.y = e * Math.cos(a + b * o), d.z = e * Math.sin(n + _ * r) * Math.sin(a + b * o), g.push(d.x, d.y, d.z), f.set(d.x, d.y, d.z).normalize(), v.push(f.x, f.y, f.z), y.push(_, 1 - b), x.push(u++)
            }
            p.push(x)
        }
        for (h = 0; i > h; h++)
            for (s = 0; t > s; s++) e = p[h][s + 1], n = p[h][s], r = p[h + 1][s], o = p[h + 1][s + 1], (0 !== h || a > 0) && m.push(e, n, o), (h !== i - 1 || l < Math.PI) && m.push(n, r, o);
        this.setIndex(m), this.addAttribute("position", new xt(g, 3)), this.addAttribute("normal", new xt(v, 3)), this.addAttribute("uv", new xt(y, 2))
    }

    function an(e, t, i, n, r, a) {
        lt.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: a
        }, this.fromBufferGeometry(new on(e, t, i, n, r, a)), this.mergeVertices()
    }

    function on(e, t, n, r, a, o) {
        Mt.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: a,
            thetaLength: o
        }, e = e || 20, t = t || 50, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, r = void 0 !== r ? Math.max(1, r) : 1;
        var s, h, l = [],
            u = [],
            p = [],
            d = [],
            f = e,
            m = (t - e) / r,
            g = new c,
            v = new i;
        for (s = 0; r >= s; s++) {
            for (h = 0; n >= h; h++) e = a + h / n * o, g.x = f * Math.cos(e), g.y = f * Math.sin(e), u.push(g.x, g.y, g.z), p.push(0, 0, 1), v.x = (g.x / t + 1) / 2, v.y = (g.y / t + 1) / 2, d.push(v.x, v.y);
            f += m
        }
        for (s = 0; r > s; s++)
            for (t = s * (n + 1), h = 0; n > h; h++) e = h + t, a = e + n + 1, o = e + n + 2, f = e + 1, l.push(e, a, f), l.push(a, o, f);
        this.setIndex(l), this.addAttribute("position", new xt(u, 3)), this.addAttribute("normal", new xt(p, 3)), this.addAttribute("uv", new xt(d, 2))
    }

    function sn(e, t, i, n) {
        lt.call(this), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: n
        }, this.fromBufferGeometry(new cn(e, t, i, n)), this.mergeVertices()
    }

    function cn(e, t, n, r) {
        Mt.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: r
        }, t = Math.floor(t) || 12, n = n || 0, r = r || 2 * Math.PI, r = _a.clamp(r, 0, 2 * Math.PI);
        var a, o, s = [],
            h = [],
            l = [],
            u = 1 / t,
            p = new c,
            d = new i;
        for (a = 0; t >= a; a++) {
            o = n + a * u * r;
            var f = Math.sin(o),
                m = Math.cos(o);
            for (o = 0; o <= e.length - 1; o++) p.x = e[o].x * f, p.y = e[o].y, p.z = e[o].x * m, h.push(p.x, p.y, p.z), d.x = a / t, d.y = o / (e.length - 1), l.push(d.x, d.y)
        }
        for (a = 0; t > a; a++)
            for (o = 0; o < e.length - 1; o++) n = o + a * e.length, u = n + e.length, p = n + e.length + 1, d = n + 1, s.push(n, u, d), s.push(u, p, d);
        if (this.setIndex(s), this.addAttribute("position", new xt(h, 3)), this.addAttribute("uv", new xt(l, 2)), this.computeVertexNormals(), r === 2 * Math.PI)
            for (r = this.attributes.normal.array, s = new c, h = new c, l = new c, n = t * e.length * 3, o = a = 0; a < e.length; a++, o += 3) s.x = r[o + 0], s.y = r[o + 1], s.z = r[o + 2], h.x = r[n + o + 0], h.y = r[n + o + 1], h.z = r[n + o + 2], l.addVectors(s, h).normalize(), r[o + 0] = r[n + o + 0] = l.x, r[o + 1] = r[n + o + 1] = l.y, r[o + 2] = r[n + o + 2] = l.z
    }

    function hn(e, t) {
        lt.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
            shapes: e,
            curveSegments: t
        }, this.fromBufferGeometry(new ln(e, t)), this.mergeVertices()
    }

    function ln(e, t) {
        function i(e) {
            var i, s, h = r.length / 3;
            e = e.extractPoints(t);
            var l = e.shape,
                u = e.holes;
            if (!1 === za.isClockWise(l))
                for (l = l.reverse(), e = 0, i = u.length; i > e; e++) s = u[e], !0 === za.isClockWise(s) && (u[e] = s.reverse());
            var p = za.triangulateShape(l, u);
            for (e = 0, i = u.length; i > e; e++) s = u[e], l = l.concat(s);
            for (e = 0, i = l.length; i > e; e++) s = l[e], r.push(s.x, s.y, 0), a.push(0, 0, 1), o.push(s.x, s.y);
            for (e = 0, i = p.length; i > e; e++) l = p[e], n.push(l[0] + h, l[1] + h, l[2] + h), c += 3
        }
        Mt.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
        }, t = t || 12;
        var n = [],
            r = [],
            a = [],
            o = [],
            s = 0,
            c = 0;
        if (!1 === Array.isArray(e)) i(e);
        else
            for (var h = 0; h < e.length; h++) i(e[h]), this.addGroup(s, c, h), s += c, c = 0;
        this.setIndex(n), this.addAttribute("position", new xt(r, 3)), this.addAttribute("normal", new xt(a, 3)), this.addAttribute("uv", new xt(o, 2))
    }

    function un(e, t) {
        Mt.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: t
        };
        var i, n, r, a = [],
            o = Math.cos(_a.DEG2RAD * (void 0 !== t ? t : 1)),
            s = [0, 0],
            c = {},
            h = ["a", "b", "c"];
        e.isBufferGeometry ? (r = new lt, r.fromBufferGeometry(e)) : r = e.clone(), r.mergeVertices(), r.computeFaceNormals();
        var l = r.vertices;
        r = r.faces;
        for (var u = 0, p = r.length; p > u; u++)
            for (var d = r[u], f = 0; 3 > f; f++) i = d[h[f]], n = d[h[(f + 1) % 3]], s[0] = Math.min(i, n), s[1] = Math.max(i, n), i = s[0] + "," + s[1], void 0 === c[i] ? c[i] = {
                index1: s[0],
                index2: s[1],
                face1: u,
                face2: void 0
            } : c[i].face2 = u;
        for (i in c) s = c[i], (void 0 === s.face2 || r[s.face1].normal.dot(r[s.face2].normal) <= o) && (h = l[s.index1], a.push(h.x, h.y, h.z), h = l[s.index2], a.push(h.x, h.y, h.z));
        this.addAttribute("position", new xt(a, 3))
    }

    function pn(e, t, i, n, r, a, o, s) {
        lt.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: a,
            thetaStart: o,
            thetaLength: s
        }, this.fromBufferGeometry(new dn(e, t, i, n, r, a, o, s)), this.mergeVertices()
    }

    function dn(e, t, n, r, a, o, s, h) {
        function l(n) {
            var a, o, l, v = new i,
                b = new c,
                _ = 0,
                w = !0 === n ? e : t,
                M = !0 === n ? 1 : -1;
            for (o = g, a = 1; r >= a; a++) d.push(0, y * M, 0), f.push(0, M, 0), m.push(.5, .5), g++;
            for (l = g, a = 0; r >= a; a++) {
                var E = a / r * h + s,
                    T = Math.cos(E),
                    E = Math.sin(E);
                b.x = w * E, b.y = y * M, b.z = w * T, d.push(b.x, b.y, b.z), f.push(0, M, 0), v.x = .5 * T + .5, v.y = .5 * E * M + .5, m.push(v.x, v.y), g++
            }
            for (a = 0; r > a; a++) v = o + a, b = l + a, !0 === n ? p.push(b, b + 1, v) : p.push(b + 1, b, v), _ += 3;
            u.addGroup(x, _, !0 === n ? 1 : 2), x += _
        }
        Mt.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: r,
            heightSegments: a,
            openEnded: o,
            thetaStart: s,
            thetaLength: h
        };
        var u = this;
        e = void 0 !== e ? e : 20, t = void 0 !== t ? t : 20, n = void 0 !== n ? n : 100, r = Math.floor(r) || 8, a = Math.floor(a) || 1, o = void 0 !== o ? o : !1, s = void 0 !== s ? s : 0, h = void 0 !== h ? h : 2 * Math.PI;
        var p = [],
            d = [],
            f = [],
            m = [],
            g = 0,
            v = [],
            y = n / 2,
            x = 0;
        ! function () {
            var i, o, l = new c,
                b = new c,
                _ = 0,
                w = (t - e) / n;
            for (o = 0; a >= o; o++) {
                var M = [],
                    E = o / a,
                    T = E * (t - e) + e;
                for (i = 0; r >= i; i++) {
                    var S = i / r,
                        A = S * h + s,
                        R = Math.sin(A),
                        A = Math.cos(A);
                    b.x = T * R, b.y = -E * n + y, b.z = T * A, d.push(b.x, b.y, b.z), l.set(R, w, A).normalize(), f.push(l.x, l.y, l.z), m.push(S, 1 - E), M.push(g++)
                }
                v.push(M)
            }
            for (i = 0; r > i; i++)
                for (o = 0; a > o; o++) l = v[o + 1][i], b = v[o + 1][i + 1], w = v[o][i + 1], p.push(v[o][i], l, w), p.push(l, b, w), _ += 6;
            u.addGroup(x, _, 0), x += _
        }(), !1 === o && (e > 0 && l(!0), t > 0 && l(!1)), this.setIndex(p), this.addAttribute("position", new xt(d, 3)), this.addAttribute("normal", new xt(f, 3)), this.addAttribute("uv", new xt(m, 2))
    }

    function fn(e, t, i, n, r, a, o) {
        pn.call(this, 0, e, t, i, n, r, a, o), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: a,
            thetaLength: o
        }
    }

    function mn(e, t, i, n, r, a, o) {
        dn.call(this, 0, e, t, i, n, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: a,
            thetaLength: o
        }
    }

    function gn(e, t, i, n) {
        lt.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: n
        }, this.fromBufferGeometry(new vn(e, t, i, n)), this.mergeVertices()
    }

    function vn(e, t, n, r) {
        Mt.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: r
        }, e = e || 50, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
        var a, o, s = [],
            h = [],
            l = [],
            u = [],
            p = new c,
            d = new i;
        for (h.push(0, 0, 0), l.push(0, 0, 1), u.push(.5, .5), o = 0, a = 3; t >= o; o++, a += 3) {
            var f = n + o / t * r;
            p.x = e * Math.cos(f), p.y = e * Math.sin(f), h.push(p.x, p.y, p.z), l.push(0, 0, 1), d.x = (h[a] / e + 1) / 2, d.y = (h[a + 1] / e + 1) / 2, u.push(d.x, d.y)
        }
        for (a = 1; t >= a; a++) s.push(a, a + 1, 0);
        this.setIndex(s), this.addAttribute("position", new xt(h, 3)), this.addAttribute("normal", new xt(l, 3)), this.addAttribute("uv", new xt(u, 2))
    }

    function yn(e) {
        Y.call(this, {
            uniforms: Ia.merge([Ca.lights, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Ua.shadow_vert,
            fragmentShader: Ua.shadow_frag
        }), this.transparent = this.lights = !0, Object.defineProperties(this, {
            opacity: {
                enumerable: !0,
                get: function () {
                    return this.uniforms.opacity.value
                },
                set: function (e) {
                    this.uniforms.opacity.value = e
                }
            }
        }), this.setValues(e)
    }

    function xn(e) {
        Y.call(this, e), this.type = "RawShaderMaterial"
    }

    function bn(e) {
        q.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new k(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new k(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function _n(e) {
        bn.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(e)
    }

    function wn(e) {
        q.call(this), this.type = "MeshPhongMaterial", this.color = new k(16777215), this.specular = new k(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new k(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function Mn(e) {
        wn.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
    }

    function En(e) {
        q.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(e)
    }

    function Tn(e) {
        q.call(this), this.type = "MeshLambertMaterial", this.color = new k(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new k(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function Sn(e) {
        q.call(this), this.type = "LineDashedMaterial", this.color = new k(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.lights = !1, this.setValues(e)
    }

    function An(e, t, i) {
        var n = this,
            r = !1,
            a = 0,
            o = 0;
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (e) {
            o++, !1 === r && void 0 !== n.onStart && n.onStart(e, a, o), r = !0
        }, this.itemEnd = function (e) {
            a++, void 0 !== n.onProgress && n.onProgress(e, a, o), a === o && (r = !1, void 0 !== n.onLoad) && n.onLoad()
        }, this.itemError = function (e) {
            void 0 !== n.onError && n.onError(e)
        }
    }

    function Rn(e) {
        this.manager = void 0 !== e ? e : ka
    }

    function Ln(e) {
        this.manager = void 0 !== e ? e : ka, this._parser = null
    }

    function Pn(e) {
        this.manager = void 0 !== e ? e : ka, this._parser = null
    }

    function Cn(e) {
        this.manager = void 0 !== e ? e : ka
    }

    function In(e) {
        this.manager = void 0 !== e ? e : ka
    }

    function Un(e) {
        this.manager = void 0 !== e ? e : ka
    }

    function Nn(e, t) {
        at.call(this), this.type = "Light", this.color = new k(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
    }

    function Dn(e, t, i) {
        Nn.call(this, e, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(at.DefaultUp), this.updateMatrix(), this.groundColor = new k(t)
    }

    function On(e) {
        this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new h
    }

    function Fn() {
        On.call(this, new ct(50, 1, .5, 500))
    }

    function Bn(e, t, i, n, r, a) {
        Nn.call(this, e, t), this.type = "SpotLight", this.position.copy(at.DefaultUp), this.updateMatrix(), this.target = new at, Object.defineProperty(this, "power", {
            get: function () {
                return this.intensity * Math.PI
            },
            set: function (e) {
                this.intensity = e / Math.PI
            }
        }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Fn
    }

    function zn(e, t, i, n) {
        Nn.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function () {
                return 4 * this.intensity * Math.PI
            },
            set: function (e) {
                this.intensity = e / (4 * Math.PI)
            }
        }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new On(new ct(90, 1, .5, 500))
    }

    function Gn() {
        On.call(this, new st(-5, 5, 5, -5, .5, 500))
    }

    function Hn(e, t) {
        Nn.call(this, e, t), this.type = "DirectionalLight", this.position.copy(at.DefaultUp), this.updateMatrix(), this.target = new at, this.shadow = new Gn
    }

    function Vn(e, t) {
        Nn.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
    }

    function kn(e, t, i, n) {
        Nn.call(this, e, t), this.type = "RectAreaLight", this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
    }

    function jn(e, t, i, n) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i
    }

    function Wn(e, t, i, n) {
        jn.call(this, e, t, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
    }

    function Xn(e, t, i, n) {
        jn.call(this, e, t, i, n)
    }

    function qn(e, t, i, n) {
        jn.call(this, e, t, i, n)
    }

    function Yn(e, t, i, n) {
        if (void 0 === e) throw Error("track name is undefined");
        if (void 0 === t || 0 === t.length) throw Error("no keyframes in track named " + e);
        this.name = e, this.times = ja.convertArray(t, this.TimeBufferType), this.values = ja.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation), this.validate(), this.optimize()
    }

    function Zn(e, t, i, n) {
        Yn.call(this, e, t, i, n)
    }

    function Jn(e, t, i, n) {
        jn.call(this, e, t, i, n)
    }

    function Qn(e, t, i, n) {
        Yn.call(this, e, t, i, n)
    }

    function Kn(e, t, i, n) {
        Yn.call(this, e, t, i, n)
    }

    function $n(e, t, i, n) {
        Yn.call(this, e, t, i, n)
    }

    function er(e, t, i) {
        Yn.call(this, e, t, i)
    }

    function tr(e, t, i, n) {
        Yn.call(this, e, t, i, n)
    }

    function ir() {
        Yn.apply(this, arguments)
    }

    function nr(e, t, i) {
        this.name = e, this.tracks = i, this.duration = void 0 !== t ? t : -1, this.uuid = _a.generateUUID(), 0 > this.duration && this.resetDuration(), this.optimize()
    }

    function rr(e) {
        this.manager = void 0 !== e ? e : ka, this.textures = {}
    }

    function ar(e) {
        this.manager = void 0 !== e ? e : ka
    }

    function or() {
        this.onLoadStart = function () {}, this.onLoadProgress = function () {}, this.onLoadComplete = function () {}
    }

    function sr(e) {
        "boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = void 0 !== e ? e : ka, this.withCredentials = !1
    }

    function cr(e) {
        this.manager = void 0 !== e ? e : ka, this.texturePath = ""
    }

    function hr(e, t, i, n, r) {
        t = .5 * (n - t), r = .5 * (r - i);
        var a = e * e;
        return (2 * i - 2 * n + t + r) * e * a + (-3 * i + 3 * n - 2 * t - r) * a + t * e + i
    }

    function lr(e, t, i, n) {
        var r = 1 - e;
        return r * r * t + 2 * (1 - e) * e * i + e * e * n
    }

    function ur(e, t, i, n, r) {
        var a = 1 - e,
            o = 1 - e;
        return a * a * a * t + 3 * o * o * e * i + 3 * (1 - e) * e * e * n + e * e * e * r
    }

    function pr() {
        this.arcLengthDivisions = 200
    }

    function dr(e, t) {
        this.arcLengthDivisions = 200, this.v1 = e, this.v2 = t
    }

    function fr() {
        this.arcLengthDivisions = 200, this.curves = [], this.autoClose = !1
    }

    function mr(e, t, i, n, r, a, o, s) {
        this.arcLengthDivisions = 200, this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = o, this.aRotation = s || 0
    }

    function gr(e) {
        this.arcLengthDivisions = 200, this.points = void 0 === e ? [] : e
    }

    function vr(e, t, i, n) {
        this.arcLengthDivisions = 200, this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n
    }

    function yr(e, t, i) {
        this.arcLengthDivisions = 200, this.v0 = e, this.v1 = t, this.v2 = i
    }

    function xr(e) {
        fr.call(this), this.currentPoint = new i, e && this.fromPoints(e)
    }

    function br() {
        xr.apply(this, arguments), this.holes = []
    }

    function _r() {
        this.subPaths = [], this.currentPath = null
    }

    function wr(e) {
        this.data = e
    }

    function Mr(e) {
        this.manager = void 0 !== e ? e : ka
    }

    function Er(e) {
        this.manager = void 0 !== e ? e : ka
    }

    function Tr() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ct, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ct, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }

    function Sr(e, t, i) {
        at.call(this), this.type = "CubeCamera";
        var n = new ct(90, 1, e, t);
        n.up.set(0, -1, 0), n.lookAt(new c(1, 0, 0)), this.add(n);
        var r = new ct(90, 1, e, t);
        r.up.set(0, -1, 0), r.lookAt(new c(-1, 0, 0)), this.add(r);
        var a = new ct(90, 1, e, t);
        a.up.set(0, 0, 1), a.lookAt(new c(0, 1, 0)), this.add(a);
        var s = new ct(90, 1, e, t);
        s.up.set(0, 0, -1), s.lookAt(new c(0, -1, 0)), this.add(s);
        var h = new ct(90, 1, e, t);
        h.up.set(0, -1, 0), h.lookAt(new c(0, 0, 1)), this.add(h);
        var l = new ct(90, 1, e, t);
        l.up.set(0, -1, 0), l.lookAt(new c(0, 0, -1)), this.add(l), this.renderTarget = new o(i, i, {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        }), this.renderTarget.texture.name = "CubeCamera", this.updateCubeMap = function (e, t) {
            null === this.parent && this.updateMatrixWorld();
            var i = this.renderTarget,
                o = i.texture.generateMipmaps;
            i.texture.generateMipmaps = !1, i.activeCubeFace = 0, e.render(t, n, i), i.activeCubeFace = 1, e.render(t, r, i), i.activeCubeFace = 2, e.render(t, a, i), i.activeCubeFace = 3, e.render(t, s, i), i.activeCubeFace = 4, e.render(t, h, i), i.texture.generateMipmaps = o, i.activeCubeFace = 5, e.render(t, l, i), e.setRenderTarget(null)
        }
    }

    function Ar() {
        at.call(this), this.type = "AudioListener", this.context = Ka.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
    }

    function Rr(e) {
        at.call(this), this.type = "Audio", this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }

    function Lr(e) {
        Rr.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
    }

    function Pr(e, t) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }

    function Cr(e, t, i) {
        switch (this.binding = e, this.valueSize = i, e = Float64Array, t) {
            case "quaternion":
                t = this._slerp;
                break;
            case "string":
            case "bool":
                e = Array, t = this._select;
                break;
            default:
                t = this._lerp
        }
        this.buffer = new e(4 * i), this._mixBufferRegion = t, this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }

    function Ir(e, t, i) {
        i = i || Ur.parseTrackName(t), this._targetGroup = e, this._bindings = e.subscribe_(t, i)
    }

    function Ur(e, t, i) {
        this.path = t, this.parsedPath = i || Ur.parseTrackName(t), this.node = Ur.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
    }

    function Nr() {
        this.uuid = _a.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, i = arguments.length; t !== i; ++t) e[arguments[t].uuid] = t;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                },
                get inUse() {
                    return this.total - n.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }

    function Dr(e, t, i) {
        this._mixer = e, this._clip = t, this._localRoot = i || null, e = t.tracks, t = e.length, i = Array(t);
        for (var n = {
                endingStart: 2400,
                endingEnd: 2400
            }, r = 0; r !== t; ++r) {
            var a = e[r].createInterpolant(null);
            i[r] = a, a.settings = n
        }
        this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(t), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }

    function Or(e) {
        this._root = e, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
    }

    function Fr(e, t) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = t), this.value = e
    }

    function Br() {
        Mt.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function zr(e, t, i, n) {
        this.uuid = _a.generateUUID(), this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === n
    }

    function Gr(e, t) {
        this.uuid = _a.generateUUID(), this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.onUploadCallback = function () {}, this.version = 0
    }

    function Hr(e, t, i) {
        Gr.call(this, e, t), this.meshPerAttribute = i || 1
    }

    function Vr(e, t, i) {
        ut.call(this, e, t), this.meshPerAttribute = i || 1
    }

    function kr(e, t, i, n) {
        this.ray = new Lt(e, t), this.near = i || 0, this.far = n || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function () {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function jr(e, t) {
        return e.distance - t.distance
    }

    function Wr(e, t, i, n) {
        if (!1 !== e.visible && (e.raycast(t, i), !0 === n)) {
            e = e.children, n = 0;
            for (var r = e.length; r > n; n++) Wr(e[n], t, i, !0)
        }
    }

    function Xr(e) {
        this.autoStart = void 0 !== e ? e : !0, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
    }

    function qr(e, t, i) {
        return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== i ? i : 0, this
    }

    function Yr(e, t, i) {
        return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== i ? i : 0, this
    }

    function Zr(e, t) {
        It.call(this, e, t), this.animationsMap = {}, this.animationsList = [];
        var i = this.geometry.morphTargets.length;
        this.createAnimation("__default", 0, i - 1, i / 1), this.setAnimationWeight("__default", 1)
    }

    function Jr(e) {
        at.call(this), this.material = e, this.render = function () {}
    }

    function Qr(e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, t = 0, (i = this.object.geometry) && i.isGeometry ? t = 3 * i.faces.length : i && i.isBufferGeometry && (t = i.attributes.normal.count), i = new Mt, t = new xt(6 * t, 3), i.addAttribute("position", t), Ei.call(this, i, new wi({
            color: e,
            linewidth: n
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Kr(e) {
        at.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, e = new Mt;
        for (var t = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, n = 1; 32 > i; i++, n++) {
            var r = i / 32 * Math.PI * 2,
                a = n / 32 * Math.PI * 2;
            t.push(Math.cos(r), Math.sin(r), 1, Math.cos(a), Math.sin(a), 1)
        }
        e.addAttribute("position", new xt(t, 3)), t = new wi({
            fog: !1
        }), this.cone = new Ei(e, t), this.add(this.cone), this.update()
    }

    function $r(e) {
        var t = [];
        e && e.isBone && t.push(e);
        for (var i = 0; i < e.children.length; i++) t.push.apply(t, $r(e.children[i]));
        return t
    }

    function ea(e) {
        for (var t = $r(e), i = new Mt, n = [], r = [], a = new k(0, 0, 1), o = new k(0, 1, 0), s = 0; s < t.length; s++) {
            var c = t[s];
            c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b))
        }
        i.addAttribute("position", new xt(n, 3)), i.addAttribute("color", new xt(r, 3)), n = new wi({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), Ei.call(this, i, n), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.onBeforeRender()
    }

    function ta(e, t) {
        this.light = e, this.light.updateMatrixWorld();
        var i = new rn(t, 4, 2),
            n = new Rt({
                wireframe: !0,
                fog: !1
            });
        n.color.copy(this.light.color), It.call(this, i, n), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
    }

    function ia(e) {
        at.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, e = new wi({
            color: e.color
        });
        var t = new Mt;
        t.addAttribute("position", new ut(new Float32Array(15), 3)), this.add(new Mi(t, e)), this.update()
    }

    function na(e, t) {
        at.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
        var i = new Hi(t);
        i.rotateY(.5 * Math.PI);
        var n = new Rt({
                vertexColors: 2,
                wireframe: !0
            }),
            r = i.getAttribute("position"),
            r = new Float32Array(3 * r.count);
        i.addAttribute("color", new ut(r, 3)), this.add(new It(i, n)), this.update()
    }

    function ra(e, t, i, n) {
        e = e || 10, t = t || 10, i = new k(void 0 !== i ? i : 4473924), n = new k(void 0 !== n ? n : 8947848);
        var r = t / 2,
            a = e / t,
            o = e / 2;
        e = [];
        for (var s = [], c = 0, h = 0, l = -o; t >= c; c++, l += a) {
            e.push(-o, 0, l, o, 0, l), e.push(l, 0, -o, l, 0, o);
            var u = c === r ? i : n;
            u.toArray(s, h), h += 3, u.toArray(s, h), h += 3, u.toArray(s, h), h += 3, u.toArray(s, h), h += 3
        }
        t = new Mt, t.addAttribute("position", new xt(e, 3)), t.addAttribute("color", new xt(s, 3)), i = new wi({
            vertexColors: 2
        }), Ei.call(this, t, i)
    }

    function aa(e, t, i, n, r, a) {
        e = e || 10, t = t || 16, i = i || 8, n = n || 64, r = new k(void 0 !== r ? r : 4473924), a = new k(void 0 !== a ? a : 8947848);
        var o, s, c, h, l, u = [],
            p = [];
        for (c = 0; t >= c; c++) s = c / t * 2 * Math.PI, o = Math.sin(s) * e, s = Math.cos(s) * e, u.push(0, 0, 0), u.push(o, 0, s), l = 1 & c ? r : a, p.push(l.r, l.g, l.b), p.push(l.r, l.g, l.b);
        for (c = 0; i >= c; c++)
            for (l = 1 & c ? r : a, h = e - e / i * c, t = 0; n > t; t++) s = t / n * 2 * Math.PI, o = Math.sin(s) * h, s = Math.cos(s) * h, u.push(o, 0, s), p.push(l.r, l.g, l.b), s = (t + 1) / n * 2 * Math.PI, o = Math.sin(s) * h, s = Math.cos(s) * h, u.push(o, 0, s), p.push(l.r, l.g, l.b);
        e = new Mt, e.addAttribute("position", new xt(u, 3)), e.addAttribute("color", new xt(p, 3)), u = new wi({
            vertexColors: 2
        }), Ei.call(this, e, u)
    }

    function oa(e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, t = 0, (i = this.object.geometry) && i.isGeometry ? t = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), i = new Mt, t = new xt(6 * t, 3), i.addAttribute("position", t), Ei.call(this, i, new wi({
            color: e,
            linewidth: n
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function sa(e, t) {
        at.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, void 0 === t && (t = 1);
        var i = new Mt;
        i.addAttribute("position", new xt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
        var n = new wi({
            fog: !1
        });
        this.add(new Mi(i, n)), i = new Mt, i.addAttribute("position", new xt([0, 0, 0, 0, 0, 1], 3)), this.add(new Mi(i, n)), this.update()
    }

    function ca(e) {
        function t(e, t, n) {
            i(e, n), i(t, n)
        }

        function i(e, t) {
            a.push(0, 0, 0), o.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(a.length / 3 - 1)
        }
        var n = new Mt,
            r = new wi({
                color: 16777215,
                vertexColors: 1
            }),
            a = [],
            o = [],
            s = {},
            c = new k(16755200),
            h = new k(16711680),
            l = new k(43775),
            u = new k(16777215),
            p = new k(3355443);
        t("n1", "n2", c), t("n2", "n4", c), t("n4", "n3", c), t("n3", "n1", c), t("f1", "f2", c), t("f2", "f4", c), t("f4", "f3", c), t("f3", "f1", c), t("n1", "f1", c), t("n2", "f2", c), t("n3", "f3", c), t("n4", "f4", c), t("p", "n1", h), t("p", "n2", h), t("p", "n3", h), t("p", "n4", h), t("u1", "u2", l), t("u2", "u3", l), t("u3", "u1", l), t("c", "t", u), t("p", "c", p), t("cn1", "cn2", p), t("cn3", "cn4", p), t("cf1", "cf2", p), t("cf3", "cf4", p), n.addAttribute("position", new xt(a, 3)), n.addAttribute("color", new xt(o, 3)), Ei.call(this, n, r), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
    }

    function ha(e, t) {
        this.object = e, void 0 === t && (t = 16776960);
        var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            n = new Float32Array(24),
            r = new Mt;
        r.setIndex(new ut(i, 1)), r.addAttribute("position", new ut(n, 3)), Ei.call(this, r, new wi({
            color: t
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function la(e, t, i, n, r, a) {
        at.call(this), void 0 === n && (n = 16776960), void 0 === i && (i = 1), void 0 === r && (r = .2 * i), void 0 === a && (a = .2 * r), void 0 === $a && ($a = new Mt, $a.addAttribute("position", new xt([0, 0, 0, 0, 1, 0], 3)), eo = new dn(0, .5, 1, 5, 1), eo.translate(0, -.5, 0)), this.position.copy(t), this.line = new Mi($a, new wi({
            color: n
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new It(eo, new Rt({
            color: n
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, r, a)
    }

    function ua(e) {
        e = e || 1;
        var t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e];
        e = new Mt, e.addAttribute("position", new xt(t, 3)), e.addAttribute("color", new xt([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), t = new wi({
            vertexColors: 2
        }), Ei.call(this, e, t)
    }

    function pa() {
        var e = 0,
            t = 0,
            i = 0,
            n = 0;
        return {
            initCatmullRom: function (r, a, o, s, c) {
                r = c * (o - r), s = c * (s - a), e = a, t = r, i = -3 * a + 3 * o - 2 * r - s, n = 2 * a - 2 * o + r + s
            },
            initNonuniformCatmullRom: function (r, a, o, s, c, h, l) {
                r = ((a - r) / c - (o - r) / (c + h) + (o - a) / h) * h, s = ((o - a) / h - (s - a) / (h + l) + (s - o) / l) * h, e = a, t = r, i = -3 * a + 3 * o - 2 * r - s, n = 2 * a - 2 * o + r + s
            },
            calc: function (r) {
                var a = r * r;
                return e + t * r + i * a + n * a * r
            }
        }
    }

    function da(e) {
        this.arcLengthDivisions = 200, 2 > e.length && console.warn("THREE.CatmullRomCurve3: Points array needs at least two entries."), this.points = e || [], this.closed = !1
    }

    function fa(e, t, i, n) {
        this.arcLengthDivisions = 200, this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n
    }

    function ma(e, t, i) {
        this.arcLengthDivisions = 200, this.v0 = e, this.v1 = t, this.v2 = i
    }

    function ga(e, t) {
        this.arcLengthDivisions = 200, this.v1 = e, this.v2 = t
    }

    function va(e, t, i, n, r, a) {
        mr.call(this, e, t, i, i, n, r, a)
    }

    function ya(e) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), da.call(this, e), this.type = "catmullrom", this.closed = !0
    }

    function xa(e) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), da.call(this, e), this.type = "catmullrom"
    }

    function ba(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), da.call(this, e), this.type = "catmullrom"
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }), void 0 === Math.sign && (Math.sign = function (e) {
        return 0 > e ? -1 : e > 0 ? 1 : +e
    }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
        get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && function () {
        Object.assign = function (e) {
            if (void 0 === e || null === e) throw new TypeError("Cannot convert undefined or null to object");
            for (var t = Object(e), i = 1; i < arguments.length; i++) {
                var n = arguments[i];
                if (void 0 !== n && null !== n)
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
            }
            return t
        }
    }(), Object.assign(t.prototype, {
        addEventListener: function (e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
        },
        hasEventListener: function (e, t) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[e] && -1 !== i[e].indexOf(t)
        },
        removeEventListener: function (e, t) {
            if (void 0 !== this._listeners) {
                var i = this._listeners[e];
                if (void 0 !== i) {
                    var n = i.indexOf(t); - 1 !== n && i.splice(n, 1)
                }
            }
        },
        dispatchEvent: function (e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var t = t.slice(0), i = 0, n = t.length; n > i; i++) t[i].call(this, e)
                }
            }
        }
    });
    var _a = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function () {
            var e, t = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                i = Array(36),
                n = 0;
            return function () {
                for (var r = 0; 36 > r; r++) 8 === r || 13 === r || 18 === r || 23 === r ? i[r] = "-" : 14 === r ? i[r] = "4" : (2 >= n && (n = 33554432 + 16777216 * Math.random() | 0), e = 15 & n, n >>= 4, i[r] = t[19 === r ? 3 & e | 8 : e]);
                return i.join("")
            }
        }(),
        clamp: function (e, t, i) {
            return Math.max(t, Math.min(i, e))
        },
        euclideanModulo: function (e, t) {
            return (e % t + t) % t
        },
        mapLinear: function (e, t, i, n, r) {
            return n + (e - t) * (r - n) / (i - t)
        },
        lerp: function (e, t, i) {
            return (1 - i) * e + i * t
        },
        smoothstep: function (e, t, i) {
            return t >= e ? 0 : e >= i ? 1 : (e = (e - t) / (i - t), e * e * (3 - 2 * e))
        },
        smootherstep: function (e, t, i) {
            return t >= e ? 0 : e >= i ? 1 : (e = (e - t) / (i - t), e * e * e * (e * (6 * e - 15) + 10))
        },
        randInt: function (e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function (e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function (e) {
            return e * (.5 - Math.random())
        },
        degToRad: function (e) {
            return e * _a.DEG2RAD
        },
        radToDeg: function (e) {
            return e * _a.RAD2DEG
        },
        isPowerOfTwo: function (e) {
            return 0 === (e & e - 1) && 0 !== e
        },
        nearestPowerOfTwo: function (e) {
            return Math.pow(2, Math.round(Math.log(e) / Math.LN2))
        },
        nextPowerOfTwo: function (e) {
            return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e++, e
        }
    };
    Object.defineProperties(i.prototype, {
        width: {
            get: function () {
                return this.x
            },
            set: function (e) {
                this.x = e
            }
        },
        height: {
            get: function () {
                return this.y
            },
            set: function (e) {
                this.y = e
            }
        }
    }), Object.assign(i.prototype, {
        isVector2: !0,
        set: function (e, t) {
            return this.x = e, this.y = t, this
        },
        setScalar: function (e) {
            return this.y = this.x = e, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y)
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        },
        addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        },
        subScalar: function (e) {
            return this.x -= e, this.y -= e, this
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        },
        multiply: function (e) {
            return this.x *= e.x, this.y *= e.y, this
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this
        },
        divide: function (e) {
            return this.x /= e.x, this.y /= e.y, this
        },
        divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        },
        min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        },
        max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        },
        clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        },
        clampScalar: function () {
            var e = new i,
                t = new i;
            return function (i, n) {
                return e.set(i, i), t.set(n, n), this.clamp(e, t)
            }
        }(),
        clampLength: function (e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function () {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        angle: function () {
            var e = Math.atan2(this.y, this.x);
            return 0 > e && (e += 2 * Math.PI), e
        },
        distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function (e) {
            var t = this.x - e.x;
            return e = this.y - e.y, t * t + e * e
        },
        distanceToManhattan: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        },
        lerpVectors: function (e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
        },
        fromBufferAttribute: function (e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
        },
        rotateAround: function (e, t) {
            var i = Math.cos(t),
                n = Math.sin(t),
                r = this.x - e.x,
                a = this.y - e.y;
            return this.x = r * i - a * n + e.x, this.y = r * n + a * i + e.y, this
        }
    });
    var wa = 0;
    n.DEFAULT_IMAGE = void 0, n.DEFAULT_MAPPING = 300, Object.defineProperty(n.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(n.prototype, t.prototype, {
        constructor: n,
        isTexture: !0,
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
        },
        toJSON: function (e) {
            if (void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var i = this.image;
                if (void 0 === i.uuid && (i.uuid = _a.generateUUID()), void 0 === e.images[i.uuid]) {
                    var n, r = e.images,
                        a = i.uuid,
                        o = i.uuid;
                    void 0 !== i.toDataURL ? n = i : (n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), n.width = i.width, n.height = i.height, n.getContext("2d").drawImage(i, 0, 0, i.width, i.height)), n = 2048 < n.width || 2048 < n.height ? n.toDataURL("image/jpeg", .6) : n.toDataURL("image/png"), r[a] = {
                        uuid: o,
                        url: n
                    }
                }
                t.image = i.uuid
            }
            return e.textures[this.uuid] = t
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function (e) {
            if (300 === this.mapping) {
                if (e.multiply(this.repeat), e.add(this.offset), 0 > e.x || 1 < e.x) switch (this.wrapS) {
                    case 1e3:
                        e.x -= Math.floor(e.x);
                        break;
                    case 1001:
                        e.x = 0 > e.x ? 0 : 1;
                        break;
                    case 1002:
                        e.x = 1 === Math.abs(Math.floor(e.x) % 2) ? Math.ceil(e.x) - e.x : e.x - Math.floor(e.x)
                }
                if (0 > e.y || 1 < e.y) switch (this.wrapT) {
                    case 1e3:
                        e.y -= Math.floor(e.y);
                        break;
                    case 1001:
                        e.y = 0 > e.y ? 0 : 1;
                        break;
                    case 1002:
                        e.y = 1 === Math.abs(Math.floor(e.y) % 2) ? Math.ceil(e.y) - e.y : e.y - Math.floor(e.y)
                }
                this.flipY && (e.y = 1 - e.y)
            }
        }
    }), Object.assign(r.prototype, {
        isVector4: !0,
        set: function (e, t, i, n) {
            return this.x = e, this.y = t, this.z = i, this.w = n, this
        },
        setScalar: function (e) {
            return this.w = this.z = this.y = this.x = e, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setZ: function (e) {
            return this.z = e, this
        },
        setW: function (e) {
            return this.w = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        },
        addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        },
        subScalar: function (e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        },
        applyMatrix4: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = this.w;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n + e[12] * r, this.y = e[1] * t + e[5] * i + e[9] * n + e[13] * r, this.z = e[2] * t + e[6] * i + e[10] * n + e[14] * r, this.w = e[3] * t + e[7] * i + e[11] * n + e[15] * r, this
        },
        divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function (e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        },
        setAxisAngleFromRotationMatrix: function (e) {
            var t, i, n;
            e = e.elements;
            var r = e[0];
            n = e[4];
            var a = e[8],
                o = e[1],
                s = e[5],
                c = e[9];
            i = e[2], t = e[6];
            var h = e[10];
            return .01 > Math.abs(n - o) && .01 > Math.abs(a - i) && .01 > Math.abs(c - t) ? .1 > Math.abs(n + o) && .1 > Math.abs(a + i) && .1 > Math.abs(c + t) && .1 > Math.abs(r + s + h - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, r = (r + 1) / 2, s = (s + 1) / 2, h = (h + 1) / 2, n = (n + o) / 4, a = (a + i) / 4, c = (c + t) / 4, r > s && r > h ? .01 > r ? (t = 0, n = i = .707106781) : (t = Math.sqrt(r), i = n / t, n = a / t) : s > h ? .01 > s ? (t = .707106781, i = 0, n = .707106781) : (i = Math.sqrt(s), t = n / i, n = c / i) : .01 > h ? (i = t = .707106781, n = 0) : (n = Math.sqrt(h), t = a / n, i = c / n), this.set(t, i, n, e), this) : (e = Math.sqrt((t - c) * (t - c) + (a - i) * (a - i) + (o - n) * (o - n)), .001 > Math.abs(e) && (e = 1), this.x = (t - c) / e, this.y = (a - i) / e, this.z = (o - n) / e, this.w = Math.acos((r + s + h - 1) / 2), this)
        },
        min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        },
        max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        },
        clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        },
        clampScalar: function () {
            var e, t;
            return function (i, n) {
                return void 0 === e && (e = new r, t = new r), e.set(i, i, i, i), t.set(n, n, n, n), this.clamp(e, t)
            }
        }(),
        clampLength: function (e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function () {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        },
        lerpVectors: function (e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        },
        fromBufferAttribute: function (e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
    }), Object.assign(a.prototype, t.prototype, {
        isWebGLRenderTarget: !0,
        setSize: function (e, t) {
            (this.width !== e || this.height !== t) && (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), o.prototype = Object.create(a.prototype), o.prototype.constructor = o, o.prototype.isWebGLRenderTargetCube = !0, Object.assign(s, {
        slerp: function (e, t, i, n) {
            return i.copy(e).slerp(t, n)
        },
        slerpFlat: function (e, t, i, n, r, a, o) {
            var s = i[n + 0],
                c = i[n + 1],
                h = i[n + 2];
            i = i[n + 3], n = r[a + 0];
            var l = r[a + 1],
                u = r[a + 2];
            if (r = r[a + 3], i !== r || s !== n || c !== l || h !== u) {
                a = 1 - o;
                var p = s * n + c * l + h * u + i * r,
                    d = p >= 0 ? 1 : -1,
                    f = 1 - p * p;
                f > Number.EPSILON && (f = Math.sqrt(f), p = Math.atan2(f, p * d), a = Math.sin(a * p) / f, o = Math.sin(o * p) / f), d *= o, s = s * a + n * d, c = c * a + l * d, h = h * a + u * d, i = i * a + r * d, a === 1 - o && (o = 1 / Math.sqrt(s * s + c * c + h * h + i * i), s *= o, c *= o, h *= o, i *= o)
            }
            e[t] = s, e[t + 1] = c, e[t + 2] = h, e[t + 3] = i
        }
    }), Object.defineProperties(s.prototype, {
        x: {
            get: function () {
                return this._x
            },
            set: function (e) {
                this._x = e, this.onChangeCallback()
            }
        },
        y: {
            get: function () {
                return this._y
            },
            set: function (e) {
                this._y = e, this.onChangeCallback()
            }
        },
        z: {
            get: function () {
                return this._z
            },
            set: function (e) {
                this._z = e, this.onChangeCallback()
            }
        },
        w: {
            get: function () {
                return this._w
            },
            set: function (e) {
                this._w = e, this.onChangeCallback()
            }
        }
    }), Object.assign(s.prototype, {
        set: function (e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._w = n, this.onChangeCallback(), this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function (e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
        },
        setFromEuler: function (e, t) {
            if (!e || !e.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var i = e._x,
                n = e._y,
                r = e._z,
                a = e.order,
                o = Math.cos,
                s = Math.sin,
                c = o(i / 2),
                h = o(n / 2),
                o = o(r / 2),
                i = s(i / 2),
                n = s(n / 2),
                r = s(r / 2);
            return "XYZ" === a ? (this._x = i * h * o + c * n * r, this._y = c * n * o - i * h * r, this._z = c * h * r + i * n * o, this._w = c * h * o - i * n * r) : "YXZ" === a ? (this._x = i * h * o + c * n * r, this._y = c * n * o - i * h * r, this._z = c * h * r - i * n * o, this._w = c * h * o + i * n * r) : "ZXY" === a ? (this._x = i * h * o - c * n * r, this._y = c * n * o + i * h * r, this._z = c * h * r + i * n * o, this._w = c * h * o - i * n * r) : "ZYX" === a ? (this._x = i * h * o - c * n * r, this._y = c * n * o + i * h * r, this._z = c * h * r - i * n * o, this._w = c * h * o + i * n * r) : "YZX" === a ? (this._x = i * h * o + c * n * r, this._y = c * n * o + i * h * r, this._z = c * h * r - i * n * o, this._w = c * h * o - i * n * r) : "XZY" === a && (this._x = i * h * o - c * n * r, this._y = c * n * o - i * h * r, this._z = c * h * r + i * n * o, this._w = c * h * o + i * n * r), !1 !== t && this.onChangeCallback(), this
        },
        setFromAxisAngle: function (e, t) {
            var i = t / 2,
                n = Math.sin(i);
            return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function (e) {
            var t = e.elements,
                i = t[0];
            e = t[4];
            var n = t[8],
                r = t[1],
                a = t[5],
                o = t[9],
                s = t[2],
                c = t[6],
                t = t[10],
                h = i + a + t;
            return h > 0 ? (i = .5 / Math.sqrt(h + 1), this._w = .25 / i, this._x = (c - o) * i, this._y = (n - s) * i, this._z = (r - e) * i) : i > a && i > t ? (i = 2 * Math.sqrt(1 + i - a - t), this._w = (c - o) / i, this._x = .25 * i, this._y = (e + r) / i, this._z = (n + s) / i) : a > t ? (i = 2 * Math.sqrt(1 + a - i - t), this._w = (n - s) / i, this._x = (e + r) / i, this._y = .25 * i, this._z = (o + c) / i) : (i = 2 * Math.sqrt(1 + t - i - a), this._w = (r - e) / i, this._x = (n + s) / i, this._y = (o + c) / i, this._z = .25 * i), this.onChangeCallback(), this
        },
        setFromUnitVectors: function () {
            var e, t = new c;
            return function (i, n) {
                return void 0 === t && (t = new c), e = i.dot(n) + 1, 1e-6 > e ? (e = 0, Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, n), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize()
            }
        }(),
        inverse: function () {
            return this.conjugate().normalize()
        },
        conjugate: function () {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function (e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function () {
            var e = this.length();
            return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this.onChangeCallback(), this
        },
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function (e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function (e, t) {
            var i = e._x,
                n = e._y,
                r = e._z,
                a = e._w,
                o = t._x,
                s = t._y,
                c = t._z,
                h = t._w;
            return this._x = i * h + a * o + n * c - r * s, this._y = n * h + a * s + r * o - i * c, this._z = r * h + a * c + i * s - n * o, this._w = a * h - i * o - n * s - r * c, this.onChangeCallback(), this
        },
        slerp: function (e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var i = this._x,
                n = this._y,
                r = this._z,
                a = this._w,
                o = a * e._w + i * e._x + n * e._y + r * e._z;
            if (0 > o ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = i, this._y = n, this._z = r, this;
            var s = Math.sqrt(1 - o * o);
            if (.001 > Math.abs(s)) return this._w = .5 * (a + this._w), this._x = .5 * (i + this._x), this._y = .5 * (n + this._y), this._z = .5 * (r + this._z), this;
            var c = Math.atan2(s, o),
                o = Math.sin((1 - t) * c) / s,
                s = Math.sin(t * c) / s;
            return this._w = a * o + this._w * s, this._x = i * o + this._x * s, this._y = n * o + this._y * s, this._z = r * o + this._z * s, this.onChangeCallback(), this
        },
        equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        },
        onChange: function (e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function () {}
    }), Object.assign(c.prototype, {
        isVector3: !0,
        set: function (e, t, i) {
            return this.x = e, this.y = t, this.z = i, this
        },
        setScalar: function (e) {
            return this.z = this.y = this.x = e, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setZ: function (e) {
            return this.z = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this.z += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        },
        addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        },
        subScalar: function (e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        },
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        },
        multiplyVectors: function (e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        },
        applyEuler: function () {
            var e = new s;
            return function (t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(e.setFromEuler(t))
            }
        }(),
        applyAxisAngle: function () {
            var e = new s;
            return function (t, i) {
                return this.applyQuaternion(e.setFromAxisAngle(t, i))
            }
        }(),
        applyMatrix3: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[3] * i + e[6] * n, this.y = e[1] * t + e[4] * i + e[7] * n, this.z = e[2] * t + e[5] * i + e[8] * n, this
        },
        applyMatrix4: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            e = e.elements;
            var r = 1 / (e[3] * t + e[7] * i + e[11] * n + e[15]);
            return this.x = (e[0] * t + e[4] * i + e[8] * n + e[12]) * r, this.y = (e[1] * t + e[5] * i + e[9] * n + e[13]) * r, this.z = (e[2] * t + e[6] * i + e[10] * n + e[14]) * r, this
        },
        applyQuaternion: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = e.x,
                a = e.y,
                o = e.z;
            e = e.w;
            var s = e * t + a * n - o * i,
                c = e * i + o * t - r * n,
                h = e * n + r * i - a * t,
                t = -r * t - a * i - o * n;
            return this.x = s * e + t * -r + c * -o - h * -a, this.y = c * e + t * -a + h * -r - s * -o, this.z = h * e + t * -o + s * -a - c * -r, this
        },
        project: function () {
            var e = new h;
            return function (t) {
                return e.multiplyMatrices(t.projectionMatrix, e.getInverse(t.matrixWorld)), this.applyMatrix4(e)
            }
        }(),
        unproject: function () {
            var e = new h;
            return function (t) {
                return e.multiplyMatrices(t.matrixWorld, e.getInverse(t.projectionMatrix)), this.applyMatrix4(e)
            }
        }(),
        transformDirection: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n, this.y = e[1] * t + e[5] * i + e[9] * n, this.z = e[2] * t + e[6] * i + e[10] * n, this.normalize()
        },
        divide: function (e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        },
        divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        },
        min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        },
        max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        },
        clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        },
        clampScalar: function () {
            var e = new c,
                t = new c;
            return function (i, n) {
                return e.set(i, i, i), t.set(n, n, n), this.clamp(e, t)
            }
        }(),
        clampLength: function (e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function () {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        },
        lerpVectors: function (e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        cross: function (e, t) {
            if (void 0 !== t) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
            var i = this.x,
                n = this.y,
                r = this.z;
            return this.x = n * e.z - r * e.y, this.y = r * e.x - i * e.z, this.z = i * e.y - n * e.x, this
        },
        crossVectors: function (e, t) {
            var i = e.x,
                n = e.y,
                r = e.z,
                a = t.x,
                o = t.y,
                s = t.z;
            return this.x = n * s - r * o, this.y = r * a - i * s, this.z = i * o - n * a, this
        },
        projectOnVector: function (e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        },
        projectOnPlane: function () {
            var e = new c;
            return function (t) {
                return e.copy(this).projectOnVector(t), this.sub(e)
            }
        }(),
        reflect: function () {
            var e = new c;
            return function (t) {
                return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
            }
        }(),
        angleTo: function (e) {
            return e = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()), Math.acos(_a.clamp(e, -1, 1))
        },
        distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function (e) {
            var t = this.x - e.x,
                i = this.y - e.y;
            return e = this.z - e.z, t * t + i * i + e * e
        },
        distanceToManhattan: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function (e) {
            var t = Math.sin(e.phi) * e.radius;
            return this.x = t * Math.sin(e.theta), this.y = Math.cos(e.phi) * e.radius, this.z = t * Math.cos(e.theta), this
        },
        setFromCylindrical: function (e) {
            return this.x = e.radius * Math.sin(e.theta), this.y = e.y, this.z = e.radius * Math.cos(e.theta), this
        },
        setFromMatrixPosition: function (e) {
            return e = e.elements, this.x = e[12], this.y = e[13], this.z = e[14], this
        },
        setFromMatrixScale: function (e) {
            var t = this.setFromMatrixColumn(e, 0).length(),
                i = this.setFromMatrixColumn(e, 1).length();
            return e = this.setFromMatrixColumn(e, 2).length(), this.x = t, this.y = i, this.z = e, this
        },
        setFromMatrixColumn: function (e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        },
        fromBufferAttribute: function (e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
    }), Object.assign(h.prototype, {
        isMatrix4: !0,
        set: function (e, t, i, n, r, a, o, s, c, h, l, u, p, d, f, m) {
            var g = this.elements;
            return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = o, g[13] = s, g[2] = c, g[6] = h, g[10] = l, g[14] = u, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function () {
            return (new h).fromArray(this.elements)
        },
        copy: function (e) {
            var t = this.elements;
            return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], this
        },
        copyPosition: function (e) {
            var t = this.elements;
            return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this
        },
        extractBasis: function (e, t, i) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function (e, t, i) {
            return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function () {
            var e = new c;
            return function (t) {
                var i = this.elements,
                    n = t.elements,
                    r = 1 / e.setFromMatrixColumn(t, 0).length(),
                    a = 1 / e.setFromMatrixColumn(t, 1).length();
                return t = 1 / e.setFromMatrixColumn(t, 2).length(), i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[8] = n[8] * t, i[9] = n[9] * t, i[10] = n[10] * t, this
            }
        }(),
        makeRotationFromEuler: function (e) {
            e && e.isEuler || console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements,
                i = e.x,
                n = e.y,
                r = e.z,
                a = Math.cos(i),
                i = Math.sin(i),
                o = Math.cos(n),
                n = Math.sin(n),
                s = Math.cos(r),
                r = Math.sin(r);
            if ("XYZ" === e.order) {
                e = a * s;
                var c = a * r,
                    h = i * s,
                    l = i * r;
                t[0] = o * s, t[4] = -o * r, t[8] = n, t[1] = c + h * n, t[5] = e - l * n, t[9] = -i * o, t[2] = l - e * n, t[6] = h + c * n, t[10] = a * o
            } else "YXZ" === e.order ? (e = o * s, c = o * r, h = n * s, l = n * r, t[0] = e + l * i, t[4] = h * i - c, t[8] = a * n, t[1] = a * r, t[5] = a * s, t[9] = -i, t[2] = c * i - h, t[6] = l + e * i, t[10] = a * o) : "ZXY" === e.order ? (e = o * s, c = o * r, h = n * s, l = n * r, t[0] = e - l * i, t[4] = -a * r, t[8] = h + c * i, t[1] = c + h * i, t[5] = a * s, t[9] = l - e * i, t[2] = -a * n, t[6] = i, t[10] = a * o) : "ZYX" === e.order ? (e = a * s, c = a * r, h = i * s, l = i * r, t[0] = o * s, t[4] = h * n - c, t[8] = e * n + l, t[1] = o * r, t[5] = l * n + e, t[9] = c * n - h, t[2] = -n, t[6] = i * o, t[10] = a * o) : "YZX" === e.order ? (e = a * o, c = a * n, h = i * o, l = i * n, t[0] = o * s, t[4] = l - e * r, t[8] = h * r + c, t[1] = r, t[5] = a * s, t[9] = -i * s, t[2] = -n * s, t[6] = c * r + h, t[10] = e - l * r) : "XZY" === e.order && (e = a * o, c = a * n, h = i * o, l = i * n, t[0] = o * s, t[4] = -r, t[8] = n * s, t[1] = e * r + l, t[5] = a * s, t[9] = c * r - h, t[2] = h * r - c, t[6] = i * s, t[10] = l * r + e);
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        makeRotationFromQuaternion: function (e) {
            var t = this.elements,
                i = e._x,
                n = e._y,
                r = e._z,
                a = e._w,
                o = i + i,
                s = n + n,
                c = r + r;
            e = i * o;
            var h = i * s,
                i = i * c,
                l = n * s,
                n = n * c,
                r = r * c,
                o = a * o,
                s = a * s,
                a = a * c;
            return t[0] = 1 - (l + r), t[4] = h - a, t[8] = i + s, t[1] = h + a, t[5] = 1 - (e + r), t[9] = n - o, t[2] = i - s, t[6] = n + o, t[10] = 1 - (e + l), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        lookAt: function () {
            var e = new c,
                t = new c,
                i = new c;
            return function (n, r, a) {
                var o = this.elements;
                return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), e.crossVectors(a, i), 0 === e.lengthSq() && (1 === Math.abs(a.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), e.crossVectors(a, i)), e.normalize(), t.crossVectors(i, e), o[0] = e.x, o[4] = t.x, o[8] = i.x, o[1] = e.y, o[5] = t.y, o[9] = i.y, o[2] = e.z, o[6] = t.z, o[10] = i.z, this
            }
        }(),
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function (e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function (e, t) {
            var i = e.elements,
                n = t.elements,
                r = this.elements,
                a = i[0],
                o = i[4],
                s = i[8],
                c = i[12],
                h = i[1],
                l = i[5],
                u = i[9],
                p = i[13],
                d = i[2],
                f = i[6],
                m = i[10],
                g = i[14],
                v = i[3],
                y = i[7],
                x = i[11],
                i = i[15],
                b = n[0],
                _ = n[4],
                w = n[8],
                M = n[12],
                E = n[1],
                T = n[5],
                S = n[9],
                A = n[13],
                R = n[2],
                L = n[6],
                P = n[10],
                C = n[14],
                I = n[3],
                U = n[7],
                N = n[11],
                n = n[15];
            return r[0] = a * b + o * E + s * R + c * I, r[4] = a * _ + o * T + s * L + c * U, r[8] = a * w + o * S + s * P + c * N, r[12] = a * M + o * A + s * C + c * n, r[1] = h * b + l * E + u * R + p * I, r[5] = h * _ + l * T + u * L + p * U, r[9] = h * w + l * S + u * P + p * N, r[13] = h * M + l * A + u * C + p * n, r[2] = d * b + f * E + m * R + g * I, r[6] = d * _ + f * T + m * L + g * U, r[10] = d * w + f * S + m * P + g * N, r[14] = d * M + f * A + m * C + g * n, r[3] = v * b + y * E + x * R + i * I, r[7] = v * _ + y * T + x * L + i * U, r[11] = v * w + y * S + x * P + i * N, r[15] = v * M + y * A + x * C + i * n, this
        },
        multiplyScalar: function (e) {
            var t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        },
        applyToBufferAttribute: function () {
            var e = new c;
            return function (t) {
                for (var i = 0, n = t.count; n > i; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix4(this), t.setXYZ(i, e.x, e.y, e.z);
                return t
            }
        }(),
        determinant: function () {
            var e = this.elements,
                t = e[0],
                i = e[4],
                n = e[8],
                r = e[12],
                a = e[1],
                o = e[5],
                s = e[9],
                c = e[13],
                h = e[2],
                l = e[6],
                u = e[10],
                p = e[14];
            return e[3] * (+r * s * l - n * c * l - r * o * u + i * c * u + n * o * p - i * s * p) + e[7] * (+t * s * p - t * c * u + r * a * u - n * a * p + n * c * h - r * s * h) + e[11] * (+t * c * l - t * o * p - r * a * l + i * a * p + r * o * h - i * c * h) + e[15] * (-n * o * h - t * s * l + t * o * u + n * a * l - i * a * u + i * s * h)
        },
        transpose: function () {
            var e, t = this.elements;
            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
        },
        setPosition: function (e) {
            var t = this.elements;
            return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
        },
        getInverse: function (e, t) {
            var i = this.elements,
                n = e.elements,
                r = n[0],
                a = n[1],
                o = n[2],
                s = n[3],
                c = n[4],
                h = n[5],
                l = n[6],
                u = n[7],
                p = n[8],
                d = n[9],
                f = n[10],
                m = n[11],
                g = n[12],
                v = n[13],
                y = n[14],
                n = n[15],
                x = d * y * u - v * f * u + v * l * m - h * y * m - d * l * n + h * f * n,
                b = g * f * u - p * y * u - g * l * m + c * y * m + p * l * n - c * f * n,
                _ = p * v * u - g * d * u + g * h * m - c * v * m - p * h * n + c * d * n,
                w = g * d * l - p * v * l - g * h * f + c * v * f + p * h * y - c * d * y,
                M = r * x + a * b + o * _ + s * w;
            if (0 === M) {
                if (!0 === t) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity()
            }
            return M = 1 / M, i[0] = x * M, i[1] = (v * f * s - d * y * s - v * o * m + a * y * m + d * o * n - a * f * n) * M, i[2] = (h * y * s - v * l * s + v * o * u - a * y * u - h * o * n + a * l * n) * M, i[3] = (d * l * s - h * f * s - d * o * u + a * f * u + h * o * m - a * l * m) * M, i[4] = b * M, i[5] = (p * y * s - g * f * s + g * o * m - r * y * m - p * o * n + r * f * n) * M, i[6] = (g * l * s - c * y * s - g * o * u + r * y * u + c * o * n - r * l * n) * M, i[7] = (c * f * s - p * l * s + p * o * u - r * f * u - c * o * m + r * l * m) * M, i[8] = _ * M, i[9] = (g * d * s - p * v * s - g * a * m + r * v * m + p * a * n - r * d * n) * M, i[10] = (c * v * s - g * h * s + g * a * u - r * v * u - c * a * n + r * h * n) * M, i[11] = (p * h * s - c * d * s - p * a * u + r * d * u + c * a * m - r * h * m) * M, i[12] = w * M, i[13] = (p * v * o - g * d * o + g * a * f - r * v * f - p * a * y + r * d * y) * M, i[14] = (g * h * o - c * v * o - g * a * l + r * v * l + c * a * y - r * h * y) * M, i[15] = (c * d * o - p * h * o + p * a * l - r * d * l - c * a * f + r * h * f) * M, this
        },
        scale: function (e) {
            var t = this.elements,
                i = e.x,
                n = e.y;
            return e = e.z, t[0] *= i, t[4] *= n, t[8] *= e, t[1] *= i, t[5] *= n, t[9] *= e, t[2] *= i, t[6] *= n, t[10] *= e, t[3] *= i, t[7] *= n, t[11] *= e, this
        },
        getMaxScaleOnAxis: function () {
            var e = this.elements;
            return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10]))
        },
        makeTranslation: function (e, t, i) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
        },
        makeRotationX: function (e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function (e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function (e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function (e, t) {
            var i = Math.cos(t),
                n = Math.sin(t),
                r = 1 - i,
                a = e.x,
                o = e.y,
                s = e.z,
                c = r * a,
                h = r * o;
            return this.set(c * a + i, c * o - n * s, c * s + n * o, 0, c * o + n * s, h * o + i, h * s - n * a, 0, c * s - n * o, h * s + n * a, r * s * s + i, 0, 0, 0, 0, 1), this
        },
        makeScale: function (e, t, i) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        },
        makeShear: function (e, t, i) {
            return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1), this
        },
        compose: function (e, t, i) {
            return this.makeRotationFromQuaternion(t), this.scale(i), this.setPosition(e), this
        },
        decompose: function () {
            var e = new c,
                t = new h;
            return function (i, n, r) {
                var a = this.elements,
                    o = e.set(a[0], a[1], a[2]).length(),
                    s = e.set(a[4], a[5], a[6]).length(),
                    c = e.set(a[8], a[9], a[10]).length();
                0 > this.determinant() && (o = -o), i.x = a[12], i.y = a[13], i.z = a[14], t.copy(this), i = 1 / o;
                var a = 1 / s,
                    h = 1 / c;
                return t.elements[0] *= i, t.elements[1] *= i, t.elements[2] *= i, t.elements[4] *= a, t.elements[5] *= a, t.elements[6] *= a, t.elements[8] *= h, t.elements[9] *= h, t.elements[10] *= h, n.setFromRotationMatrix(t), r.x = o, r.y = s, r.z = c, this
            }
        }(),
        makePerspective: function (e, t, i, n, r, a) {
            void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var o = this.elements;
            return o[0] = 2 * r / (t - e), o[4] = 0, o[8] = (t + e) / (t - e), o[12] = 0, o[1] = 0, o[5] = 2 * r / (i - n), o[9] = (i + n) / (i - n), o[13] = 0, o[2] = 0, o[6] = 0, o[10] = -(a + r) / (a - r), o[14] = -2 * a * r / (a - r), o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
        },
        makeOrthographic: function (e, t, i, n, r, a) {
            var o = this.elements,
                s = 1 / (t - e),
                c = 1 / (i - n),
                h = 1 / (a - r);
            return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -((t + e) * s), o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -((i + n) * c), o[2] = 0, o[6] = 0, o[10] = -2 * h, o[14] = -((a + r) * h), o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
        },
        equals: function (e) {
            var t = this.elements;
            e = e.elements;
            for (var i = 0; 16 > i; i++)
                if (t[i] !== e[i]) return !1;
            return !0
        },
        fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; 16 > i; i++) this.elements[i] = e[i + t];
            return this
        },
        toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
        }
    }), l.prototype = Object.create(n.prototype), l.prototype.constructor = l, l.prototype.isDataTexture = !0, u.prototype = Object.create(n.prototype), u.prototype.constructor = u, u.prototype.isCubeTexture = !0, Object.defineProperty(u.prototype, "images", {
        get: function () {
            return this.image
        },
        set: function (e) {
            this.image = e
        }
    });
    var Ma = new n,
        Ea = new u,
        Ta = [],
        Sa = [],
        Aa = new Float32Array(16),
        Ra = new Float32Array(9);
    H.prototype.setValue = function (e, t) {
        for (var i = this.seq, n = 0, r = i.length; n !== r; ++n) {
            var a = i[n];
            a.setValue(e, t[a.id])
        }
    };
    var La = /([\w\d_]+)(\])?(\[|\.)?/g;
    V.prototype.setValue = function (e, t, i) {
        t = this.map[t], void 0 !== t && t.setValue(e, i, this.renderer)
    }, V.prototype.setOptional = function (e, t, i) {
        t = t[i], void 0 !== t && this.setValue(e, i, t)
    }, V.upload = function (e, t, i, n) {
        for (var r = 0, a = t.length; r !== a; ++r) {
            var o = t[r],
                s = i[o.id];
            !1 !== s.needsUpdate && o.setValue(e, s.value, n)
        }
    }, V.seqWithValue = function (e, t) {
        for (var i = [], n = 0, r = e.length; n !== r; ++n) {
            var a = e[n];
            a.id in t && i.push(a)
        }
        return i
    };
    var Pa = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    Object.assign(k.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function (e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        },
        setScalar: function (e) {
            return this.b = this.g = this.r = e, this
        },
        setHex: function (e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        },
        setRGB: function (e, t, i) {
            return this.r = e, this.g = t, this.b = i, this
        },
        setHSL: function () {
            function e(e, t, i) {
                return 0 > i && (i += 1), i > 1 && --i, 1 / 6 > i ? e + 6 * (t - e) * i : .5 > i ? t : 2 / 3 > i ? e + 6 * (t - e) * (2 / 3 - i) : e
            }
            return function (t, i, n) {
                return t = _a.euclideanModulo(t, 1), i = _a.clamp(i, 0, 1), n = _a.clamp(n, 0, 1), 0 === i ? this.r = this.g = this.b = n : (i = .5 >= n ? n * (1 + i) : n + i - n * i, n = 2 * n - i, this.r = e(n, i, t + 1 / 3), this.g = e(n, i, t), this.b = e(n, i, t - 1 / 3)), this
            }
        }(),
        setStyle: function (e) {
            function t(t) {
                void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var n = i[2];
                switch (i[1]) {
                    case "rgb":
                    case "rgba":
                        if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[5]), this;
                        if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) {
                            var n = parseFloat(i[1]) / 360,
                                r = parseInt(i[2], 10) / 100,
                                a = parseInt(i[3], 10) / 100;
                            return t(i[5]), this.setHSL(n, r, a)
                        }
                }
            } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                if (i = i[1], n = i.length, 3 === n) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
                if (6 === n) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this
            }
            return e && 0 < e.length && (i = Pa[e], void 0 !== i ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + e)), this
        },
        clone: function () {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function (e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        },
        copyGammaToLinear: function (e, t) {
            return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        copyLinearToGamma: function (e, t) {
            void 0 === t && (t = 2);
            var i = t > 0 ? 1 / t : 1;
            return this.r = Math.pow(e.r, i), this.g = Math.pow(e.g, i), this.b = Math.pow(e.b, i), this
        },
        convertGammaToLinear: function () {
            var e = this.r,
                t = this.g,
                i = this.b;
            return this.r = e * e, this.g = t * t, this.b = i * i, this
        },
        convertLinearToGamma: function () {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
        },
        getHex: function () {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function (e) {
            e = e || {
                h: 0,
                s: 0,
                l: 0
            };
            var t, i = this.r,
                n = this.g,
                r = this.b,
                a = Math.max(i, n, r),
                o = Math.min(i, n, r),
                s = (o + a) / 2;
            if (o === a) o = t = 0;
            else {
                var c = a - o,
                    o = .5 >= s ? c / (a + o) : c / (2 - a - o);
                switch (a) {
                    case i:
                        t = (n - r) / c + (r > n ? 6 : 0);
                        break;
                    case n:
                        t = (r - i) / c + 2;
                        break;
                    case r:
                        t = (i - n) / c + 4
                }
                t /= 6
            }
            return e.h = t, e.s = o, e.l = s, e
        },
        getStyle: function () {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function (e, t, i) {
            var n = this.getHSL();
            return n.h += e, n.s += t, n.l += i, this.setHSL(n.h, n.s, n.l), this
        },
        add: function (e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        },
        addColors: function (e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        },
        addScalar: function (e) {
            return this.r += e, this.g += e, this.b += e, this
        },
        sub: function (e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        },
        multiply: function (e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        },
        multiplyScalar: function (e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        },
        lerp: function (e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        },
        equals: function (e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        },
        toJSON: function () {
            return this.getHex()
        }
    });
    var Ca = {
            common: {
                diffuse: {
                    value: new k(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                offsetRepeat: {
                    value: new r(0, 0, 1, 1)
                },
                specularMap: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new i(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new k(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new k(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                offsetRepeat: {
                    value: new r(0, 0, 1, 1)
                }
            }
        },
        Ia = {
            merge: function (e) {
                for (var t = {}, i = 0; i < e.length; i++) {
                    var n, r = this.clone(e[i]);
                    for (n in r) t[n] = r[n]
                }
                return t
            },
            clone: function (e) {
                var t, i = {};
                for (t in e) {
                    i[t] = {};
                    for (var n in e[t]) {
                        var r = e[t][n];
                        i[t][n] = r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? r.clone() : Array.isArray(r) ? r.slice() : r
                    }
                }
                return i
            }
        },
        Ua = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n",
            alphatest_fragment: "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
            aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
            begin_vertex: "\nvec3 transformed = vec3( position );\n",
            beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
            bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		return distanceFalloff * maxDistanceCutoffFactor;\n#else\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n	}\n	return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE  = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS  = 0.5 / LUT_SIZE;\n	float theta = acos( dot( N, V ) );\n	vec2 uv = vec2(\n		sqrt( saturate( roughness ) ),\n		saturate( theta / ( 0.5 * PI ) ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n	float b = 3.45068 + (4.18814 + y) * y;\n	float v = a / b;\n	float theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	vec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n	return result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n		vec4 plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n		\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n			vec4 plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	\n	#endif\n#endif\n",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	varying vec3 vViewPosition;\n#endif\n",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	vViewPosition = - mvPosition.xyz;\n#endif\n",
            color_fragment: "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n",
            color_pars_vertex: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n	mat3 tmp;\n	tmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n	tmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n	tmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n	return tmp;\n}\n",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif\n",
            defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n",
            encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.x, max( value.g, value.b ) );\n	float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M            = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.x, max( value.g, value.b ) );\n	float D      = max( maxRange / maxRGB, 1.0 );\n	D            = min( floor( D ) / 255.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n	Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract(Le);\n	vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n	return vec4( max(vRGB, 0.0), 1.0 );\n}\n",
            envmap_fragment: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = asin( flipNormal * reflectVec.y ) * RECIPROCAL_PI + 0.5;\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif\n",
            envmap_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n",
            fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
            fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
            fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif\n",
            gradientmap_pars_fragment: "#ifdef TOON\n	uniform sampler2D gradientMap;\n	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n		float dotNL = dot( normal, lightDirection );\n		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n		#ifdef USE_GRADIENTMAP\n			return texture2D( gradientMap, coord ).rgb;\n		#else\n			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n		#endif\n	}\n#endif\n",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n",
            lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltcMat;	uniform sampler2D ltcMag;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifdef TOON\n		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#else\n		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n		vec3 irradiance = dotNL * directLight.color;\n	#endif\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		float norm = texture2D( ltcMag, uv ).a;\n		vec4 t = texture2D( ltcMat, uv );\n		mat3 mInv = mat3(\n			vec3(   1,   0, t.y ),\n			vec3(   0, t.z,   0 ),\n			vec3( t.w,   0, t.x )\n		);\n		reflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifndef STANDARD\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifndef STANDARD\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		float dotNL = dotNV;\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
            lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n		irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	#ifndef STANDARD\n		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n	#else\n		vec3 clearCoatRadiance = vec3( 0.0 );\n	#endif\n	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
            logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n",
            map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n",
            map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n",
            map_particle_fragment: "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
            map_particle_pars_fragment: "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif\n",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n",
            normal_flip: "#ifdef DOUBLE_SIDED\n	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n	float flipNormal = 1.0;\n#endif\n",
            normal_fragment: "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
            project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
            dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
            dithering_pars_fragment: "#if defined( DITHERING )\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif\n",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif\n",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n",
            shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n",
            skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n",
            skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
            skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
            tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	gl_FragColor.a *= opacity;\n}\n",
            cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n",
            depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}\n",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n",
            distanceRGBA_frag: "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
            distanceRGBA_vert: "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition;\n}\n",
            equirect_frag: "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
            equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}\n",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}\n",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}\n",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n",
            shadow_frag: "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n",
            shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n"
        },
        Na = {
            basic: {
                uniforms: Ia.merge([Ca.common, Ca.aomap, Ca.lightmap, Ca.fog]),
                vertexShader: Ua.meshbasic_vert,
                fragmentShader: Ua.meshbasic_frag
            },
            lambert: {
                uniforms: Ia.merge([Ca.common, Ca.aomap, Ca.lightmap, Ca.emissivemap, Ca.fog, Ca.lights, {
                    emissive: {
                        value: new k(0)
                    }
                }]),
                vertexShader: Ua.meshlambert_vert,
                fragmentShader: Ua.meshlambert_frag
            },
            phong: {
                uniforms: Ia.merge([Ca.common, Ca.aomap, Ca.lightmap, Ca.emissivemap, Ca.bumpmap, Ca.normalmap, Ca.displacementmap, Ca.gradientmap, Ca.fog, Ca.lights, {
                    emissive: {
                        value: new k(0)
                    },
                    specular: {
                        value: new k(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Ua.meshphong_vert,
                fragmentShader: Ua.meshphong_frag
            },
            standard: {
                uniforms: Ia.merge([Ca.common, Ca.aomap, Ca.lightmap, Ca.emissivemap, Ca.bumpmap, Ca.normalmap, Ca.displacementmap, Ca.roughnessmap, Ca.metalnessmap, Ca.fog, Ca.lights, {
                    emissive: {
                        value: new k(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Ua.meshphysical_vert,
                fragmentShader: Ua.meshphysical_frag
            },
            points: {
                uniforms: Ia.merge([Ca.points, Ca.fog]),
                vertexShader: Ua.points_vert,
                fragmentShader: Ua.points_frag
            },
            dashed: {
                uniforms: Ia.merge([Ca.common, Ca.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: Ua.linedashed_vert,
                fragmentShader: Ua.linedashed_frag
            },
            depth: {
                uniforms: Ia.merge([Ca.common, Ca.displacementmap]),
                vertexShader: Ua.depth_vert,
                fragmentShader: Ua.depth_frag
            },
            normal: {
                uniforms: Ia.merge([Ca.common, Ca.bumpmap, Ca.normalmap, Ca.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ua.normal_vert,
                fragmentShader: Ua.normal_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: Ua.cube_vert,
                fragmentShader: Ua.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    }
                },
                vertexShader: Ua.equirect_vert,
                fragmentShader: Ua.equirect_frag
            },
            distanceRGBA: {
                uniforms: {
                    lightPos: {
                        value: new c
                    }
                },
                vertexShader: Ua.distanceRGBA_vert,
                fragmentShader: Ua.distanceRGBA_frag
            }
        };
    Na.physical = {
        uniforms: Ia.merge([Na.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: Ua.meshphysical_vert,
        fragmentShader: Ua.meshphysical_frag
    }, Object.assign(j.prototype, {
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromPoints: function (e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; i > t; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function () {
            var e = new i;
            return function (t, i) {
                var n = e.copy(i).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
        }(),
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function (e) {
            return e = e || new i, this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function (e) {
            return e = e || new i, this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function (e) {
            return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y ? !1 : !0
        },
        containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function (e, t) {
            return (t || new i).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function (e) {
            return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y ? !1 : !0
        },
        clampPoint: function (e, t) {
            return (t || new i).copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function () {
            var e = new i;
            return function (t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        translate: function (e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    });
    var Da = 0;
    Object.assign(q.prototype, t.prototype, {
        isMaterial: !0,
        onBeforeCompile: function () {},
        setValues: function (e) {
            if (void 0 !== e)
                for (var t in e) {
                    var i = e[t];
                    if (void 0 === i) console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    else {
                        var n = this[t];
                        void 0 === n ? console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = "overdraw" === t ? Number(i) : i
                    }
                }
        },
        toJSON: function (e) {
            function t(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    delete n.metadata, i.push(n)
                }
                return i
            }
            var i = void 0 === e;
            i && (e = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 2 !== this.shading && (n.shading = this.shading), 0 !== this.side && (n.side = this.side), 0 !== this.vertexColors && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), n.skinning = this.skinning, n.morphTargets = this.morphTargets, n.dithering = this.dithering, i && (i = t(e.textures), e = t(e.images), 0 < i.length && (n.textures = i), 0 < e.length && (n.images = e)), n
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.shading = e.shading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.overdraw = e.overdraw, this.visible = e.visible, this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection, e = e.clippingPlanes;
            var t = null;
            if (null !== e)
                for (var i = e.length, t = Array(i), n = 0; n !== i; ++n) t[n] = e[n].clone();
            return this.clippingPlanes = t, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Y.prototype = Object.create(q.prototype), Y.prototype.constructor = Y, Y.prototype.isShaderMaterial = !0, Y.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ia.clone(e.uniforms), this.defines = e.defines, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
    }, Y.prototype.toJSON = function (e) {
        return e = q.prototype.toJSON.call(this, e), e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
    }, Z.prototype = Object.create(q.prototype), Z.prototype.constructor = Z, Z.prototype.isMeshDepthMaterial = !0, Z.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }, Object.assign(J.prototype, {
        isBox3: !0,
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromArray: function (e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = e.length; c > s; s += 3) {
                var h = e[s],
                    l = e[s + 1],
                    u = e[s + 2];
                t > h && (t = h), i > l && (i = l), n > u && (n = u), h > r && (r = h), l > a && (a = l), u > o && (o = u)
            }
            return this.min.set(t, i, n), this.max.set(r, a, o), this
        },
        setFromBufferAttribute: function (e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = e.count; c > s; s++) {
                var h = e.getX(s),
                    l = e.getY(s),
                    u = e.getZ(s);
                t > h && (t = h), i > l && (i = l), n > u && (n = u), h > r && (r = h), l > a && (a = l), u > o && (o = u)
            }
            return this.min.set(t, i, n), this.max.set(r, a, o), this
        },
        setFromPoints: function (e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; i > t; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function () {
            var e = new c;
            return function (t, i) {
                var n = e.copy(i).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
        }(),
        setFromObject: function (e) {
            return this.makeEmpty(), this.expandByObject(e)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function (e) {
            return e = e || new c, this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function (e) {
            return e = e || new c, this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        expandByObject: function () {
            var e = new c;
            return function (t) {
                var i = this;
                return t.updateMatrixWorld(!0), t.traverse(function (t) {
                    var n, r;
                    if (n = t.geometry, void 0 !== n)
                        if (n.isGeometry) {
                            var a = n.vertices;
                            for (n = 0, r = a.length; r > n; n++) e.copy(a[n]), e.applyMatrix4(t.matrixWorld), i.expandByPoint(e)
                        } else if (n.isBufferGeometry && (a = n.attributes.position, void 0 !== a))
                        for (n = 0, r = a.count; r > n; n++) e.fromBufferAttribute(a, n).applyMatrix4(t.matrixWorld), i.expandByPoint(e)
                }), this
            }
        }(),
        containsPoint: function (e) {
            return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z ? !1 : !0
        },
        containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function (e, t) {
            return (t || new c).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function (e) {
            return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z ? !1 : !0
        },
        intersectsSphere: function () {
            var e = new c;
            return function (t) {
                return this.clampPoint(t.center, e), e.distanceToSquared(t.center) <= t.radius * t.radius
            }
        }(),
        intersectsPlane: function (e) {
            var t, i;
            return 0 < e.normal.x ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), 0 < e.normal.y ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= e.constant && i >= e.constant
        },
        clampPoint: function (e, t) {
            return (t || new c).copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function () {
            var e = new c;
            return function (t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        getBoundingSphere: function () {
            var e = new c;
            return function (t) {
                return t = t || new Q, this.getCenter(t.center), t.radius = .5 * this.getSize(e).length(), t
            }
        }(),
        intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        applyMatrix4: function () {
            var e = [new c, new c, new c, new c, new c, new c, new c, new c];
            return function (t) {
                return this.isEmpty() ? this : (e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(e), this)
            }
        }(),
        translate: function (e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }), Object.assign(Q.prototype, {
        set: function (e, t) {
            return this.center.copy(e), this.radius = t, this
        },
        setFromPoints: function () {
            var e = new J;
            return function (t, i) {
                var n = this.center;
                void 0 !== i ? n.copy(i) : e.setFromPoints(t).getCenter(n);
                for (var r = 0, a = 0, o = t.length; o > a; a++) r = Math.max(r, n.distanceToSquared(t[a]));
                return this.radius = Math.sqrt(r), this
            }
        }(),
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        },
        empty: function () {
            return 0 >= this.radius
        },
        containsPoint: function (e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function (e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function (e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function (e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function (e) {
            return Math.abs(this.center.dot(e.normal) - e.constant) <= this.radius
        },
        clampPoint: function (e, t) {
            var i = this.center.distanceToSquared(e),
                n = t || new c;
            return n.copy(e), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n
        },
        getBoundingBox: function (e) {
            return e = e || new J, e.set(this.center, this.center), e.expandByScalar(this.radius), e
        },
        applyMatrix4: function (e) {
            return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this
        },
        translate: function (e) {
            return this.center.add(e), this
        },
        equals: function (e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }), Object.assign(K.prototype, {
        isMatrix3: !0,
        set: function (e, t, i, n, r, a, o, s, c) {
            var h = this.elements;
            return h[0] = e, h[1] = n, h[2] = o, h[3] = t, h[4] = r, h[5] = s, h[6] = i, h[7] = a, h[8] = c, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function () {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function (e) {
            var t = this.elements;
            return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], this
        },
        setFromMatrix4: function (e) {
            return e = e.elements, this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        },
        applyToBufferAttribute: function () {
            var e = new c;
            return function (t) {
                for (var i = 0, n = t.count; n > i; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix3(this), t.setXYZ(i, e.x, e.y, e.z);
                return t
            }
        }(),
        multiply: function (e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function (e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function (e, t) {
            var i = e.elements,
                n = t.elements,
                r = this.elements,
                a = i[0],
                o = i[3],
                s = i[6],
                c = i[1],
                h = i[4],
                l = i[7],
                u = i[2],
                p = i[5],
                i = i[8],
                d = n[0],
                f = n[3],
                m = n[6],
                g = n[1],
                v = n[4],
                y = n[7],
                x = n[2],
                b = n[5],
                n = n[8];
            return r[0] = a * d + o * g + s * x, r[3] = a * f + o * v + s * b, r[6] = a * m + o * y + s * n, r[1] = c * d + h * g + l * x, r[4] = c * f + h * v + l * b, r[7] = c * m + h * y + l * n, r[2] = u * d + p * g + i * x, r[5] = u * f + p * v + i * b, r[8] = u * m + p * y + i * n, this
        },
        multiplyScalar: function (e) {
            var t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        },
        determinant: function () {
            var e = this.elements,
                t = e[0],
                i = e[1],
                n = e[2],
                r = e[3],
                a = e[4],
                o = e[5],
                s = e[6],
                c = e[7],
                e = e[8];
            return t * a * e - t * o * c - i * r * e + i * o * s + n * r * c - n * a * s
        },
        getInverse: function (e, t) {
            e && e.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
            var i = e.elements,
                n = this.elements,
                r = i[0],
                a = i[1],
                o = i[2],
                s = i[3],
                c = i[4],
                h = i[5],
                l = i[6],
                u = i[7],
                i = i[8],
                p = i * c - h * u,
                d = h * l - i * s,
                f = u * s - c * l,
                m = r * p + a * d + o * f;
            if (0 === m) {
                if (!0 === t) throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity()
            }
            return m = 1 / m, n[0] = p * m, n[1] = (o * u - i * a) * m, n[2] = (h * a - o * c) * m, n[3] = d * m, n[4] = (i * r - o * l) * m, n[5] = (o * s - h * r) * m, n[6] = f * m, n[7] = (a * l - u * r) * m, n[8] = (c * r - a * s) * m, this
        },
        transpose: function () {
            var e, t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        },
        getNormalMatrix: function (e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function (e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        },
        equals: function (e) {
            var t = this.elements;
            e = e.elements;
            for (var i = 0; 9 > i; i++)
                if (t[i] !== e[i]) return !1;
            return !0
        },
        fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; 9 > i; i++) this.elements[i] = e[i + t];
            return this
        },
        toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
        }
    }), Object.assign($.prototype, {
        set: function (e, t) {
            return this.normal.copy(e), this.constant = t, this
        },
        setComponents: function (e, t, i, n) {
            return this.normal.set(e, t, i), this.constant = n, this
        },
        setFromNormalAndCoplanarPoint: function (e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        },
        setFromCoplanarPoints: function () {
            var e = new c,
                t = new c;
            return function (i, n, r) {
                return n = e.subVectors(r, n).cross(t.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this
            }
        }(),
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        },
        normalize: function () {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        },
        negate: function () {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function (e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function (e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function (e, t) {
            return this.orthoPoint(e, t).sub(e).negate()
        },
        orthoPoint: function (e, t) {
            var i = this.distanceToPoint(e);
            return (t || new c).copy(this.normal).multiplyScalar(i)
        },
        intersectLine: function () {
            var e = new c;
            return function (t, i) {
                var n = i || new c,
                    r = t.delta(e),
                    a = this.normal.dot(r);
                return 0 !== a ? (a = -(t.start.dot(this.normal) + this.constant) / a, 0 > a || a > 1 ? void 0 : n.copy(r).multiplyScalar(a).add(t.start)) : 0 === this.distanceToPoint(t.start) ? n.copy(t.start) : void 0
            }
        }(),
        intersectsLine: function (e) {
            var t = this.distanceToPoint(e.start);
            return e = this.distanceToPoint(e.end), 0 > t && e > 0 || 0 > e && t > 0
        },
        intersectsBox: function (e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function (e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function (e) {
            return (e || new c).copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function () {
            var e = new c,
                t = new K;
            return function (i, n) {
                var r = this.coplanarPoint(e).applyMatrix4(i),
                    a = n || t.getNormalMatrix(i),
                    a = this.normal.applyMatrix3(a).normalize();
                return this.constant = -r.dot(a), this
            }
        }(),
        translate: function (e) {
            return this.constant -= e.dot(this.normal), this
        },
        equals: function (e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }), Object.assign(et.prototype, {
        set: function (e, t, i, n, r, a) {
            var o = this.planes;
            return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(n), o[4].copy(r), o[5].copy(a), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            for (var t = this.planes, i = 0; 6 > i; i++) t[i].copy(e.planes[i]);
            return this
        },
        setFromMatrix: function (e) {
            var t = this.planes,
                i = e.elements;
            e = i[0];
            var n = i[1],
                r = i[2],
                a = i[3],
                o = i[4],
                s = i[5],
                c = i[6],
                h = i[7],
                l = i[8],
                u = i[9],
                p = i[10],
                d = i[11],
                f = i[12],
                m = i[13],
                g = i[14],
                i = i[15];
            return t[0].setComponents(a - e, h - o, d - l, i - f).normalize(), t[1].setComponents(a + e, h + o, d + l, i + f).normalize(), t[2].setComponents(a + n, h + s, d + u, i + m).normalize(), t[3].setComponents(a - n, h - s, d - u, i - m).normalize(), t[4].setComponents(a - r, h - c, d - p, i - g).normalize(), t[5].setComponents(a + r, h + c, d + p, i + g).normalize(), this
        },
        intersectsObject: function () {
            var e = new Q;
            return function (t) {
                var i = t.geometry;
                return null === i.boundingSphere && i.computeBoundingSphere(), e.copy(i.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSprite: function () {
            var e = new Q;
            return function (t) {
                return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSphere: function (e) {
            var t = this.planes,
                i = e.center;
            e = -e.radius;
            for (var n = 0; 6 > n; n++)
                if (t[n].distanceToPoint(i) < e) return !1;
            return !0
        },
        intersectsBox: function () {
            var e = new c,
                t = new c;
            return function (i) {
                for (var n = this.planes, r = 0; 6 > r; r++) {
                    var a = n[r];
                    e.x = 0 < a.normal.x ? i.min.x : i.max.x, t.x = 0 < a.normal.x ? i.max.x : i.min.x, e.y = 0 < a.normal.y ? i.min.y : i.max.y, t.y = 0 < a.normal.y ? i.max.y : i.min.y, e.z = 0 < a.normal.z ? i.min.z : i.max.z, t.z = 0 < a.normal.z ? i.max.z : i.min.z;
                    var o = a.distanceToPoint(e),
                        a = a.distanceToPoint(t);
                    if (0 > o && 0 > a) return !1
                }
                return !0
            }
        }(),
        containsPoint: function (e) {
            for (var t = this.planes, i = 0; 6 > i; i++)
                if (0 > t[i].distanceToPoint(e)) return !1;
            return !0
        }
    }), nt.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), nt.DefaultOrder = "XYZ", Object.defineProperties(nt.prototype, {
        x: {
            get: function () {
                return this._x
            },
            set: function (e) {
                this._x = e, this.onChangeCallback()
            }
        },
        y: {
            get: function () {
                return this._y
            },
            set: function (e) {
                this._y = e, this.onChangeCallback()
            }
        },
        z: {
            get: function () {
                return this._z
            },
            set: function (e) {
                this._z = e, this.onChangeCallback()
            }
        },
        order: {
            get: function () {
                return this._order
            },
            set: function (e) {
                this._order = e, this.onChangeCallback()
            }
        }
    }), Object.assign(nt.prototype, {
        isEuler: !0,
        set: function (e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function (e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function (e, t, i) {
            var n = _a.clamp,
                r = e.elements;
            e = r[0];
            var a = r[4],
                o = r[8],
                s = r[1],
                c = r[5],
                h = r[9],
                l = r[2],
                u = r[6],
                r = r[10];
            return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(n(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(-h, r), this._z = Math.atan2(-a, e)) : (this._x = Math.atan2(u, c), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(h, -1, 1)), .99999 > Math.abs(h) ? (this._y = Math.atan2(o, r), this._z = Math.atan2(s, c)) : (this._y = Math.atan2(-l, e), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(u, -1, 1)), .99999 > Math.abs(u) ? (this._y = Math.atan2(-l, r), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(s, e))) : "ZYX" === t ? (this._y = Math.asin(-n(l, -1, 1)), .99999 > Math.abs(l) ? (this._x = Math.atan2(u, r), this._z = Math.atan2(s, e)) : (this._x = 0, this._z = Math.atan2(-a, c))) : "YZX" === t ? (this._z = Math.asin(n(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-l, e)) : (this._x = 0, this._y = Math.atan2(o, r))) : "XZY" === t ? (this._z = Math.asin(-n(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(u, c), this._y = Math.atan2(o, e)) : (this._x = Math.atan2(-h, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== i && this.onChangeCallback(), this
        },
        setFromQuaternion: function () {
            var e = new h;
            return function (t, i, n) {
                return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, i, n)
            }
        }(),
        setFromVector3: function (e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: function () {
            var e = new s;
            return function (t) {
                return e.setFromEuler(this), this.setFromQuaternion(e, t)
            }
        }(),
        equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function (e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        },
        toVector3: function (e) {
            return e ? e.set(this._x, this._y, this._z) : new c(this._x, this._y, this._z)
        },
        onChange: function (e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function () {}
    }), Object.assign(rt.prototype, {
        set: function (e) {
            this.mask = 1 << e | 0
        },
        enable: function (e) {
            this.mask = this.mask | 1 << e | 0
        },
        toggle: function (e) {
            this.mask ^= 1 << e | 0
        },
        disable: function (e) {
            this.mask &= ~(1 << e | 0)
        },
        test: function (e) {
            return 0 !== (this.mask & e.mask)
        }
    });
    var Oa = 0;
    at.DefaultUp = new c(0, 1, 0), at.DefaultMatrixAutoUpdate = !0, Object.assign(at.prototype, t.prototype, {
        isObject3D: !0,
        onBeforeRender: function () {},
        onAfterRender: function () {},
        applyMatrix: function (e) {
            this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function (e) {
            return this.quaternion.premultiply(e), this
        },
        setRotationFromAxisAngle: function (e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function (e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function (e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function (e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function () {
            var e = new s;
            return function (t, i) {
                return e.setFromAxisAngle(t, i), this.quaternion.multiply(e), this
            }
        }(),
        rotateX: function () {
            var e = new c(1, 0, 0);
            return function (t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateY: function () {
            var e = new c(0, 1, 0);
            return function (t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateZ: function () {
            var e = new c(0, 0, 1);
            return function (t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        translateOnAxis: function () {
            var e = new c;
            return function (t, i) {
                return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(i)), this
            }
        }(),
        translateX: function () {
            var e = new c(1, 0, 0);
            return function (t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateY: function () {
            var e = new c(0, 1, 0);
            return function (t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateZ: function () {
            var e = new c(0, 0, 1);
            return function (t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        localToWorld: function (e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function () {
            var e = new h;
            return function (t) {
                return t.applyMatrix4(e.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function () {
            var e = new h;
            return function (t) {
                this.isCamera ? e.lookAt(this.position, t, this.up) : e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e)
            }
        }(),
        add: function (e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                type: "added"
            }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        },
        remove: function (e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                return this
            }
            return t = this.children.indexOf(e), -1 !== t && (e.parent = null, e.dispatchEvent({
                type: "removed"
            }), this.children.splice(t, 1)), this
        },
        getObjectById: function (e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function (e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function (e, t) {
            if (this[e] === t) return this;
            for (var i = 0, n = this.children.length; n > i; i++) {
                var r = this.children[i].getObjectByProperty(e, t);
                if (void 0 !== r) return r
            }
        },
        getWorldPosition: function (e) {
            return e = e || new c, this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function () {
            var e = new c,
                t = new c;
            return function (i) {
                return i = i || new s, this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, i, t), i
            }
        }(),
        getWorldRotation: function () {
            var e = new s;
            return function (t) {
                return t = t || new nt, this.getWorldQuaternion(e), t.setFromQuaternion(e, this.rotation.order, !1)
            }
        }(),
        getWorldScale: function () {
            var e = new c,
                t = new s;
            return function (i) {
                return i = i || new c, this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, i), i
            }
        }(),
        getWorldDirection: function () {
            var e = new s;
            return function (t) {
                return t = t || new c, this.getWorldQuaternion(e), t.set(0, 0, 1).applyQuaternion(e)
            }
        }(),
        raycast: function () {},
        traverse: function (e) {
            e(this);
            for (var t = this.children, i = 0, n = t.length; n > i; i++) t[i].traverse(e)
        },
        traverseVisible: function (e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, i = 0, n = t.length; n > i; i++) t[i].traverseVisible(e)
            }
        },
        traverseAncestors: function (e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        },
        updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
            for (var t = this.children, i = 0, n = t.length; n > i; i++) t[i].updateMatrixWorld(e)
        },
        toJSON: function (e) {
            function t(t, i) {
                return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid
            }

            function i(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    delete n.metadata, i.push(n)
                }
                return i
            }
            var n = void 0 === e || "" === e,
                r = {};
            n && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            }, r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var a = {};
            if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), !0 === this.castShadow && (a.castShadow = !0), !0 === this.receiveShadow && (a.receiveShadow = !0), !1 === this.visible && (a.visible = !1), a.matrix = this.matrix.toArray(), void 0 !== this.geometry && (a.geometry = t(e.geometries, this.geometry)), void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (var o = [], s = 0, c = this.material.length; c > s; s++) o.push(t(e.materials, this.material[s]));
                    a.material = o
                } else a.material = t(e.materials, this.material);
            if (0 < this.children.length)
                for (a.children = [], s = 0; s < this.children.length; s++) a.children.push(this.children[s].toJSON(e).object);
            return n && (n = i(e.geometries), o = i(e.materials), s = i(e.textures), c = i(e.images), 0 < n.length && (r.geometries = n), 0 < o.length && (r.materials = o), 0 < s.length && (r.textures = s), 0 < c.length && (r.images = c)), r.object = a, r
        },
        clone: function (e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function (e, t) {
            if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                for (var i = 0; i < e.children.length; i++) this.add(e.children[i].clone());
            return this
        }
    }), ot.prototype = Object.assign(Object.create(at.prototype), {
        constructor: ot,
        isCamera: !0,
        copy: function (e, t) {
            return at.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this
        },
        getWorldDirection: function () {
            var e = new s;
            return function (t) {
                return t = t || new c, this.getWorldQuaternion(e), t.set(0, 0, -1).applyQuaternion(e)
            }
        }(),
        updateMatrixWorld: function (e) {
            at.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        }
    }), st.prototype = Object.assign(Object.create(ot.prototype), {
        constructor: st,
        isOrthographicCamera: !0,
        copy: function (e, t) {
            return ot.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        },
        setViewOffset: function (e, t, i, n, r, a) {
            this.view = {
                fullWidth: e,
                fullHeight: t,
                offsetX: i,
                offsetY: n,
                width: r,
                height: a
            }, this.updateProjectionMatrix()
        },
        clearViewOffset: function () {
            this.view = null, this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function () {
            var e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                i = (this.right + this.left) / 2,
                n = (this.top + this.bottom) / 2,
                r = i - e,
                i = i + e,
                e = n + t,
                t = n - t;
            if (null !== this.view) var i = this.zoom / (this.view.width / this.view.fullWidth),
                t = this.zoom / (this.view.height / this.view.fullHeight),
                a = (this.right - this.left) / this.view.width,
                n = (this.top - this.bottom) / this.view.height,
                r = r + this.view.offsetX / i * a,
                i = r + this.view.width / i * a,
                e = e - this.view.offsetY / t * n,
                t = e - this.view.height / t * n;
            this.projectionMatrix.makeOrthographic(r, i, e, t, this.near, this.far)
        },
        toJSON: function (e) {
            return e = at.prototype.toJSON.call(this, e), e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    }), ct.prototype = Object.assign(Object.create(ot.prototype), {
        constructor: ct,
        isPerspectiveCamera: !0,
        copy: function (e, t) {
            return ot.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        },
        setFocalLength: function (e) {
            e = .5 * this.getFilmHeight() / e, this.fov = 2 * _a.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function () {
            var e = Math.tan(.5 * _a.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function () {
            return 2 * _a.RAD2DEG * Math.atan(Math.tan(.5 * _a.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function (e, t, i, n, r, a) {
            this.aspect = e / t, this.view = {
                fullWidth: e,
                fullHeight: t,
                offsetX: i,
                offsetY: n,
                width: r,
                height: a
            }, this.updateProjectionMatrix()
        },
        clearViewOffset: function () {
            this.view = null, this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function () {
            var e = this.near,
                t = e * Math.tan(.5 * _a.DEG2RAD * this.fov) / this.zoom,
                i = 2 * t,
                n = this.aspect * i,
                r = -.5 * n,
                a = this.view;
            if (null !== a) var o = a.fullWidth,
                s = a.fullHeight,
                r = r + a.offsetX * n / o,
                t = t - a.offsetY * i / s,
                n = a.width / o * n,
                i = a.height / s * i;
            a = this.filmOffset, 0 !== a && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far)
        },
        toJSON: function (e) {
            return e = at.prototype.toJSON.call(this, e), e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    }), Object.assign(ht.prototype, {
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
            for (var t = 0, i = e.vertexNormals.length; i > t; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0, i = e.vertexColors.length; i > t; t++) this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    });
    var Fa = 0;
    Object.assign(lt.prototype, t.prototype, {
        isGeometry: !0,
        applyMatrix: function (e) {
            for (var t = (new K).getNormalMatrix(e), i = 0, n = this.vertices.length; n > i; i++) this.vertices[i].applyMatrix4(e);
            for (i = 0, n = this.faces.length; n > i; i++) {
                e = this.faces[i], e.normal.applyMatrix3(t).normalize();
                for (var r = 0, a = e.vertexNormals.length; a > r; r++) e.vertexNormals[r].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
        },
        rotateX: function () {
            var e = new h;
            return function (t) {
                return e.makeRotationX(t), this.applyMatrix(e), this
            }
        }(),
        rotateY: function () {
            var e = new h;
            return function (t) {
                return e.makeRotationY(t), this.applyMatrix(e), this
            }
        }(),
        rotateZ: function () {
            var e = new h;
            return function (t) {
                return e.makeRotationZ(t), this.applyMatrix(e), this
            }
        }(),
        translate: function () {
            var e = new h;
            return function (t, i, n) {
                return e.makeTranslation(t, i, n), this.applyMatrix(e), this
            }
        }(),
        scale: function () {
            var e = new h;
            return function (t, i, n) {
                return e.makeScale(t, i, n), this.applyMatrix(e), this
            }
        }(),
        lookAt: function () {
            var e = new at;
            return function (t) {
                e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
            }
        }(),
        fromBufferGeometry: function (e) {
            function t(e, t, i, r) {
                var a = void 0 !== s ? [p[e].clone(), p[t].clone(), p[i].clone()] : [],
                    o = void 0 !== h ? [n.colors[e].clone(), n.colors[t].clone(), n.colors[i].clone()] : [];
                r = new ht(e, t, i, a, o, r), n.faces.push(r), void 0 !== l && n.faceVertexUvs[0].push([d[e].clone(), d[t].clone(), d[i].clone()]), void 0 !== u && n.faceVertexUvs[1].push([f[e].clone(), f[t].clone(), f[i].clone()])
            }
            var n = this,
                r = null !== e.index ? e.index.array : void 0,
                a = e.attributes,
                o = a.position.array,
                s = void 0 !== a.normal ? a.normal.array : void 0,
                h = void 0 !== a.color ? a.color.array : void 0,
                l = void 0 !== a.uv ? a.uv.array : void 0,
                u = void 0 !== a.uv2 ? a.uv2.array : void 0;
            void 0 !== u && (this.faceVertexUvs[1] = []);
            for (var p = [], d = [], f = [], m = a = 0; a < o.length; a += 3, m += 2) n.vertices.push(new c(o[a], o[a + 1], o[a + 2])), void 0 !== s && p.push(new c(s[a], s[a + 1], s[a + 2])), void 0 !== h && n.colors.push(new k(h[a], h[a + 1], h[a + 2])), void 0 !== l && d.push(new i(l[m], l[m + 1])), void 0 !== u && f.push(new i(u[m], u[m + 1]));
            var g = e.groups;
            if (0 < g.length)
                for (a = 0; a < g.length; a++)
                    for (var o = g[a], v = o.start, y = o.count, m = v, v = v + y; v > m; m += 3) void 0 !== r ? t(r[m], r[m + 1], r[m + 2], o.materialIndex) : t(m, m + 1, m + 2, o.materialIndex);
            else if (void 0 !== r)
                for (a = 0; a < r.length; a += 3) t(r[a], r[a + 1], r[a + 2]);
            else
                for (a = 0; a < o.length / 3; a += 3) t(a, a + 1, a + 2);
            return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        },
        center: function () {
            this.computeBoundingBox();
            var e = this.boundingBox.getCenter().negate();
            return this.translate(e.x, e.y, e.z), e
        },
        normalize: function () {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center,
                t = this.boundingSphere.radius,
                t = 0 === t ? 1 : 1 / t,
                i = new h;
            return i.set(t, 0, 0, -t * e.x, 0, t, 0, -t * e.y, 0, 0, t, -t * e.z, 0, 0, 0, 1), this.applyMatrix(i), this
        },
        computeFaceNormals: function () {
            for (var e = new c, t = new c, i = 0, n = this.faces.length; n > i; i++) {
                var r = this.faces[i],
                    a = this.vertices[r.a],
                    o = this.vertices[r.b];
                e.subVectors(this.vertices[r.c], o), t.subVectors(a, o), e.cross(t), e.normalize(), r.normal.copy(e)
            }
        },
        computeVertexNormals: function (e) {
            void 0 === e && (e = !0);
            var t, i, n;
            for (n = Array(this.vertices.length), t = 0, i = this.vertices.length; i > t; t++) n[t] = new c;
            if (e) {
                var r, a, o, s = new c,
                    h = new c;
                for (e = 0, t = this.faces.length; t > e; e++) i = this.faces[e], r = this.vertices[i.a], a = this.vertices[i.b], o = this.vertices[i.c], s.subVectors(o, a), h.subVectors(r, a), s.cross(h), n[i.a].add(s), n[i.b].add(s), n[i.c].add(s)
            } else
                for (this.computeFaceNormals(), e = 0, t = this.faces.length; t > e; e++) i = this.faces[e], n[i.a].add(i.normal), n[i.b].add(i.normal), n[i.c].add(i.normal);
            for (t = 0, i = this.vertices.length; i > t; t++) n[t].normalize();
            for (e = 0, t = this.faces.length; t > e; e++) i = this.faces[e], r = i.vertexNormals, 3 === r.length ? (r[0].copy(n[i.a]), r[1].copy(n[i.b]), r[2].copy(n[i.c])) : (r[0] = n[i.a].clone(), r[1] = n[i.b].clone(), r[2] = n[i.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function () {
            var e, t, i;
            for (this.computeFaceNormals(), e = 0, t = this.faces.length; t > e; e++) {
                i = this.faces[e];
                var n = i.vertexNormals;
                3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function () {
            var e, t, i, n, r;
            for (i = 0, n = this.faces.length; n > i; i++)
                for (r = this.faces[i], r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), e = 0, t = r.vertexNormals.length; t > e; e++) r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone();
            var a = new lt;
            for (a.faces = this.faces, e = 0, t = this.morphTargets.length; t > e; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [], r = this.morphNormals[e].faceNormals;
                    var o, s, h = this.morphNormals[e].vertexNormals;
                    for (i = 0, n = this.faces.length; n > i; i++) o = new c, s = {
                        a: new c,
                        b: new c,
                        c: new c
                    }, r.push(o), h.push(s)
                }
                for (h = this.morphNormals[e], a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals(), i = 0, n = this.faces.length; n > i; i++) r = this.faces[i], o = h.faceNormals[i], s = h.vertexNormals[i], o.copy(r.normal), s.a.copy(r.vertexNormals[0]), s.b.copy(r.vertexNormals[1]), s.c.copy(r.vertexNormals[2])
            }
            for (i = 0, n = this.faces.length; n > i; i++) r = this.faces[i], r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
        },
        computeLineDistances: function () {
            for (var e = 0, t = this.vertices, i = 0, n = t.length; n > i; i++) i > 0 && (e += t[i].distanceTo(t[i - 1])), this.lineDistances[i] = e
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new J), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new Q), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function (e, t, i) {
            if (e && e.isGeometry) {
                var n, r = this.vertices.length,
                    a = this.vertices,
                    o = e.vertices,
                    s = this.faces,
                    c = e.faces,
                    h = this.faceVertexUvs[0],
                    l = e.faceVertexUvs[0],
                    u = this.colors,
                    p = e.colors;
                void 0 === i && (i = 0), void 0 !== t && (n = (new K).getNormalMatrix(t)), e = 0;
                for (var d = o.length; d > e; e++) {
                    var f = o[e].clone();
                    void 0 !== t && f.applyMatrix4(t), a.push(f)
                }
                for (e = 0, d = p.length; d > e; e++) u.push(p[e].clone());
                for (e = 0, d = c.length; d > e; e++) {
                    var o = c[e],
                        m = o.vertexNormals,
                        p = o.vertexColors,
                        u = new ht(o.a + r, o.b + r, o.c + r);
                    for (u.normal.copy(o.normal), void 0 !== n && u.normal.applyMatrix3(n).normalize(), t = 0, a = m.length; a > t; t++) f = m[t].clone(), void 0 !== n && f.applyMatrix3(n).normalize(), u.vertexNormals.push(f);
                    for (u.color.copy(o.color), t = 0, a = p.length; a > t; t++) f = p[t], u.vertexColors.push(f.clone());
                    u.materialIndex = o.materialIndex + i, s.push(u)
                }
                for (e = 0, d = l.length; d > e; e++)
                    if (i = l[e], n = [], void 0 !== i) {
                        for (t = 0, a = i.length; a > t; t++) n.push(i[t].clone());
                        h.push(n)
                    }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
        },
        mergeMesh: function (e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
        },
        mergeVertices: function () {
            var e, t, i, n = {},
                r = [],
                a = [],
                o = Math.pow(10, 4);
            for (t = 0, i = this.vertices.length; i > t; t++) e = this.vertices[t], e = Math.round(e.x * o) + "_" + Math.round(e.y * o) + "_" + Math.round(e.z * o), void 0 === n[e] ? (n[e] = t, r.push(this.vertices[t]), a[t] = r.length - 1) : a[t] = a[n[e]];
            for (n = [], t = 0, i = this.faces.length; i > t; t++)
                for (o = this.faces[t], o.a = a[o.a], o.b = a[o.b], o.c = a[o.c], o = [o.a, o.b, o.c], e = 0; 3 > e; e++)
                    if (o[e] === o[(e + 1) % 3]) {
                        n.push(t);
                        break
                    }
            for (t = n.length - 1; t >= 0; t--)
                for (o = n[t], this.faces.splice(o, 1), a = 0, i = this.faceVertexUvs.length; i > a; a++) this.faceVertexUvs[a].splice(o, 1);
            return t = this.vertices.length - r.length, this.vertices = r, t
        },
        sortFacesByMaterialIndex: function () {
            for (var e = this.faces, t = e.length, i = 0; t > i; i++) e[i]._id = i;
            e.sort(function (e, t) {
                return e.materialIndex - t.materialIndex
            });
            var n, r, a = this.faceVertexUvs[0],
                o = this.faceVertexUvs[1];
            for (a && a.length === t && (n = []), o && o.length === t && (r = []), i = 0; t > i; i++) {
                var s = e[i]._id;
                n && n.push(a[s]), r && r.push(o[s])
            }
            n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function () {
            function e(e, t, i) {
                return i ? e | 1 << t : e & ~(1 << t)
            }

            function t(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== h[t] ? h[t] : (h[t] = c.length / 3, c.push(e.x, e.y, e.z), h[t])
            }

            function i(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== u[t] ? u[t] : (u[t] = l.length, l.push(e.getHex()), u[t])
            }

            function n(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== d[t] ? d[t] : (d[t] = p.length / 2, p.push(e.x, e.y), d[t])
            }
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                var a, o = this.parameters;
                for (a in o) void 0 !== o[a] && (r[a] = o[a]);
                return r
            }
            for (o = [], a = 0; a < this.vertices.length; a++) {
                var s = this.vertices[a];
                o.push(s.x, s.y, s.z)
            }
            var s = [],
                c = [],
                h = {},
                l = [],
                u = {},
                p = [],
                d = {};
            for (a = 0; a < this.faces.length; a++) {
                var f = this.faces[a],
                    m = void 0 !== this.faceVertexUvs[0][a],
                    g = 0 < f.normal.length(),
                    v = 0 < f.vertexNormals.length,
                    y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                    x = 0 < f.vertexColors.length,
                    b = 0,
                    b = e(b, 0, 0),
                    b = e(b, 1, !0),
                    b = e(b, 2, !1),
                    b = e(b, 3, m),
                    b = e(b, 4, g),
                    b = e(b, 5, v),
                    b = e(b, 6, y),
                    b = e(b, 7, x);
                s.push(b), s.push(f.a, f.b, f.c), s.push(f.materialIndex), m && (m = this.faceVertexUvs[0][a], s.push(n(m[0]), n(m[1]), n(m[2]))), g && s.push(t(f.normal)), v && (g = f.vertexNormals, s.push(t(g[0]), t(g[1]), t(g[2]))), y && s.push(i(f.color)), x && (f = f.vertexColors, s.push(i(f[0]), i(f[1]), i(f[2])))
            }
            return r.data = {}, r.data.vertices = o, r.data.normals = c, 0 < l.length && (r.data.colors = l), 0 < p.length && (r.data.uvs = [p]), r.data.faces = s, r
        },
        clone: function () {
            return (new lt).copy(this)
        },
        copy: function (e) {
            var t, i, n, r, a, o;
            for (this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = e.name, n = e.vertices, t = 0, i = n.length; i > t; t++) this.vertices.push(n[t].clone());
            for (n = e.colors, t = 0, i = n.length; i > t; t++) this.colors.push(n[t].clone());
            for (n = e.faces, t = 0, i = n.length; i > t; t++) this.faces.push(n[t].clone());
            for (t = 0, i = e.faceVertexUvs.length; i > t; t++) {
                var s = e.faceVertexUvs[t];
                for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), n = 0, r = s.length; r > n; n++) {
                    var c = s[n],
                        h = [];
                    for (a = 0, o = c.length; o > a; a++) h.push(c[a].clone());
                    this.faceVertexUvs[t].push(h)
                }
            }
            for (a = e.morphTargets, t = 0, i = a.length; i > t; t++) {
                if (o = {}, o.name = a[t].name, void 0 !== a[t].vertices)
                    for (o.vertices = [], n = 0, r = a[t].vertices.length; r > n; n++) o.vertices.push(a[t].vertices[n].clone());
                if (void 0 !== a[t].normals)
                    for (o.normals = [], n = 0, r = a[t].normals.length; r > n; n++) o.normals.push(a[t].normals[n].clone());
                this.morphTargets.push(o)
            }
            for (a = e.morphNormals, t = 0, i = a.length; i > t; t++) {
                if (o = {}, void 0 !== a[t].vertexNormals)
                    for (o.vertexNormals = [], n = 0, r = a[t].vertexNormals.length; r > n; n++) s = a[t].vertexNormals[n], c = {}, c.a = s.a.clone(), c.b = s.b.clone(), c.c = s.c.clone(), o.vertexNormals.push(c);
                if (void 0 !== a[t].faceNormals)
                    for (o.faceNormals = [], n = 0, r = a[t].faceNormals.length; r > n; n++) o.faceNormals.push(a[t].faceNormals[n].clone());
                this.morphNormals.push(o)
            }
            for (n = e.skinWeights, t = 0, i = n.length; i > t; t++) this.skinWeights.push(n[t].clone());
            for (n = e.skinIndices, t = 0, i = n.length; i > t; t++) this.skinIndices.push(n[t].clone());
            for (n = e.lineDistances, t = 0, i = n.length; i > t; t++) this.lineDistances.push(n[t]);
            return t = e.boundingBox, null !== t && (this.boundingBox = t.clone()), t = e.boundingSphere, null !== t && (this.boundingSphere = t.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(ut.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(ut.prototype, {
        isBufferAttribute: !0,
        setArray: function (e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e
        },
        setDynamic: function (e) {
            return this.dynamic = e, this
        },
        copy: function (e) {
            return this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
        },
        copyAt: function (e, t, i) {
            e *= this.itemSize, i *= t.itemSize;
            for (var n = 0, r = this.itemSize; r > n; n++) this.array[e + n] = t.array[i + n];
            return this
        },
        copyArray: function (e) {
            return this.array.set(e), this
        },
        copyColorsArray: function (e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; r > n; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), a = new k), t[i++] = a.r, t[i++] = a.g, t[i++] = a.b
            }
            return this
        },
        copyIndicesArray: function (e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; r > n; n++) {
                var a = e[n];
                t[i++] = a.a, t[i++] = a.b, t[i++] = a.c
            }
            return this
        },
        copyVector2sArray: function (e) {
            for (var t = this.array, n = 0, r = 0, a = e.length; a > r; r++) {
                var o = e[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new i), t[n++] = o.x, t[n++] = o.y
            }
            return this
        },
        copyVector3sArray: function (e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; r > n; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new c), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z
            }
            return this
        },
        copyVector4sArray: function (e) {
            for (var t = this.array, i = 0, n = 0, a = e.length; a > n; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new r), t[i++] = o.x, t[i++] = o.y, t[i++] = o.z, t[i++] = o.w
            }
            return this
        },
        set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        getX: function (e) {
            return this.array[e * this.itemSize]
        },
        setX: function (e, t) {
            return this.array[e * this.itemSize] = t, this
        },
        getY: function (e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function (e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        },
        getZ: function (e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function (e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        },
        getW: function (e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function (e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        },
        setXY: function (e, t, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this
        },
        setXYZ: function (e, t, i, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this
        },
        setXYZW: function (e, t, i, n, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this
        },
        onUpload: function (e) {
            return this.onUploadCallback = e, this
        },
        clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
    }), pt.prototype = Object.create(ut.prototype), pt.prototype.constructor = pt, dt.prototype = Object.create(ut.prototype), dt.prototype.constructor = dt, ft.prototype = Object.create(ut.prototype), ft.prototype.constructor = ft, mt.prototype = Object.create(ut.prototype), mt.prototype.constructor = mt, gt.prototype = Object.create(ut.prototype), gt.prototype.constructor = gt, vt.prototype = Object.create(ut.prototype), vt.prototype.constructor = vt, yt.prototype = Object.create(ut.prototype), yt.prototype.constructor = yt, xt.prototype = Object.create(ut.prototype), xt.prototype.constructor = xt, bt.prototype = Object.create(ut.prototype), bt.prototype.constructor = bt, Object.assign(_t.prototype, {
        computeGroups: function (e) {
            var t, i = [],
                n = void 0;
            e = e.faces;
            for (var r = 0; r < e.length; r++) {
                var a = e[r];
                a.materialIndex !== n && (n = a.materialIndex, void 0 !== t && (t.count = 3 * r - t.start, i.push(t)), t = {
                    start: 3 * r,
                    materialIndex: n
                })
            }
            void 0 !== t && (t.count = 3 * r - t.start, i.push(t)), this.groups = i
        },
        fromGeometry: function (e) {
            var t, n = e.faces,
                r = e.vertices,
                a = e.faceVertexUvs,
                o = a[0] && 0 < a[0].length,
                s = a[1] && 0 < a[1].length,
                c = e.morphTargets,
                h = c.length;
            if (h > 0) {
                t = [];
                for (var l = 0; h > l; l++) t[l] = [];
                this.morphTargets.position = t
            }
            var u, p = e.morphNormals,
                d = p.length;
            if (d > 0) {
                for (u = [], l = 0; d > l; l++) u[l] = [];
                this.morphTargets.normal = u
            }
            for (var f = e.skinIndices, m = e.skinWeights, g = f.length === r.length, v = m.length === r.length, l = 0; l < n.length; l++) {
                var y = n[l];
                this.vertices.push(r[y.a], r[y.b], r[y.c]);
                var x = y.vertexNormals;
                for (3 === x.length ? this.normals.push(x[0], x[1], x[2]) : (x = y.normal, this.normals.push(x, x, x)), x = y.vertexColors, 3 === x.length ? this.colors.push(x[0], x[1], x[2]) : (x = y.color, this.colors.push(x, x, x)), !0 === o && (x = a[0][l], void 0 !== x ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new i, new i, new i))), !0 === s && (x = a[1][l], void 0 !== x ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new i, new i, new i))), x = 0; h > x; x++) {
                    var b = c[x].vertices;
                    t[x].push(b[y.a], b[y.b], b[y.c])
                }
                for (x = 0; d > x; x++) b = p[x].vertexNormals[l], u[x].push(b.a, b.b, b.c);
                g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
            }
            return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        }
    }), Mt.MaxIndex = 65535, Object.assign(Mt.prototype, t.prototype, {
        isBufferGeometry: !0,
        getIndex: function () {
            return this.index
        },
        setIndex: function (e) {
            this.index = Array.isArray(e) ? new(65535 < wt(e) ? yt : gt)(e, 1) : e
        },
        addAttribute: function (e, t, i) {
            if (t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute) {
                if ("index" !== e) return this.attributes[e] = t, this;
                console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t)
            } else console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new ut(t, i))
        },
        getAttribute: function (e) {
            return this.attributes[e]
        },
        removeAttribute: function (e) {
            return delete this.attributes[e], this
        },
        addGroup: function (e, t, i) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== i ? i : 0
            })
        },
        clearGroups: function () {
            this.groups = []
        },
        setDrawRange: function (e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        },
        applyMatrix: function (e) {
            var t = this.attributes.position;
            return void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0), t = this.attributes.normal, void 0 !== t && ((new K).getNormalMatrix(e).applyToBufferAttribute(t), t.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function () {
            var e = new h;
            return function (t) {
                return e.makeRotationX(t), this.applyMatrix(e), this
            }
        }(),
        rotateY: function () {
            var e = new h;
            return function (t) {
                return e.makeRotationY(t), this.applyMatrix(e), this
            }
        }(),
        rotateZ: function () {
            var e = new h;
            return function (t) {
                return e.makeRotationZ(t), this.applyMatrix(e), this
            }
        }(),
        translate: function () {
            var e = new h;
            return function (t, i, n) {
                return e.makeTranslation(t, i, n), this.applyMatrix(e), this
            }
        }(),
        scale: function () {
            var e = new h;
            return function (t, i, n) {
                return e.makeScale(t, i, n), this.applyMatrix(e), this
            }
        }(),
        lookAt: function () {
            var e = new at;
            return function (t) {
                e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
            }
        }(),
        center: function () {
            this.computeBoundingBox();
            var e = this.boundingBox.getCenter().negate();
            return this.translate(e.x, e.y, e.z), e
        },
        setFromObject: function (e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                e = new xt(3 * t.vertices.length, 3);
                var i = new xt(3 * t.colors.length, 3);
                this.addAttribute("position", e.copyVector3sArray(t.vertices)), this.addAttribute("color", i.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length && (e = new xt(t.lineDistances.length, 1), this.addAttribute("lineDistance", e.copyArray(t.lineDistances))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        updateFromObject: function (e) {
            var t = e.geometry;
            if (e.isMesh) {
                var i = t.__directGeometry;
                if (!0 === t.elementsNeedUpdate && (i = void 0, t.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(t);
                i.verticesNeedUpdate = t.verticesNeedUpdate, i.normalsNeedUpdate = t.normalsNeedUpdate, i.colorsNeedUpdate = t.colorsNeedUpdate, i.uvsNeedUpdate = t.uvsNeedUpdate, i.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = i
            }
            return !0 === t.verticesNeedUpdate && (i = this.attributes.position, void 0 !== i && (i.copyVector3sArray(t.vertices), i.needsUpdate = !0), t.verticesNeedUpdate = !1), !0 === t.normalsNeedUpdate && (i = this.attributes.normal, void 0 !== i && (i.copyVector3sArray(t.normals), i.needsUpdate = !0), t.normalsNeedUpdate = !1), !0 === t.colorsNeedUpdate && (i = this.attributes.color, void 0 !== i && (i.copyColorsArray(t.colors), i.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (i = this.attributes.uv, void 0 !== i && (i.copyVector2sArray(t.uvs), i.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (i = this.attributes.lineDistance, void 0 !== i && (i.copyArray(t.lineDistances), i.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
        },
        fromGeometry: function (e) {
            return e.__directGeometry = (new _t).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function (e) {
            var t = new Float32Array(3 * e.vertices.length);
            this.addAttribute("position", new ut(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length && (t = new Float32Array(3 * e.normals.length), this.addAttribute("normal", new ut(t, 3).copyVector3sArray(e.normals))), 0 < e.colors.length && (t = new Float32Array(3 * e.colors.length), this.addAttribute("color", new ut(t, 3).copyColorsArray(e.colors))), 0 < e.uvs.length && (t = new Float32Array(2 * e.uvs.length), this.addAttribute("uv", new ut(t, 2).copyVector2sArray(e.uvs))), 0 < e.uvs2.length && (t = new Float32Array(2 * e.uvs2.length), this.addAttribute("uv2", new ut(t, 2).copyVector2sArray(e.uvs2))), 0 < e.indices.length && (t = new(65535 < wt(e.indices) ? Uint32Array : Uint16Array)(3 * e.indices.length), this.setIndex(new ut(t, 1).copyIndicesArray(e.indices))), this.groups = e.groups;
            for (var i in e.morphTargets) {
                for (var t = [], n = e.morphTargets[i], r = 0, a = n.length; a > r; r++) {
                    var o = n[r],
                        s = new xt(3 * o.length, 3);
                    t.push(s.copyVector3sArray(o))
                }
                this.morphAttributes[i] = t
            }
            return 0 < e.skinIndices.length && (i = new xt(4 * e.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(e.skinIndices))), 0 < e.skinWeights.length && (i = new xt(4 * e.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(e.skinWeights))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new J);
            var e = this.attributes.position;
            void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function () {
            var e = new J,
                t = new c;
            return function () {
                null === this.boundingSphere && (this.boundingSphere = new Q);
                var i = this.attributes.position;
                if (i) {
                    var n = this.boundingSphere.center;
                    e.setFromBufferAttribute(i), e.getCenter(n);
                    for (var r = 0, a = 0, o = i.count; o > a; a++) t.x = i.getX(a), t.y = i.getY(a), t.z = i.getZ(a), r = Math.max(r, n.distanceToSquared(t));
                    this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function () {},
        computeVertexNormals: function () {
            var e = this.index,
                t = this.attributes,
                i = this.groups;
            if (t.position) {
                var n = t.position.array;
                if (void 0 === t.normal) this.addAttribute("normal", new ut(new Float32Array(n.length), 3));
                else
                    for (var r = t.normal.array, a = 0, o = r.length; o > a; a++) r[a] = 0;
                var s, h, l, r = t.normal.array,
                    u = new c,
                    p = new c,
                    d = new c,
                    f = new c,
                    m = new c;
                if (e) {
                    e = e.array, 0 === i.length && this.addGroup(0, e.length);
                    for (var g = 0, v = i.length; v > g; ++g)
                        for (a = i[g], o = a.start, s = a.count, a = o, o += s; o > a; a += 3) s = 3 * e[a + 0], h = 3 * e[a + 1], l = 3 * e[a + 2], u.fromArray(n, s), p.fromArray(n, h), d.fromArray(n, l), f.subVectors(d, p), m.subVectors(u, p), f.cross(m), r[s] += f.x, r[s + 1] += f.y, r[s + 2] += f.z, r[h] += f.x, r[h + 1] += f.y, r[h + 2] += f.z, r[l] += f.x, r[l + 1] += f.y, r[l + 2] += f.z
                } else
                    for (a = 0, o = n.length; o > a; a += 9) u.fromArray(n, a), p.fromArray(n, a + 3), d.fromArray(n, a + 6), f.subVectors(d, p), m.subVectors(u, p), f.cross(m), r[a] = f.x, r[a + 1] = f.y, r[a + 2] = f.z, r[a + 3] = f.x, r[a + 4] = f.y, r[a + 5] = f.z, r[a + 6] = f.x, r[a + 7] = f.y, r[a + 8] = f.z;
                this.normalizeNormals(), t.normal.needsUpdate = !0
            }
        },
        merge: function (e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0);
                var i, n = this.attributes;
                for (i in n)
                    if (void 0 !== e.attributes[i])
                        for (var r = n[i].array, a = e.attributes[i], o = a.array, s = 0, a = a.itemSize * t; s < o.length; s++, a++) r[a] = o[s];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        },
        normalizeNormals: function () {
            for (var e, t, i, n, r = this.attributes.normal, a = 0, o = r.count; o > a; a++) e = r.getX(a), t = r.getY(a), i = r.getZ(a), n = 1 / Math.sqrt(e * e + t * t + i * i), r.setXYZ(a, e * n, t * n, i * n)
        },
        toNonIndexed: function () {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var e, t = new Mt,
                i = this.index.array,
                n = this.attributes;
            for (e in n) {
                for (var r, a = n[e], o = a.array, a = a.itemSize, s = new o.constructor(i.length * a), c = 0, h = 0, l = i.length; l > h; h++) {
                    r = i[h] * a;
                    for (var u = 0; a > u; u++) s[c++] = o[r++]
                }
                t.addAttribute(e, new ut(s, a))
            }
            return t
        },
        toJSON: function () {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                var t, i = this.parameters;
                for (t in i) void 0 !== i[t] && (e[t] = i[t]);
                return e
            }
            e.data = {
                attributes: {}
            };
            var n = this.index;
            null !== n && (i = Array.prototype.slice.call(n.array), e.data.index = {
                type: n.array.constructor.name,
                array: i
            }), n = this.attributes;
            for (t in n) {
                var r = n[t],
                    i = Array.prototype.slice.call(r.array);
                e.data.attributes[t] = {
                    itemSize: r.itemSize,
                    type: r.array.constructor.name,
                    array: i,
                    normalized: r.normalized
                }
            }
            return t = this.groups, 0 < t.length && (e.data.groups = JSON.parse(JSON.stringify(t))), t = this.boundingSphere, null !== t && (e.data.boundingSphere = {
                center: t.center.toArray(),
                radius: t.radius
            }), e
        },
        clone: function () {
            return (new Mt).copy(this)
        },
        copy: function (e) {
            var t, i, n;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = e.name, i = e.index, null !== i && this.setIndex(i.clone()), i = e.attributes;
            for (t in i) this.addAttribute(t, i[t].clone());
            var r = e.morphAttributes;
            for (t in r) {
                var a = [],
                    o = r[t];
                for (i = 0, n = o.length; n > i; i++) a.push(o[i].clone());
                this.morphAttributes[t] = a
            }
            for (t = e.groups, i = 0, n = t.length; n > i; i++) r = t[i], this.addGroup(r.start, r.count, r.materialIndex);
            return t = e.boundingBox, null !== t && (this.boundingBox = t.clone()), t = e.boundingSphere, null !== t && (this.boundingSphere = t.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Et.prototype = Object.create(lt.prototype), Et.prototype.constructor = Et, Tt.prototype = Object.create(Mt.prototype), Tt.prototype.constructor = Tt, St.prototype = Object.create(lt.prototype), St.prototype.constructor = St, At.prototype = Object.create(Mt.prototype), At.prototype.constructor = At, Rt.prototype = Object.create(q.prototype), Rt.prototype.constructor = Rt, Rt.prototype.isMeshBasicMaterial = !0, Rt.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
    }, Object.assign(Lt.prototype, {
        set: function (e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        },
        at: function (e, t) {
            return (t || new c).copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function (e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        },
        recast: function () {
            var e = new c;
            return function (t) {
                return this.origin.copy(this.at(t, e)), this
            }
        }(),
        closestPointToPoint: function (e, t) {
            var i = t || new c;
            i.subVectors(e, this.origin);
            var n = i.dot(this.direction);
            return 0 > n ? i.copy(this.origin) : i.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function (e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function () {
            var e = new c;
            return function (t) {
                var i = e.subVectors(t, this.origin).dot(this.direction);
                return 0 > i ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(i).add(this.origin), e.distanceToSquared(t))
            }
        }(),
        distanceSqToSegment: function () {
            var e = new c,
                t = new c,
                i = new c;
            return function (n, r, a, o) {
                e.copy(n).add(r).multiplyScalar(.5), t.copy(r).sub(n).normalize(), i.copy(this.origin).sub(e);
                var s, c = .5 * n.distanceTo(r),
                    h = -this.direction.dot(t),
                    l = i.dot(this.direction),
                    u = -i.dot(t),
                    p = i.lengthSq(),
                    d = Math.abs(1 - h * h);
                return d > 0 ? (n = h * u - l, r = h * l - u, s = c * d, n >= 0 ? r >= -s ? s >= r ? (c = 1 / d, n *= c, r *= c, h = n * (n + h * r + 2 * l) + r * (h * n + r + 2 * u) + p) : (r = c, n = Math.max(0, -(h * r + l)), h = -n * n + r * (r + 2 * u) + p) : (r = -c, n = Math.max(0, -(h * r + l)), h = -n * n + r * (r + 2 * u) + p) : -s >= r ? (n = Math.max(0, -(-h * c + l)), r = n > 0 ? -c : Math.min(Math.max(-c, -u), c), h = -n * n + r * (r + 2 * u) + p) : s >= r ? (n = 0, r = Math.min(Math.max(-c, -u), c), h = r * (r + 2 * u) + p) : (n = Math.max(0, -(h * c + l)), r = n > 0 ? c : Math.min(Math.max(-c, -u), c), h = -n * n + r * (r + 2 * u) + p)) : (r = h > 0 ? -c : c, n = Math.max(0, -(h * r + l)), h = -n * n + r * (r + 2 * u) + p), a && a.copy(this.direction).multiplyScalar(n).add(this.origin), o && o.copy(t).multiplyScalar(r).add(e), h
            }
        }(),
        intersectSphere: function () {
            var e = new c;
            return function (t, i) {
                e.subVectors(t.center, this.origin);
                var n = e.dot(this.direction),
                    r = e.dot(e) - n * n,
                    a = t.radius * t.radius;
                return r > a ? null : (a = Math.sqrt(a - r), r = n - a, n += a, 0 > r && 0 > n ? null : 0 > r ? this.at(n, i) : this.at(r, i))
            }
        }(),
        intersectsSphere: function (e) {
            return this.distanceToPoint(e.center) <= e.radius
        },
        distanceToPlane: function (e) {
            var t = e.normal.dot(this.direction);
            return 0 === t ? 0 === e.distanceToPoint(this.origin) ? 0 : null : (e = -(this.origin.dot(e.normal) + e.constant) / t, e >= 0 ? e : null)
        },
        intersectPlane: function (e, t) {
            var i = this.distanceToPlane(e);
            return null === i ? null : this.at(i, t)
        },
        intersectsPlane: function (e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || 0 > e.normal.dot(this.direction) * t ? !0 : !1
        },
        intersectBox: function (e, t) {
            var i, n, r, a, o;
            n = 1 / this.direction.x, a = 1 / this.direction.y, o = 1 / this.direction.z;
            var s = this.origin;
            return n >= 0 ? (i = (e.min.x - s.x) * n, n *= e.max.x - s.x) : (i = (e.max.x - s.x) * n, n *= e.min.x - s.x), a >= 0 ? (r = (e.min.y - s.y) * a, a *= e.max.y - s.y) : (r = (e.max.y - s.y) * a, a *= e.min.y - s.y), i > a || r > n ? null : ((r > i || i !== i) && (i = r), (n > a || n !== n) && (n = a), o >= 0 ? (r = (e.min.z - s.z) * o, o *= e.max.z - s.z) : (r = (e.max.z - s.z) * o, o *= e.min.z - s.z), i > o || r > n ? null : ((r > i || i !== i) && (i = r), (n > o || n !== n) && (n = o), 0 > n ? null : this.at(i >= 0 ? i : n, t)))
        },
        intersectsBox: function () {
            var e = new c;
            return function (t) {
                return null !== this.intersectBox(t, e)
            }
        }(),
        intersectTriangle: function () {
            var e = new c,
                t = new c,
                i = new c,
                n = new c;
            return function (r, a, o, s, c) {
                if (t.subVectors(a, r), i.subVectors(o, r), n.crossVectors(t, i), a = this.direction.dot(n), a > 0) {
                    if (s) return null;
                    s = 1
                } else {
                    if (!(0 > a)) return null;
                    s = -1, a = -a
                }
                return e.subVectors(this.origin, r), r = s * this.direction.dot(i.crossVectors(e, i)), 0 > r ? null : (o = s * this.direction.dot(t.cross(e)), 0 > o || r + o > a ? null : (r = -s * e.dot(n), 0 > r ? null : this.at(r / a, c)))
            }
        }(),
        applyMatrix4: function (e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        },
        equals: function (e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }), Object.assign(Pt.prototype, {
        set: function (e, t) {
            return this.start.copy(e), this.end.copy(t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        },
        getCenter: function (e) {
            return (e || new c).addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function (e) {
            return (e || new c).subVectors(this.end, this.start)
        },
        distanceSq: function () {
            return this.start.distanceToSquared(this.end)
        },
        distance: function () {
            return this.start.distanceTo(this.end)
        },
        at: function (e, t) {
            var i = t || new c;
            return this.delta(i).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function () {
            var e = new c,
                t = new c;
            return function (i, n) {
                e.subVectors(i, this.start), t.subVectors(this.end, this.start);
                var r = t.dot(t),
                    r = t.dot(e) / r;
                return n && (r = _a.clamp(r, 0, 1)), r
            }
        }(),
        closestPointToPoint: function (e, t, i) {
            return e = this.closestPointToPointParameter(e, t), i = i || new c, this.delta(i).multiplyScalar(e).add(this.start)
        },
        applyMatrix4: function (e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        },
        equals: function (e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }), Object.assign(Ct, {
        normal: function () {
            var e = new c;
            return function (t, i, n, r) {
                return r = r || new c, r.subVectors(n, i), e.subVectors(t, i), r.cross(e), t = r.lengthSq(), t > 0 ? r.multiplyScalar(1 / Math.sqrt(t)) : r.set(0, 0, 0)
            }
        }(),
        barycoordFromPoint: function () {
            var e = new c,
                t = new c,
                i = new c;
            return function (n, r, a, o, s) {
                e.subVectors(o, r), t.subVectors(a, r), i.subVectors(n, r), n = e.dot(e), r = e.dot(t), a = e.dot(i);
                var h = t.dot(t);
                o = t.dot(i);
                var l = n * h - r * r;
                return s = s || new c, 0 === l ? s.set(-2, -1, -1) : (l = 1 / l, h = (h * a - r * o) * l, n = (n * o - r * a) * l, s.set(1 - h - n, n, h))
            }
        }(),
        containsPoint: function () {
            var e = new c;
            return function (t, i, n, r) {
                return t = Ct.barycoordFromPoint(t, i, n, r, e), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y
            }
        }()
    }), Object.assign(Ct.prototype, {
        set: function (e, t, i) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
        },
        setFromPointsAndIndices: function (e, t, i, n) {
            return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        },
        area: function () {
            var e = new c,
                t = new c;
            return function () {
                return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
            }
        }(),
        midpoint: function (e) {
            return (e || new c).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        normal: function (e) {
            return Ct.normal(this.a, this.b, this.c, e)
        },
        plane: function (e) {
            return (e || new $).setFromCoplanarPoints(this.a, this.b, this.c)
        },
        barycoordFromPoint: function (e, t) {
            return Ct.barycoordFromPoint(e, this.a, this.b, this.c, t)
        },
        containsPoint: function (e) {
            return Ct.containsPoint(e, this.a, this.b, this.c)
        },
        closestPointToPoint: function () {
            var e = new $,
                t = [new Pt, new Pt, new Pt],
                i = new c,
                n = new c;
            return function (r, a) {
                var o = a || new c,
                    s = 1 / 0;
                if (e.setFromCoplanarPoints(this.a, this.b, this.c), e.projectPoint(r, i), !0 === this.containsPoint(i)) o.copy(i);
                else {
                    t[0].set(this.a, this.b), t[1].set(this.b, this.c), t[2].set(this.c, this.a);
                    for (var h = 0; h < t.length; h++) {
                        t[h].closestPointToPoint(i, !0, n);
                        var l = i.distanceToSquared(n);
                        s > l && (s = l, o.copy(n))
                    }
                }
                return o
            }
        }(),
        equals: function (e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }), It.prototype = Object.assign(Object.create(at.prototype), {
        constructor: It,
        isMesh: !0,
        setDrawMode: function (e) {
            this.drawMode = e
        },
        copy: function (e) {
            return at.prototype.copy.call(this, e), this.drawMode = e.drawMode, this
        },
        updateMorphTargets: function () {
            var e, t, i = this.geometry;
            if (i.isBufferGeometry) {
                if (i = i.morphAttributes, e = Object.keys(i), 0 < e.length) {
                    var n = i[e[0]];
                    if (void 0 !== n)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, i = 0, e = n.length; e > i; i++) t = n[i].name || String(i), this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = i
                }
            } else if (n = i.morphTargets, void 0 !== n && 0 < n.length)
                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, i = 0, e = n.length; e > i; i++) t = n[i].name || String(i), this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = i
        },
        raycast: function () {
            function e(e, t, i, n, r, a, o) {
                return Ct.barycoordFromPoint(e, t, i, n, y), r.multiplyScalar(y.x), a.multiplyScalar(y.y), o.multiplyScalar(y.z), r.add(a).add(o), r.clone()
            }

            function t(e, t, i, n, r, a, o) {
                var s = e.material;
                return null === (1 === s.side ? i.intersectTriangle(a, r, n, !0, o) : i.intersectTriangle(n, r, a, 2 !== s.side, o)) ? null : (b.copy(o), b.applyMatrix4(e.matrixWorld), i = t.ray.origin.distanceTo(b), i < t.near || i > t.far ? null : {
                    distance: i,
                    point: b.clone(),
                    object: e
                })
            }

            function n(i, n, r, a, o, c, h, p) {
                return s.fromBufferAttribute(a, c), l.fromBufferAttribute(a, h), u.fromBufferAttribute(a, p), (i = t(i, n, r, s, l, u, x)) && (o && (m.fromBufferAttribute(o, c), g.fromBufferAttribute(o, h), v.fromBufferAttribute(o, p), i.uv = e(x, s, l, u, m, g, v)), i.face = new ht(c, h, p, Ct.normal(s, l, u)), i.faceIndex = c), i
            }
            var r = new h,
                a = new Lt,
                o = new Q,
                s = new c,
                l = new c,
                u = new c,
                p = new c,
                d = new c,
                f = new c,
                m = new i,
                g = new i,
                v = new i,
                y = new c,
                x = new c,
                b = new c;
            return function (i, c) {
                var h = this.geometry,
                    y = this.material,
                    b = this.matrixWorld;
                if (void 0 !== y && (null === h.boundingSphere && h.computeBoundingSphere(), o.copy(h.boundingSphere), o.applyMatrix4(b), !1 !== i.ray.intersectsSphere(o) && (r.getInverse(b), a.copy(i.ray).applyMatrix4(r), null === h.boundingBox || !1 !== a.intersectsBox(h.boundingBox)))) {
                    var _;
                    if (h.isBufferGeometry) {
                        var w, M, E, T, y = h.index,
                            S = h.attributes.position,
                            b = h.attributes.uv;
                        if (null !== y)
                            for (E = 0, T = y.count; T > E; E += 3) h = y.getX(E), w = y.getX(E + 1), M = y.getX(E + 2), (_ = n(this, i, a, S, b, h, w, M)) && (_.faceIndex = Math.floor(E / 3), c.push(_));
                        else
                            for (E = 0, T = S.count; T > E; E += 3) h = E, w = E + 1, M = E + 2, (_ = n(this, i, a, S, b, h, w, M)) && (_.index = h, c.push(_))
                    } else if (h.isGeometry) {
                        var A, b = Array.isArray(y);
                        E = h.vertices, T = h.faces, w = h.faceVertexUvs[0], 0 < w.length && (S = w);
                        for (var R = 0, L = T.length; L > R; R++) {
                            var P = T[R];
                            if (_ = b ? y[P.materialIndex] : y, void 0 !== _) {
                                if (w = E[P.a], M = E[P.b], A = E[P.c], !0 === _.morphTargets) {
                                    _ = h.morphTargets;
                                    var C = this.morphTargetInfluences;
                                    s.set(0, 0, 0), l.set(0, 0, 0), u.set(0, 0, 0);
                                    for (var I = 0, U = _.length; U > I; I++) {
                                        var N = C[I];
                                        if (0 !== N) {
                                            var D = _[I].vertices;
                                            s.addScaledVector(p.subVectors(D[P.a], w), N), l.addScaledVector(d.subVectors(D[P.b], M), N), u.addScaledVector(f.subVectors(D[P.c], A), N)
                                        }
                                    }
                                    s.add(w), l.add(M), u.add(A), w = s, M = l, A = u
                                }(_ = t(this, i, a, w, M, A, x)) && (S && S[R] && (C = S[R], m.copy(C[0]), g.copy(C[1]), v.copy(C[2]), _.uv = e(x, w, M, A, m, g, v)), _.face = P, _.faceIndex = R, c.push(_))
                            }
                        }
                    }
                }
            }
        }(),
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    });
    var Ba = 0;
    si.prototype = Object.assign(Object.create(ct.prototype), {
        constructor: si,
        isArrayCamera: !0
    }), pi.prototype.isFogExp2 = !0, pi.prototype.clone = function () {
        return new pi(this.color.getHex(), this.density)
    }, pi.prototype.toJSON = function () {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }, di.prototype.isFog = !0, di.prototype.clone = function () {
        return new di(this.color.getHex(), this.near, this.far)
    }, di.prototype.toJSON = function () {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }, fi.prototype = Object.assign(Object.create(at.prototype), {
        constructor: fi,
        copy: function (e, t) {
            return at.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
        },
        toJSON: function (e) {
            var t = at.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
        }
    }), mi.prototype = Object.assign(Object.create(at.prototype), {
        constructor: mi,
        isLensFlare: !0,
        copy: function (e) {
            at.prototype.copy.call(this, e), this.positionScreen.copy(e.positionScreen), this.customUpdateCallback = e.customUpdateCallback;
            for (var t = 0, i = e.lensFlares.length; i > t; t++) this.lensFlares.push(e.lensFlares[t]);
            return this
        },
        add: function (e, t, i, n, r, a) {
            void 0 === t && (t = -1), void 0 === i && (i = 0), void 0 === a && (a = 1), void 0 === r && (r = new k(16777215)), void 0 === n && (n = 1), i = Math.min(i, Math.max(0, i)), this.lensFlares.push({
                texture: e,
                size: t,
                distance: i,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: a,
                color: r,
                blending: n
            })
        },
        updateLensFlares: function () {
            var e, t, i = this.lensFlares.length,
                n = 2 * -this.positionScreen.x,
                r = 2 * -this.positionScreen.y;
            for (e = 0; i > e; e++) t = this.lensFlares[e], t.x = this.positionScreen.x + n * t.distance, t.y = this.positionScreen.y + r * t.distance, t.wantedRotation = t.x * Math.PI * .25, t.rotation += .25 * (t.wantedRotation - t.rotation)
        }
    }), gi.prototype = Object.create(q.prototype), gi.prototype.constructor = gi, gi.prototype.isSpriteMaterial = !0, gi.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this
    }, vi.prototype = Object.assign(Object.create(at.prototype), {
        constructor: vi,
        isSprite: !0,
        raycast: function () {
            var e = new c,
                t = new c,
                i = new c;
            return function (n, r) {
                t.setFromMatrixPosition(this.matrixWorld), n.ray.closestPointToPoint(t, e), i.setFromMatrixScale(this.matrixWorld);
                var a = i.x * i.y / 4;
                t.distanceToSquared(e) > a || (a = n.ray.origin.distanceTo(e), a < n.near || a > n.far || r.push({
                    distance: a,
                    point: e.clone(),
                    face: null,
                    object: this
                }))
            }
        }(),
        clone: function () {
            return new this.constructor(this.material).copy(this)
        }
    }), yi.prototype = Object.assign(Object.create(at.prototype), {
        constructor: yi,
        copy: function (e) {
            at.prototype.copy.call(this, e, !1), e = e.levels;
            for (var t = 0, i = e.length; i > t; t++) {
                var n = e[t];
                this.addLevel(n.object.clone(), n.distance)
            }
            return this
        },
        addLevel: function (e, t) {
            void 0 === t && (t = 0), t = Math.abs(t);
            for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++);
            i.splice(n, 0, {
                distance: t,
                object: e
            }), this.add(e)
        },
        getObjectForDistance: function (e) {
            for (var t = this.levels, i = 1, n = t.length; n > i && !(e < t[i].distance); i++);
            return t[i - 1].object
        },
        raycast: function () {
            var e = new c;
            return function (t, i) {
                e.setFromMatrixPosition(this.matrixWorld);
                var n = t.ray.origin.distanceTo(e);
                this.getObjectForDistance(n).raycast(t, i)
            }
        }(),
        update: function () {
            var e = new c,
                t = new c;
            return function (i) {
                var n = this.levels;
                if (1 < n.length) {
                    e.setFromMatrixPosition(i.matrixWorld), t.setFromMatrixPosition(this.matrixWorld), i = e.distanceTo(t), n[0].object.visible = !0;
                    for (var r = 1, a = n.length; a > r && i >= n[r].distance; r++) n[r - 1].object.visible = !1, n[r].object.visible = !0;
                    for (; a > r; r++) n[r].object.visible = !1
                }
            }
        }(),
        toJSON: function (e) {
            e = at.prototype.toJSON.call(this, e), e.object.levels = [];
            for (var t = this.levels, i = 0, n = t.length; n > i; i++) {
                var r = t[i];
                e.object.levels.push({
                    object: r.object.uuid,
                    distance: r.distance
                })
            }
            return e
        }
    }), Object.assign(xi.prototype, {
        calculateInverses: function () {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; t > e; e++) {
                var i = new h;
                this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i)
            }
        },
        pose: function () {
            var e, t, i;
            for (t = 0, i = this.bones.length; i > t; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0, i = this.bones.length; i > t; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: function () {
            var e = new h,
                t = new h;
            return function () {
                for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, a = this.boneTexture, o = 0, s = i.length; s > o; o++) e.multiplyMatrices(i[o] ? i[o].matrixWorld : t, n[o]), e.toArray(r, 16 * o);
                void 0 !== a && (a.needsUpdate = !0)
            }
        }(),
        clone: function () {
            return new xi(this.bones, this.boneInverses)
        }
    }), bi.prototype = Object.assign(Object.create(at.prototype), {
        constructor: bi,
        isBone: !0
    }), _i.prototype = Object.assign(Object.create(It.prototype), {
        constructor: _i,
        isSkinnedMesh: !0,
        initBones: function () {
            var e, t, i, n, r = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (i = 0, n = this.geometry.bones.length; n > i; i++) t = this.geometry.bones[i], e = new bi, r.push(e), e.name = t.name, e.position.fromArray(t.pos), e.quaternion.fromArray(t.rotq), void 0 !== t.scl && e.scale.fromArray(t.scl);
                for (i = 0, n = this.geometry.bones.length; n > i; i++) t = this.geometry.bones[i], -1 !== t.parent && null !== t.parent && void 0 !== r[t.parent] ? r[t.parent].add(r[i]) : this.add(r[i])
            }
            return this.updateMatrixWorld(!0), r
        },
        bind: function (e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
        },
        pose: function () {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function () {
            var e, t;
            if (this.geometry && this.geometry.isGeometry)
                for (t = 0; t < this.geometry.skinWeights.length; t++) {
                    var i = this.geometry.skinWeights[t];
                    e = 1 / i.lengthManhattan(), 1 / 0 !== e ? i.multiplyScalar(e) : i.set(1, 0, 0, 0)
                } else if (this.geometry && this.geometry.isBufferGeometry) {
                    var i = new r,
                        n = this.geometry.attributes.skinWeight;
                    for (t = 0; t < n.count; t++) i.x = n.getX(t), i.y = n.getY(t), i.z = n.getZ(t), i.w = n.getW(t), e = 1 / i.lengthManhattan(), 1 / 0 !== e ? i.multiplyScalar(e) : i.set(1, 0, 0, 0), n.setXYZW(t, i.x, i.y, i.z, i.w)
                }
        },
        updateMatrixWorld: function (e) {
            It.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), wi.prototype = Object.create(q.prototype), wi.prototype.constructor = wi, wi.prototype.isLineBasicMaterial = !0, wi.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
    }, Mi.prototype = Object.assign(Object.create(at.prototype), {
        constructor: Mi,
        isLine: !0,
        raycast: function () {
            var e = new h,
                t = new Lt,
                i = new Q;
            return function (n, r) {
                var a = n.linePrecision,
                    a = a * a,
                    o = this.geometry,
                    s = this.matrixWorld;
                if (null === o.boundingSphere && o.computeBoundingSphere(), i.copy(o.boundingSphere), i.applyMatrix4(s), !1 !== n.ray.intersectsSphere(i)) {
                    e.getInverse(s), t.copy(n.ray).applyMatrix4(e);
                    var h = new c,
                        l = new c,
                        s = new c,
                        u = new c,
                        p = this && this.isLineSegments ? 2 : 1;
                    if (o.isBufferGeometry) {
                        var d = o.index,
                            f = o.attributes.position.array;
                        if (null !== d)
                            for (var d = d.array, o = 0, m = d.length - 1; m > o; o += p) {
                                var g = d[o + 1];
                                h.fromArray(f, 3 * d[o]), l.fromArray(f, 3 * g), g = t.distanceSqToSegment(h, l, u, s), g > a || (u.applyMatrix4(this.matrixWorld), g = n.ray.origin.distanceTo(u), g < n.near || g > n.far || r.push({
                                    distance: g,
                                    point: s.clone().applyMatrix4(this.matrixWorld),
                                    index: o,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            } else
                                for (o = 0, m = f.length / 3 - 1; m > o; o += p) h.fromArray(f, 3 * o), l.fromArray(f, 3 * o + 3), g = t.distanceSqToSegment(h, l, u, s), g > a || (u.applyMatrix4(this.matrixWorld), g = n.ray.origin.distanceTo(u), g < n.near || g > n.far || r.push({
                                    distance: g,
                                    point: s.clone().applyMatrix4(this.matrixWorld),
                                    index: o,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                    } else if (o.isGeometry)
                        for (h = o.vertices, l = h.length, o = 0; l - 1 > o; o += p) g = t.distanceSqToSegment(h[o], h[o + 1], u, s), g > a || (u.applyMatrix4(this.matrixWorld), g = n.ray.origin.distanceTo(u), g < n.near || g > n.far || r.push({
                            distance: g,
                            point: s.clone().applyMatrix4(this.matrixWorld),
                            index: o,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                }
            }
        }(),
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Ei.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: Ei,
        isLineSegments: !0
    }), Ti.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: Ti,
        isLineLoop: !0
    }), Si.prototype = Object.create(q.prototype), Si.prototype.constructor = Si, Si.prototype.isPointsMaterial = !0, Si.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
    }, Ai.prototype = Object.assign(Object.create(at.prototype), {
        constructor: Ai,
        isPoints: !0,
        raycast: function () {
            var e = new h,
                t = new Lt,
                i = new Q;
            return function (n, r) {
                function a(e, i) {
                    var a = t.distanceSqToPoint(e);
                    if (u > a) {
                        var s = t.closestPointToPoint(e);
                        s.applyMatrix4(h);
                        var c = n.ray.origin.distanceTo(s);
                        c < n.near || c > n.far || r.push({
                            distance: c,
                            distanceToRay: Math.sqrt(a),
                            point: s.clone(),
                            index: i,
                            face: null,
                            object: o
                        })
                    }
                }
                var o = this,
                    s = this.geometry,
                    h = this.matrixWorld,
                    l = n.params.Points.threshold;
                if (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(h), i.radius += l, !1 !== n.ray.intersectsSphere(i)) {
                    e.getInverse(h), t.copy(n.ray).applyMatrix4(e);
                    var l = l / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        u = l * l,
                        l = new c;
                    if (s.isBufferGeometry) {
                        var p = s.index,
                            s = s.attributes.position.array;
                        if (null !== p)
                            for (var d = p.array, p = 0, f = d.length; f > p; p++) {
                                var m = d[p];
                                l.fromArray(s, 3 * m), a(l, m)
                            } else
                                for (p = 0, d = s.length / 3; d > p; p++) l.fromArray(s, 3 * p), a(l, p)
                    } else
                        for (l = s.vertices, p = 0, d = l.length; d > p; p++) a(l[p], p)
                }
            }
        }(),
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Ri.prototype = Object.assign(Object.create(at.prototype), {
        constructor: Ri
    }), Li.prototype = Object.create(n.prototype), Li.prototype.constructor = Li, Pi.prototype = Object.create(n.prototype), Pi.prototype.constructor = Pi, Pi.prototype.isCompressedTexture = !0, Ci.prototype = Object.create(n.prototype), Ci.prototype.constructor = Ci, Ii.prototype = Object.create(n.prototype), Ii.prototype.constructor = Ii, Ii.prototype.isDepthTexture = !0, Ui.prototype = Object.create(Mt.prototype), Ui.prototype.constructor = Ui, Ni.prototype = Object.create(lt.prototype), Ni.prototype.constructor = Ni, Di.prototype = Object.create(Mt.prototype), Di.prototype.constructor = Di, Oi.prototype = Object.create(lt.prototype), Oi.prototype.constructor = Oi, Fi.prototype = Object.create(Mt.prototype), Fi.prototype.constructor = Fi, Bi.prototype = Object.create(lt.prototype), Bi.prototype.constructor = Bi, zi.prototype = Object.create(Fi.prototype), zi.prototype.constructor = zi, Gi.prototype = Object.create(lt.prototype), Gi.prototype.constructor = Gi, Hi.prototype = Object.create(Fi.prototype), Hi.prototype.constructor = Hi, Vi.prototype = Object.create(lt.prototype), Vi.prototype.constructor = Vi, ki.prototype = Object.create(Fi.prototype), ki.prototype.constructor = ki, ji.prototype = Object.create(lt.prototype), ji.prototype.constructor = ji, Wi.prototype = Object.create(Fi.prototype), Wi.prototype.constructor = Wi, Xi.prototype = Object.create(lt.prototype), Xi.prototype.constructor = Xi, qi.prototype = Object.create(Mt.prototype), qi.prototype.constructor = qi, Yi.prototype = Object.create(lt.prototype), Yi.prototype.constructor = Yi, Zi.prototype = Object.create(Mt.prototype), Zi.prototype.constructor = Zi, Ji.prototype = Object.create(lt.prototype), Ji.prototype.constructor = Ji, Qi.prototype = Object.create(Mt.prototype), Qi.prototype.constructor = Qi;
    var za = {
        area: function (e) {
            for (var t = e.length, i = 0, n = t - 1, r = 0; t > r; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
            return .5 * i
        },
        triangulate: function () {
            return function (e, t) {
                var i = e.length;
                if (3 > i) return null;
                var n, r, a, o = [],
                    s = [],
                    c = [];
                if (0 < za.area(e))
                    for (r = 0; i > r; r++) s[r] = r;
                else
                    for (r = 0; i > r; r++) s[r] = i - 1 - r;
                var h = 2 * i;
                for (r = i - 1; i > 2;) {
                    if (0 >= h--) {
                        console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
                        break
                    }
                    n = r, n >= i && (n = 0), r = n + 1, r >= i && (r = 0), a = r + 1, a >= i && (a = 0);
                    var l;
                    e: {
                        var u, p, d, f, m, g, v, y;
                        if (u = e[s[n]].x, p = e[s[n]].y, d = e[s[r]].x, f = e[s[r]].y, m = e[s[a]].x, g = e[s[a]].y, 0 >= (d - u) * (g - p) - (f - p) * (m - u)) l = !1;
                        else {
                            var x, b, _, w, M, E, T, S, A, R;
                            for (x = m - d, b = g - f, _ = u - m, w = p - g, M = d - u, E = f - p, l = 0; i > l; l++)
                                if (v = e[s[l]].x, y = e[s[l]].y, !(v === u && y === p || v === d && y === f || v === m && y === g) && (T = v - u, S = y - p, A = v - d, R = y - f, v -= m, y -= g, A = x * R - b * A, T = M * S - E * T, S = _ * y - w * v, A >= -Number.EPSILON && S >= -Number.EPSILON && T >= -Number.EPSILON)) {
                                    l = !1;
                                    break e
                                }
                            l = !0
                        }
                    }
                    if (l) {
                        for (o.push([e[s[n]], e[s[r]], e[s[a]]]), c.push([s[n], s[r], s[a]]), n = r, a = r + 1; i > a; n++, a++) s[n] = s[a];
                        i--, h = 2 * i
                    }
                }
                return t ? c : o
            }
        }(),
        triangulateShape: function (e, t) {
            function i(e) {
                var t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function n(e, t, i) {
                return e.x !== t.x ? e.x < t.x ? e.x <= i.x && i.x <= t.x : t.x <= i.x && i.x <= e.x : e.y < t.y ? e.y <= i.y && i.y <= t.y : t.y <= i.y && i.y <= e.y
            }

            function r(e, t, i, r, a) {
                var o = t.x - e.x,
                    s = t.y - e.y,
                    c = r.x - i.x,
                    h = r.y - i.y,
                    l = e.x - i.x,
                    u = e.y - i.y,
                    p = s * c - o * h,
                    d = s * l - o * u;
                if (Math.abs(p) > Number.EPSILON) {
                    if (p > 0) {
                        if (0 > d || d > p) return [];
                        if (c = h * l - c * u, 0 > c || c > p) return []
                    } else {
                        if (d > 0 || p > d) return [];
                        if (c = h * l - c * u, c > 0 || p > c) return []
                    }
                    return 0 === c ? !a || 0 !== d && d !== p ? [e] : [] : c === p ? !a || 0 !== d && d !== p ? [t] : [] : 0 === d ? [i] : d === p ? [r] : (a = c / p, [{
                        x: e.x + a * o,
                        y: e.y + a * s
                    }])
                }
                return 0 !== d || h * l !== c * u ? [] : (s = 0 === o && 0 === s, c = 0 === c && 0 === h, s && c ? e.x !== i.x || e.y !== i.y ? [] : [e] : s ? n(i, r, e) ? [e] : [] : c ? n(e, t, i) ? [i] : [] : (0 !== o ? (e.x < t.x ? (o = e, c = e.x, s = t, e = t.x) : (o = t, c = t.x, s = e, e = e.x), i.x < r.x ? (t = i, p = i.x, h = r, i = r.x) : (t = r, p = r.x, h = i, i = i.x)) : (e.y < t.y ? (o = e, c = e.y, s = t, e = t.y) : (o = t, c = t.y, s = e, e = e.y), i.y < r.y ? (t = i, p = i.y, h = r, i = r.y) : (t = r, p = r.y, h = i, i = i.y)), p >= c ? p > e ? [] : e === p ? a ? [] : [t] : i >= e ? [t, s] : [t, h] : c > i ? [] : c === i ? a ? [] : [o] : i >= e ? [o, s] : [o, h]))
            }

            function a(e, t, i, n) {
                var r = t.x - e.x,
                    a = t.y - e.y;
                t = i.x - e.x, i = i.y - e.y;
                var o = n.x - e.x;
                return n = n.y - e.y, e = r * i - a * t, r = r * n - a * o, Math.abs(e) > Number.EPSILON ? (t = o * i - n * t, e > 0 ? r >= 0 && t >= 0 : r >= 0 || t >= 0) : r > 0
            }
            i(e), t.forEach(i);
            var o, s, c, h, l, u = {};
            for (c = e.concat(), o = 0, s = t.length; s > o; o++) Array.prototype.push.apply(c, t[o]);
            for (o = 0, s = c.length; s > o; o++) l = c[o].x + ":" + c[o].y, void 0 !== u[l] && console.warn("THREE.ShapeUtils: Duplicate point", l, o), u[l] = o;
            o = function (e, t) {
                function i(e, t) {
                    var i = g.length - 1,
                        n = e - 1;
                    0 > n && (n = i);
                    var r = e + 1;
                    return r > i && (r = 0), (i = a(g[e], g[n], g[r], s[t])) ? (i = s.length - 1, n = t - 1, 0 > n && (n = i), r = t + 1, r > i && (r = 0), (i = a(s[t], s[n], s[r], g[e])) ? !0 : !1) : !1
                }

                function n(e, t) {
                    var i, n;
                    for (i = 0; i < g.length; i++)
                        if (n = i + 1, n %= g.length, n = r(e, t, g[i], g[n], !0), 0 < n.length) return !0;
                    return !1
                }

                function o(e, i) {
                    var n, a, o, s;
                    for (n = 0; n < v.length; n++)
                        for (a = t[v[n]], o = 0; o < a.length; o++)
                            if (s = o + 1, s %= a.length, s = r(e, i, a[o], a[s], !0), 0 < s.length) return !0;
                    return !1
                }
                var s, c, h, l, u, p, d, f, m, g = e.concat(),
                    v = [],
                    y = [],
                    x = 0;
                for (c = t.length; c > x; x++) v.push(x);
                d = 0;
                for (var b = 2 * v.length; 0 < v.length;) {
                    if (b--, 0 > b) {
                        console.log("Infinite Loop! Holes left:" + v.length + ", Probably Hole outside Shape!");
                        break
                    }
                    for (h = d; h < g.length; h++) {
                        for (l = g[h], c = -1, x = 0; x < v.length; x++)
                            if (u = v[x], p = l.x + ":" + l.y + ":" + u, void 0 === y[p]) {
                                for (s = t[u], f = 0; f < s.length; f++)
                                    if (u = s[f], i(h, f) && !n(l, u) && !o(l, u)) {
                                        c = f, v.splice(x, 1), d = g.slice(0, h + 1), u = g.slice(h), f = s.slice(c), m = s.slice(0, c + 1), g = d.concat(f).concat(m).concat(u), d = h;
                                        break
                                    }
                                if (c >= 0) break;
                                y[p] = !0
                            }
                        if (c >= 0) break
                    }
                }
                return g
            }(e, t);
            var p = za.triangulate(o, !1);
            for (o = 0, s = p.length; s > o; o++)
                for (h = p[o], c = 0; 3 > c; c++) l = h[c].x + ":" + h[c].y, l = u[l], void 0 !== l && (h[c] = l);
            return p.concat()
        },
        isClockWise: function (e) {
            return 0 > za.area(e)
        }
    };
    Ki.prototype = Object.create(lt.prototype), Ki.prototype.constructor = Ki, $i.prototype = Object.create(Mt.prototype), $i.prototype.constructor = $i, $i.prototype.getArrays = function () {
        var e = this.getAttribute("position"),
            e = e ? Array.prototype.slice.call(e.array) : [],
            t = this.getAttribute("uv"),
            t = t ? Array.prototype.slice.call(t.array) : [],
            i = this.index,
            i = i ? Array.prototype.slice.call(i.array) : [];
        return {
            position: e,
            uv: t,
            index: i
        }
    }, $i.prototype.addShapeList = function (e, t) {
        var i = e.length;
        t.arrays = this.getArrays();
        for (var n = 0; i > n; n++) this.addShape(e[n], t);
        this.setIndex(t.arrays.index), this.addAttribute("position", new xt(t.arrays.position, 3)), this.addAttribute("uv", new xt(t.arrays.uv, 2))
    }, $i.prototype.addShape = function (e, t) {
        function n(e, t, i) {
            return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e)
        }

        function r(e, t, n) {
            var r, a, o;
            a = e.x - t.x, o = e.y - t.y, r = n.x - e.x;
            var s = n.y - e.y,
                c = a * a + o * o;
            if (Math.abs(a * s - o * r) > Number.EPSILON) {
                var h = Math.sqrt(c),
                    l = Math.sqrt(r * r + s * s),
                    c = t.x - o / h;
                if (t = t.y + a / h, s = ((n.x - s / l - c) * s - (n.y + r / l - t) * r) / (a * s - o * r), r = c + a * s - e.x, a = t + o * s - e.y, o = r * r + a * a, 2 >= o) return new i(r, a);
                o = Math.sqrt(o / 2)
            } else e = !1, a > Number.EPSILON ? r > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? r < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(s) && (e = !0), e ? (r = -o, o = Math.sqrt(c)) : (r = a, a = o, o = Math.sqrt(c / 2));
            return new i(r / o, a / o)
        }

        function a(e, t) {
            var i, n;
            for (W = e.length; 0 <= --W;) {
                i = W, n = W - 1, 0 > n && (n = e.length - 1);
                var r, a = S + 2 * M;
                for (r = 0; a > r; r++) {
                    var o = k * r,
                        s = k * (r + 1),
                        c = t + n + o,
                        u = t + n + s,
                        s = t + i + s;
                    h(t + i + o), h(c), h(s), h(c), h(u), h(s), o = v.length / 3, o = L.generateSideWallUV(U, v, o - 6, o - 3, o - 2, o - 1), l(o[0]), l(o[1]), l(o[3]), l(o[1]), l(o[2]), l(o[3])
                }
            }
        }

        function o(e, t, i) {
            b.push(e), b.push(t), b.push(i)
        }

        function s(e, t, i) {
            h(e), h(t), h(i), e = v.length / 3, e = L.generateTopUV(U, v, e - 3, e - 2, e - 1), l(e[0]), l(e[1]), l(e[2])
        }

        function h(e) {
            y.push(v.length / 3), v.push(b[3 * e + 0]), v.push(b[3 * e + 1]), v.push(b[3 * e + 2])
        }

        function l(e) {
            x.push(e.x), x.push(e.y)
        }
        var u, p, d, f, m, g = t.arrays ? t.arrays : this.getArrays(),
            v = g.position,
            y = g.index,
            x = g.uv,
            b = [],
            g = void 0 !== t.amount ? t.amount : 100,
            _ = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
            w = void 0 !== t.bevelSize ? t.bevelSize : _ - 2,
            M = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
            E = void 0 !== t.bevelEnabled ? t.bevelEnabled : !0,
            T = void 0 !== t.curveSegments ? t.curveSegments : 12,
            S = void 0 !== t.steps ? t.steps : 1,
            A = t.extrudePath,
            R = !1,
            L = void 0 !== t.UVGenerator ? t.UVGenerator : Ki.WorldUVGenerator;
        A && (u = A.getSpacedPoints(S), R = !0, E = !1, p = void 0 !== t.frames ? t.frames : A.computeFrenetFrames(S, !1), d = new c, f = new c, m = new c), E || (w = _ = M = 0);
        var P, C, I, U = this,
            A = e.extractPoints(T),
            T = A.shape,
            N = A.holes;
        if (!za.isClockWise(T))
            for (T = T.reverse(), C = 0, I = N.length; I > C; C++) P = N[C], za.isClockWise(P) && (N[C] = P.reverse());
        var D = za.triangulateShape(T, N),
            O = T;
        for (C = 0, I = N.length; I > C; C++) P = N[C], T = T.concat(P);
        var F, B, z, G, H, V, k = T.length,
            j = D.length,
            A = [],
            W = 0;
        for (z = O.length, F = z - 1, B = W + 1; z > W; W++, F++, B++) F === z && (F = 0), B === z && (B = 0), A[W] = r(O[W], O[F], O[B]);
        var X, q = [],
            Y = A.concat();
        for (C = 0, I = N.length; I > C; C++) {
            for (P = N[C], X = [], W = 0, z = P.length, F = z - 1, B = W + 1; z > W; W++, F++, B++) F === z && (F = 0), B === z && (B = 0), X[W] = r(P[W], P[F], P[B]);
            q.push(X), Y = Y.concat(X)
        }
        for (F = 0; M > F; F++) {
            for (z = F / M, G = _ * Math.cos(z * Math.PI / 2), B = w * Math.sin(z * Math.PI / 2), W = 0, z = O.length; z > W; W++) H = n(O[W], A[W], B), o(H.x, H.y, -G);
            for (C = 0, I = N.length; I > C; C++)
                for (P = N[C], X = q[C], W = 0, z = P.length; z > W; W++) H = n(P[W], X[W], B), o(H.x, H.y, -G)
        }
        for (B = w, W = 0; k > W; W++) H = E ? n(T[W], Y[W], B) : T[W], R ? (f.copy(p.normals[0]).multiplyScalar(H.x), d.copy(p.binormals[0]).multiplyScalar(H.y), m.copy(u[0]).add(f).add(d), o(m.x, m.y, m.z)) : o(H.x, H.y, 0);
        for (z = 1; S >= z; z++)
            for (W = 0; k > W; W++) H = E ? n(T[W], Y[W], B) : T[W], R ? (f.copy(p.normals[z]).multiplyScalar(H.x), d.copy(p.binormals[z]).multiplyScalar(H.y), m.copy(u[z]).add(f).add(d), o(m.x, m.y, m.z)) : o(H.x, H.y, g / S * z);
        for (F = M - 1; F >= 0; F--) {
            for (z = F / M, G = _ * Math.cos(z * Math.PI / 2), B = w * Math.sin(z * Math.PI / 2), W = 0, z = O.length; z > W; W++) H = n(O[W], A[W], B), o(H.x, H.y, g + G);
            for (C = 0, I = N.length; I > C; C++)
                for (P = N[C], X = q[C], W = 0, z = P.length; z > W; W++) H = n(P[W], X[W], B), R ? o(H.x, H.y + u[S - 1].y, u[S - 1].x + G) : o(H.x, H.y, g + G)
        }! function () {
            var e = v.length / 3;
            if (E) {
                var i = 0 * k;
                for (W = 0; j > W; W++) V = D[W], s(V[2] + i, V[1] + i, V[0] + i);
                for (i = k * (S + 2 * M), W = 0; j > W; W++) V = D[W], s(V[0] + i, V[1] + i, V[2] + i)
            } else {
                for (W = 0; j > W; W++) V = D[W], s(V[2], V[1], V[0]);
                for (W = 0; j > W; W++) V = D[W], s(V[0] + k * S, V[1] + k * S, V[2] + k * S)
            }
            U.addGroup(e, v.length / 3 - e, void 0 !== t.material ? t.material : 0)
        }(),
        function () {
            var e = v.length / 3,
                i = 0;
            for (a(O, i), i += O.length, C = 0, I = N.length; I > C; C++) P = N[C], a(P, i), i += P.length;
            U.addGroup(e, v.length / 3 - e, void 0 !== t.extrudeMaterial ? t.extrudeMaterial : 1)
        }(), t.arrays || (this.setIndex(y), this.addAttribute("position", new xt(v, 3)), this.addAttribute("uv", new xt(t.arrays.uv, 2)))
    }, Ki.WorldUVGenerator = {
        generateTopUV: function (e, t, n, r, a) {
            e = t[3 * r], r = t[3 * r + 1];
            var o = t[3 * a];
            return a = t[3 * a + 1], [new i(t[3 * n], t[3 * n + 1]), new i(e, r), new i(o, a)]
        },
        generateSideWallUV: function (e, t, n, r, a, o) {
            e = t[3 * n];
            var s = t[3 * n + 1];
            n = t[3 * n + 2];
            var c = t[3 * r],
                h = t[3 * r + 1];
            r = t[3 * r + 2];
            var l = t[3 * a],
                u = t[3 * a + 1];
            a = t[3 * a + 2];
            var p = t[3 * o],
                d = t[3 * o + 1];
            return t = t[3 * o + 2], .01 > Math.abs(s - h) ? [new i(e, 1 - n), new i(c, 1 - r), new i(l, 1 - a), new i(p, 1 - t)] : [new i(s, 1 - n), new i(h, 1 - r), new i(u, 1 - a), new i(d, 1 - t)]
        }
    }, en.prototype = Object.create(lt.prototype), en.prototype.constructor = en, tn.prototype = Object.create($i.prototype), tn.prototype.constructor = tn, nn.prototype = Object.create(lt.prototype), nn.prototype.constructor = nn, rn.prototype = Object.create(Mt.prototype), rn.prototype.constructor = rn, an.prototype = Object.create(lt.prototype), an.prototype.constructor = an, on.prototype = Object.create(Mt.prototype), on.prototype.constructor = on, sn.prototype = Object.create(lt.prototype), sn.prototype.constructor = sn, cn.prototype = Object.create(Mt.prototype), cn.prototype.constructor = cn, hn.prototype = Object.create(lt.prototype), hn.prototype.constructor = hn, ln.prototype = Object.create(Mt.prototype), ln.prototype.constructor = ln, un.prototype = Object.create(Mt.prototype), un.prototype.constructor = un, pn.prototype = Object.create(lt.prototype), pn.prototype.constructor = pn, dn.prototype = Object.create(Mt.prototype), dn.prototype.constructor = dn, fn.prototype = Object.create(pn.prototype), fn.prototype.constructor = fn, mn.prototype = Object.create(dn.prototype), mn.prototype.constructor = mn, gn.prototype = Object.create(lt.prototype), gn.prototype.constructor = gn, vn.prototype = Object.create(Mt.prototype), vn.prototype.constructor = vn;
    var Ga = Object.freeze({
        WireframeGeometry: Ui,
        ParametricGeometry: Ni,
        ParametricBufferGeometry: Di,
        TetrahedronGeometry: Bi,
        TetrahedronBufferGeometry: zi,
        OctahedronGeometry: Gi,
        OctahedronBufferGeometry: Hi,
        IcosahedronGeometry: Vi,
        IcosahedronBufferGeometry: ki,
        DodecahedronGeometry: ji,
        DodecahedronBufferGeometry: Wi,
        PolyhedronGeometry: Oi,
        PolyhedronBufferGeometry: Fi,
        TubeGeometry: Xi,
        TubeBufferGeometry: qi,
        TorusKnotGeometry: Yi,
        TorusKnotBufferGeometry: Zi,
        TorusGeometry: Ji,
        TorusBufferGeometry: Qi,
        TextGeometry: en,
        TextBufferGeometry: tn,
        SphereGeometry: nn,
        SphereBufferGeometry: rn,
        RingGeometry: an,
        RingBufferGeometry: on,
        PlaneGeometry: St,
        PlaneBufferGeometry: At,
        LatheGeometry: sn,
        LatheBufferGeometry: cn,
        ShapeGeometry: hn,
        ShapeBufferGeometry: ln,
        ExtrudeGeometry: Ki,
        ExtrudeBufferGeometry: $i,
        EdgesGeometry: un,
        ConeGeometry: fn,
        ConeBufferGeometry: mn,
        CylinderGeometry: pn,
        CylinderBufferGeometry: dn,
        CircleGeometry: gn,
        CircleBufferGeometry: vn,
        BoxGeometry: Et,
        BoxBufferGeometry: Tt
    });
    yn.prototype = Object.create(Y.prototype), yn.prototype.constructor = yn, yn.prototype.isShadowMaterial = !0, xn.prototype = Object.create(Y.prototype), xn.prototype.constructor = xn, xn.prototype.isRawShaderMaterial = !0, bn.prototype = Object.create(q.prototype), bn.prototype.constructor = bn, bn.prototype.isMeshStandardMaterial = !0, bn.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, _n.prototype = Object.create(bn.prototype), _n.prototype.constructor = _n, _n.prototype.isMeshPhysicalMaterial = !0, _n.prototype.copy = function (e) {
        return bn.prototype.copy.call(this, e), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
    }, wn.prototype = Object.create(q.prototype), wn.prototype.constructor = wn, wn.prototype.isMeshPhongMaterial = !0, wn.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Mn.prototype = Object.create(wn.prototype), Mn.prototype.constructor = Mn, Mn.prototype.isMeshToonMaterial = !0, Mn.prototype.copy = function (e) {
        return wn.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
    }, En.prototype = Object.create(q.prototype), En.prototype.constructor = En, En.prototype.isMeshNormalMaterial = !0, En.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Tn.prototype = Object.create(q.prototype), Tn.prototype.constructor = Tn, Tn.prototype.isMeshLambertMaterial = !0, Tn.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Sn.prototype = Object.create(q.prototype), Sn.prototype.constructor = Sn, Sn.prototype.isLineDashedMaterial = !0, Sn.prototype.copy = function (e) {
        return q.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    };
    var Ha = Object.freeze({
            ShadowMaterial: yn,
            SpriteMaterial: gi,
            RawShaderMaterial: xn,
            ShaderMaterial: Y,
            PointsMaterial: Si,
            MeshPhysicalMaterial: _n,
            MeshStandardMaterial: bn,
            MeshPhongMaterial: wn,
            MeshToonMaterial: Mn,
            MeshNormalMaterial: En,
            MeshLambertMaterial: Tn,
            MeshDepthMaterial: Z,
            MeshBasicMaterial: Rt,
            LineDashedMaterial: Sn,
            LineBasicMaterial: wi,
            Material: q
        }),
        Va = {
            enabled: !1,
            files: {},
            add: function (e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function (e) {
                return !1 !== this.enabled ? this.files[e] : void 0
            },
            remove: function (e) {
                delete this.files[e]
            },
            clear: function () {
                this.files = {}
            }
        },
        ka = new An;
    Object.assign(Rn.prototype, {
        load: function (e, t, i, n) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e);
            var r = this,
                a = Va.get(e);
            if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function () {
                t && t(a), r.manager.itemEnd(e)
            }, 0), a;
            var o = e.match(/^data:(.*?)(;base64)?,(.*)$/);
            if (o) {
                var s = o[1],
                    c = !!o[2],
                    o = o[3],
                    o = window.decodeURIComponent(o);
                c && (o = window.atob(o));
                try {
                    var h, l = (this.responseType || "").toLowerCase();
                    switch (l) {
                        case "arraybuffer":
                        case "blob":
                            h = new ArrayBuffer(o.length);
                            for (var u = new Uint8Array(h), c = 0; c < o.length; c++) u[c] = o.charCodeAt(c);
                            "blob" === l && (h = new Blob([h], {
                                type: s
                            }));
                            break;
                        case "document":
                            h = (new DOMParser).parseFromString(o, s);
                            break;
                        case "json":
                            h = JSON.parse(o);
                            break;
                        default:
                            h = o
                    }
                    window.setTimeout(function () {
                        t && t(h), r.manager.itemEnd(e)
                    }, 0)
                } catch (p) {
                    window.setTimeout(function () {
                        n && n(p), r.manager.itemEnd(e), r.manager.itemError(e)
                    }, 0)
                }
            } else {
                var d = new XMLHttpRequest;
                d.open("GET", e, !0), d.addEventListener("load", function (i) {
                    var a = i.target.response;
                    Va.add(e, a), 200 === this.status ? (t && t(a), r.manager.itemEnd(e)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), t && t(a), r.manager.itemEnd(e)) : (n && n(i), r.manager.itemEnd(e), r.manager.itemError(e))
                }, !1), void 0 !== i && d.addEventListener("progress", function (e) {
                    i(e)
                }, !1), d.addEventListener("error", function (t) {
                    n && n(t), r.manager.itemEnd(e), r.manager.itemError(e)
                }, !1), void 0 !== this.responseType && (d.responseType = this.responseType), void 0 !== this.withCredentials && (d.withCredentials = this.withCredentials), d.overrideMimeType && d.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (s in this.requestHeader) d.setRequestHeader(s, this.requestHeader[s]);
                d.send(null)
            }
            return r.manager.itemStart(e), d
        },
        setPath: function (e) {
            return this.path = e, this
        },
        setResponseType: function (e) {
            return this.responseType = e, this
        },
        setWithCredentials: function (e) {
            return this.withCredentials = e, this
        },
        setMimeType: function (e) {
            return this.mimeType = e, this
        },
        setRequestHeader: function (e) {
            return this.requestHeader = e, this
        }
    }), Object.assign(Ln.prototype, {
        load: function (e, t, i, n) {
            function r(r) {
                c.load(e[r], function (e) {
                    e = a._parser(e, !0), o[r] = {
                        width: e.width,
                        height: e.height,
                        format: e.format,
                        mipmaps: e.mipmaps
                    }, h += 1, 6 === h && (1 === e.mipmapCount && (s.minFilter = 1006), s.format = e.format, s.needsUpdate = !0, t && t(s))
                }, i, n)
            }
            var a = this,
                o = [],
                s = new Pi;
            s.image = o;
            var c = new Rn(this.manager);
            if (c.setPath(this.path), c.setResponseType("arraybuffer"), Array.isArray(e))
                for (var h = 0, l = 0, u = e.length; u > l; ++l) r(l);
            else c.load(e, function (e) {
                if (e = a._parser(e, !0), e.isCubemap)
                    for (var i = e.mipmaps.length / e.mipmapCount, n = 0; i > n; n++) {
                        o[n] = {
                            mipmaps: []
                        };
                        for (var r = 0; r < e.mipmapCount; r++) o[n].mipmaps.push(e.mipmaps[n * e.mipmapCount + r]), o[n].format = e.format, o[n].width = e.width, o[n].height = e.height
                    } else s.image.width = e.width, s.image.height = e.height, s.mipmaps = e.mipmaps;
                1 === e.mipmapCount && (s.minFilter = 1006), s.format = e.format, s.needsUpdate = !0, t && t(s)
            }, i, n);
            return s
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(Pn.prototype, {
        load: function (e, t, i, n) {
            var r = this,
                a = new l,
                o = new Rn(this.manager);
            return o.setResponseType("arraybuffer"), o.load(e, function (e) {
                (e = r._parser(e)) && (void 0 !== e.image ? a.image = e.image : void 0 !== e.data && (a.image.width = e.width, a.image.height = e.height, a.image.data = e.data), a.wrapS = void 0 !== e.wrapS ? e.wrapS : 1001, a.wrapT = void 0 !== e.wrapT ? e.wrapT : 1001, a.magFilter = void 0 !== e.magFilter ? e.magFilter : 1006, a.minFilter = void 0 !== e.minFilter ? e.minFilter : 1008, a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (a.format = e.format), void 0 !== e.type && (a.type = e.type), void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps), 1 === e.mipmapCount && (a.minFilter = 1006), a.needsUpdate = !0, t && t(a, e))
            }, i, n), a
        }
    }), Object.assign(Cn.prototype, {
        load: function (e, t, i, n) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e);
            var r = this,
                a = Va.get(e);
            return void 0 !== a ? (r.manager.itemStart(e), setTimeout(function () {
                t && t(a), r.manager.itemEnd(e)
            }, 0), a) : (i = document.createElementNS("http://www.w3.org/1999/xhtml", "img"), i.addEventListener("load", function () {
                Va.add(e, this), t && t(this), r.manager.itemEnd(e)
            }, !1), i.addEventListener("error", function (t) {
                n && n(t), r.manager.itemEnd(e), r.manager.itemError(e)
            }, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (i.crossOrigin = this.crossOrigin), r.manager.itemStart(e), i.src = e, i)
        },
        setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(In.prototype, {
        load: function (e, t, i, n) {
            function r(i) {
                o.load(e[i], function (e) {
                    a.images[i] = e, s++, 6 === s && (a.needsUpdate = !0, t && t(a))
                }, void 0, n)
            }
            var a = new u,
                o = new Cn(this.manager);
            o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
            var s = 0;
            for (i = 0; i < e.length; ++i) r(i);
            return a
        },
        setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(Un.prototype, {
        load: function (e, t, i, r) {
            var a = new Cn(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            var o = new n;
            return o.image = a.load(e, function () {
                var i = 0 < e.search(/\.(jpg|jpeg)$/) || 0 === e.search(/^data\:image\/jpeg/);
                o.format = i ? 1022 : 1023, o.needsUpdate = !0, void 0 !== t && t(o)
            }, i, r), o
        },
        setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Nn.prototype = Object.assign(Object.create(at.prototype), {
        constructor: Nn,
        isLight: !0,
        copy: function (e) {
            return at.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
        },
        toJSON: function (e) {
            return e = at.prototype.toJSON.call(this, e), e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }), Dn.prototype = Object.assign(Object.create(Nn.prototype), {
        constructor: Dn,
        isHemisphereLight: !0,
        copy: function (e) {
            return Nn.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
        }
    }), Object.assign(On.prototype, {
        copy: function (e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        toJSON: function () {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), (512 !== this.mapSize.x || 512 !== this.mapSize.y) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }), Fn.prototype = Object.assign(Object.create(On.prototype), {
        constructor: Fn,
        isSpotLightShadow: !0,
        update: function (e) {
            var t = this.camera,
                i = 2 * _a.RAD2DEG * e.angle,
                n = this.mapSize.width / this.mapSize.height;
            e = e.distance || t.far, (i !== t.fov || n !== t.aspect || e !== t.far) && (t.fov = i, t.aspect = n, t.far = e, t.updateProjectionMatrix())
        }
    }), Bn.prototype = Object.assign(Object.create(Nn.prototype), {
        constructor: Bn,
        isSpotLight: !0,
        copy: function (e) {
            return Nn.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), zn.prototype = Object.assign(Object.create(Nn.prototype), {
        constructor: zn,
        isPointLight: !0,
        copy: function (e) {
            return Nn.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }), Gn.prototype = Object.assign(Object.create(On.prototype), {
        constructor: Gn
    }), Hn.prototype = Object.assign(Object.create(Nn.prototype), {
        constructor: Hn,
        isDirectionalLight: !0,
        copy: function (e) {
            return Nn.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), Vn.prototype = Object.assign(Object.create(Nn.prototype), {
        constructor: Vn,
        isAmbientLight: !0
    }), kn.prototype = Object.assign(Object.create(Nn.prototype), {
        constructor: kn,
        isRectAreaLight: !0,
        copy: function (e) {
            return Nn.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
        },
        toJSON: function (e) {
            return e = Nn.prototype.toJSON.call(this, e), e.object.width = this.width, e.object.height = this.height, e
        }
    });
    var ja = {
        arraySlice: function (e, t, i) {
            return ja.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
        },
        convertArray: function (e, t, i) {
            return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        },
        isTypedArray: function (e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        },
        getKeyframeOrder: function (e) {
            for (var t = e.length, i = Array(t), n = 0; n !== t; ++n) i[n] = n;
            return i.sort(function (t, i) {
                return e[t] - e[i]
            }), i
        },
        sortedArray: function (e, t, i) {
            for (var n = e.length, r = new e.constructor(n), a = 0, o = 0; o !== n; ++a)
                for (var s = i[a] * t, c = 0; c !== t; ++c) r[o++] = e[s + c];
            return r
        },
        flattenJSON: function (e, t, i, n) {
            for (var r = 1, a = e[0]; void 0 !== a && void 0 === a[n];) a = e[r++];
            if (void 0 !== a) {
                var o = a[n];
                if (void 0 !== o)
                    if (Array.isArray(o)) {
                        do o = a[n], void 0 !== o && (t.push(a.time), i.push.apply(i, o)), a = e[r++]; while (void 0 !== a)
                    } else if (void 0 !== o.toArray) {
                    do o = a[n], void 0 !== o && (t.push(a.time), o.toArray(i, i.length)), a = e[r++]; while (void 0 !== a)
                } else
                    do o = a[n], void 0 !== o && (t.push(a.time), i.push(o)), a = e[r++]; while (void 0 !== a)
            }
        }
    };
    Object.assign(jn.prototype, {
        evaluate: function (e) {
            var t = this.parameterPositions,
                i = this._cachedIndex,
                n = t[i],
                r = t[i - 1];
            e: {
                t: {
                    i: {
                        n: if (!(n > e)) {
                            for (var a = i + 2;;) {
                                if (void 0 === n) {
                                    if (r > e) break n;
                                    return this._cachedIndex = i = t.length, this.afterEnd_(i - 1, e, r)
                                }
                                if (i === a) break;
                                if (r = n, n = t[++i], n > e) break t
                            }
                            n = t.length;
                            break i
                        }if (e >= r) break e;
                        for (a = t[1], a > e && (i = 2, r = a), a = i - 2;;) {
                            if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                            if (i === a) break;
                            if (n = r, r = t[--i - 1], e >= r) break t
                        }
                        n = i,
                        i = 0
                    }
                    for (; n > i;) r = i + n >>> 1,
                    e < t[r] ? n = r : i = r + 1;
                    if (n = t[i], r = t[i - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                    if (void 0 === n) return this._cachedIndex = i = t.length, this.afterEnd_(i - 1, r, e)
                }
                this._cachedIndex = i,
                this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, e, n)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function () {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function (e) {
            var t = this.resultBuffer,
                i = this.sampleValues,
                n = this.valueSize;
            e *= n;
            for (var r = 0; r !== n; ++r) t[r] = i[e + r];
            return t
        },
        interpolate_: function () {
            throw Error("call to abstract method")
        },
        intervalChanged_: function () {}
    }), Object.assign(jn.prototype, {
        beforeStart_: jn.prototype.copySampleValue_,
        afterEnd_: jn.prototype.copySampleValue_
    }), Wn.prototype = Object.assign(Object.create(jn.prototype), {
        constructor: Wn,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function (e, t, i) {
            var n = this.parameterPositions,
                r = e - 2,
                a = e + 1,
                o = n[r],
                s = n[a];
            if (void 0 === o) switch (this.getSettings_().endingStart) {
                case 2401:
                    r = e, o = 2 * t - i;
                    break;
                case 2402:
                    r = n.length - 2, o = t + n[r] - n[r + 1];
                    break;
                default:
                    r = e, o = i
            }
            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                case 2401:
                    a = e, s = 2 * i - t;
                    break;
                case 2402:
                    a = 1, s = i + n[1] - n[0];
                    break;
                default:
                    a = e - 1, s = t
            }
            e = .5 * (i - t), n = this.valueSize, this._weightPrev = e / (t - o), this._weightNext = e / (s - i), this._offsetPrev = r * n, this._offsetNext = a * n
        },
        interpolate_: function (e, t, i, n) {
            var r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize;
            e *= o;
            var s = e - o,
                c = this._offsetPrev,
                h = this._offsetNext,
                l = this._weightPrev,
                u = this._weightNext,
                p = (i - t) / (n - t);
            for (i = p * p, n = i * p, t = -l * n + 2 * l * i - l * p, l = (1 + l) * n + (-1.5 - 2 * l) * i + (-.5 + l) * p + 1, p = (-1 - u) * n + (1.5 + u) * i + .5 * p, u = u * n - u * i, i = 0; i !== o; ++i) r[i] = t * a[c + i] + l * a[s + i] + p * a[e + i] + u * a[h + i];
            return r
        }
    }), Xn.prototype = Object.assign(Object.create(jn.prototype), {
        constructor: Xn,
        interpolate_: function (e, t, i, n) {
            var r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize;
            e *= o;
            var s = e - o;
            for (t = (i - t) / (n - t), i = 1 - t, n = 0; n !== o; ++n) r[n] = a[s + n] * i + a[e + n] * t;
            return r
        }
    }), qn.prototype = Object.assign(Object.create(jn.prototype), {
        constructor: qn,
        interpolate_: function (e) {
            return this.copySampleValue_(e - 1)
        }
    });
    var Wa;
    Wa = {
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function (e) {
            return new qn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodLinear: function (e) {
            return new Xn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: function (e) {
            return new Wn(this.times, this.values, this.getValueSize(), e)
        },
        setInterpolation: function (e) {
            var t;
            switch (e) {
                case 2300:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                if (t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation) throw Error(t);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                console.warn("THREE.KeyframeTrackPrototype:", t)
            } else this.createInterpolant = t
        },
        getInterpolation: function () {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function () {
            return this.values.length / this.times.length
        },
        shift: function (e) {
            if (0 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] += e;
            return this
        },
        scale: function (e) {
            if (1 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] *= e;
            return this
        },
        trim: function (e, t) {
            for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < e;) ++r;
            for (; - 1 !== a && i[a] > t;) --a;
            return ++a, (0 !== r || a !== n) && (r >= a && (a = Math.max(a, 1), r = a - 1), n = this.getValueSize(), this.times = ja.arraySlice(i, r, a), this.values = ja.arraySlice(this.values, r * n, a * n)), this
        },
        validate: function () {
            var e = !0,
                t = this.getValueSize();
            0 !== t - Math.floor(t) && (console.error("THREE.KeyframeTrackPrototype: Invalid value size in track.", this), e = !1);
            var i = this.times,
                t = this.values,
                n = i.length;
            0 === n && (console.error("THREE.KeyframeTrackPrototype: Track is empty.", this), e = !1);
            for (var r = null, a = 0; a !== n; a++) {
                var o = i[a];
                if ("number" == typeof o && isNaN(o)) {
                    console.error("THREE.KeyframeTrackPrototype: Time is not a valid number.", this, a, o), e = !1;
                    break
                }
                if (null !== r && r > o) {
                    console.error("THREE.KeyframeTrackPrototype: Out of order keys.", this, a, o, r), e = !1;
                    break
                }
                r = o
            }
            if (void 0 !== t && ja.isTypedArray(t))
                for (a = 0, i = t.length; a !== i; ++a)
                    if (n = t[a], isNaN(n)) {
                        console.error("THREE.KeyframeTrackPrototype: Value is not a valid number.", this, a, n), e = !1;
                        break
                    }
            return e
        },
        optimize: function () {
            for (var e = this.times, t = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, a = e.length - 1, o = 1; a > o; ++o) {
                var s = !1,
                    c = e[o];
                if (c !== e[o + 1] && (1 !== o || c !== c[0]))
                    if (n) s = !0;
                    else
                        for (var h = o * i, l = h - i, u = h + i, c = 0; c !== i; ++c) {
                            var p = t[h + c];
                            if (p !== t[l + c] || p !== t[u + c]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (o !== r)
                        for (e[r] = e[o], s = o * i, h = r * i, c = 0; c !== i; ++c) t[h + c] = t[s + c];
                    ++r
                }
            }
            if (a > 0) {
                for (e[r] = e[a], s = a * i, h = r * i, c = 0; c !== i; ++c) t[h + c] = t[s + c];
                ++r
            }
            return r !== e.length && (this.times = ja.arraySlice(e, 0, r), this.values = ja.arraySlice(t, 0, r * i)), this
        }
    }, Zn.prototype = Object.assign(Object.create(Wa), {
        constructor: Zn,
        ValueTypeName: "vector"
    }), Jn.prototype = Object.assign(Object.create(jn.prototype), {
        constructor: Jn,
        interpolate_: function (e, t, i, n) {
            var r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize;
            for (e *= o, t = (i - t) / (n - t), i = e + o; e !== i; e += 4) s.slerpFlat(r, 0, a, e - o, a, e, t);
            return r
        }
    }), Qn.prototype = Object.assign(Object.create(Wa), {
        constructor: Qn,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function (e) {
            return new Jn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), Kn.prototype = Object.assign(Object.create(Wa), {
        constructor: Kn,
        ValueTypeName: "number"
    }), $n.prototype = Object.assign(Object.create(Wa), {
        constructor: $n,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), er.prototype = Object.assign(Object.create(Wa), {
        constructor: er,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), tr.prototype = Object.assign(Object.create(Wa), {
        constructor: tr,
        ValueTypeName: "color"
    }), ir.prototype = Wa, Wa.constructor = ir, Object.assign(ir, {
        parse: function (e) {
            if (void 0 === e.type) throw Error("track type undefined, can not parse");
            var t = ir._getTrackTypeForValueTypeName(e.type);
            if (void 0 === e.times) {
                var i = [],
                    n = [];
                ja.flattenJSON(e.keys, i, n, "value"), e.times = i, e.values = n
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
        },
        toJSON: function (e) {
            var t = e.constructor;
            if (void 0 !== t.toJSON) t = t.toJSON(e);
            else {
                var t = {
                        name: e.name,
                        times: ja.convertArray(e.times, Array),
                        values: ja.convertArray(e.values, Array)
                    },
                    i = e.getInterpolation();
                i !== e.DefaultInterpolation && (t.interpolation = i)
            }
            return t.type = e.ValueTypeName, t
        },
        _getTrackTypeForValueTypeName: function (e) {
            switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Kn;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Zn;
                case "color":
                    return tr;
                case "quaternion":
                    return Qn;
                case "bool":
                case "boolean":
                    return er;
                case "string":
                    return $n
            }
            throw Error("Unsupported typeName: " + e)
        }
    }), Object.assign(nr, {
        parse: function (e) {
            for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, a = i.length; r !== a; ++r) t.push(ir.parse(i[r]).scale(n));
            return new nr(e.name, e.duration, t)
        },
        toJSON: function (e) {
            var t = [],
                i = e.tracks;
            e = {
                name: e.name,
                duration: e.duration,
                tracks: t
            };
            for (var n = 0, r = i.length; n !== r; ++n) t.push(ir.toJSON(i[n]));
            return e
        },
        CreateFromMorphTargetSequence: function (e, t, i, n) {
            for (var r = t.length, a = [], o = 0; r > o; o++) {
                var s = [],
                    c = [];
                s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
                var h = ja.getKeyframeOrder(s),
                    s = ja.sortedArray(s, 1, h),
                    c = ja.sortedArray(c, 1, h);
                n || 0 !== s[0] || (s.push(r), c.push(c[0])), a.push(new Kn(".morphTargetInfluences[" + t[o].name + "]", s, c).scale(1 / i))
            }
            return new nr(e, -1, a)
        },
        findByName: function (e, t) {
            var i = e;
            Array.isArray(e) || (i = e.geometry && e.geometry.animations || e.animations);
            for (var n = 0; n < i.length; n++)
                if (i[n].name === t) return i[n];
            return null
        },
        CreateClipsFromMorphTargetSequences: function (e, t, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; o > a; a++) {
                var s = e[a],
                    c = s.name.match(r);
                if (c && 1 < c.length) {
                    var h = c[1];
                    (c = n[h]) || (n[h] = c = []), c.push(s)
                }
            }
            e = [];
            for (h in n) e.push(nr.CreateFromMorphTargetSequence(h, n[h], t, i));
            return e
        },
        parseAnimation: function (e, t) {
            if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            for (var i = function (e, t, i, n, r) {
                    if (0 !== i.length) {
                        var a = [],
                            o = [];
                        ja.flattenJSON(i, a, o, n), 0 !== a.length && r.push(new e(t, a, o))
                    }
                }, n = [], r = e.name || "default", a = e.length || -1, o = e.fps || 30, s = e.hierarchy || [], c = 0; c < s.length; c++) {
                var h = s[c].keys;
                if (h && 0 !== h.length)
                    if (h[0].morphTargets) {
                        for (var a = {}, l = 0; l < h.length; l++)
                            if (h[l].morphTargets)
                                for (var u = 0; u < h[l].morphTargets.length; u++) a[h[l].morphTargets[u]] = -1;
                        for (var p in a) {
                            for (var d = [], f = [], u = 0; u !== h[l].morphTargets.length; ++u) {
                                var m = h[l];
                                d.push(m.time), f.push(m.morphTarget === p ? 1 : 0)
                            }
                            n.push(new Kn(".morphTargetInfluence[" + p + "]", d, f))
                        }
                        a = a.length * (o || 1)
                    } else l = ".bones[" + t[c].name + "]", i(Zn, l + ".position", h, "pos", n), i(Qn, l + ".quaternion", h, "rot", n), i(Zn, l + ".scale", h, "scl", n)
            }
            return 0 === n.length ? null : new nr(r, a, n)
        }
    }), Object.assign(nr.prototype, {
        resetDuration: function () {
            for (var e = 0, t = 0, i = this.tracks.length; t !== i; ++t) var n = this.tracks[t],
                e = Math.max(e, n.times[n.times.length - 1]);
            this.duration = e
        },
        trim: function () {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        },
        optimize: function () {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        }
    }), Object.assign(rr.prototype, {
        load: function (e, t, i, n) {
            var r = this;
            new Rn(r.manager).load(e, function (e) {
                t(r.parse(JSON.parse(e)))
            }, i, n)
        },
        setTextures: function (e) {
            this.textures = e
        },
        parse: function (e) {
            function t(e) {
                return void 0 === n[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), n[e]
            }
            var n = this.textures,
                r = new Ha[e.type];
            if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearCoat && (r.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (r.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.uniforms && (r.uniforms = e.uniforms), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.vertexColors && (r.vertexColors = e.vertexColors), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.shading && (r.shading = e.shading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = t(e.map)), void 0 !== e.alphaMap && (r.alphaMap = t(e.alphaMap), r.transparent = !0), void 0 !== e.bumpMap && (r.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = t(e.normalMap)), void 0 !== e.normalScale) {
                var a = e.normalScale;
                !1 === Array.isArray(a) && (a = [a, a]), r.normalScale = (new i).fromArray(a)
            }
            return void 0 !== e.displacementMap && (r.displacementMap = t(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = t(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = t(e.specularMap)), void 0 !== e.envMap && (r.envMap = t(e.envMap)), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.lightMap && (r.lightMap = t(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = t(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = t(e.gradientMap)), r
        }
    }), Object.assign(ar.prototype, {
        load: function (e, t, i, n) {
            var r = this;
            new Rn(r.manager).load(e, function (e) {
                t(r.parse(JSON.parse(e)))
            }, i, n)
        },
        parse: function (e) {
            var t = new Mt,
                i = e.data.index;
            void 0 !== i && (i = new Xa[i.type](i.array), t.setIndex(new ut(i, 1)));
            var n, r = e.data.attributes;
            for (n in r) {
                var a = r[n],
                    i = new Xa[a.type](a.array);
                t.addAttribute(n, new ut(i, a.itemSize, a.normalized))
            }
            if (n = e.data.groups || e.data.drawcalls || e.data.offsets, void 0 !== n)
                for (i = 0, r = n.length; i !== r; ++i) a = n[i], t.addGroup(a.start, a.count, a.materialIndex);
            return e = e.data.boundingSphere, void 0 !== e && (n = new c, void 0 !== e.center && n.fromArray(e.center), t.boundingSphere = new Q(n, e.radius)), t
        }
    });
    var Xa = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    or.Handlers = {
        handlers: [],
        add: function (e, t) {
            this.handlers.push(e, t)
        },
        get: function (e) {
            for (var t = this.handlers, i = 0, n = t.length; n > i; i += 2) {
                var r = t[i + 1];
                if (t[i].test(e)) return r
            }
            return null
        }
    }, Object.assign(or.prototype, {
        crossOrigin: void 0,
        extractUrlBase: function (e) {
            return e = e.split("/"), 1 === e.length ? "./" : (e.pop(), e.join("/") + "/")
        },
        initMaterials: function (e, t, i) {
            for (var n = [], r = 0; r < e.length; ++r) n[r] = this.createMaterial(e[r], t, i);
            return n
        },
        createMaterial: function () {
            var e = {
                    NoBlending: 0,
                    NormalBlending: 1,
                    AdditiveBlending: 2,
                    SubtractiveBlending: 3,
                    MultiplyBlending: 4,
                    CustomBlending: 5
                },
                t = new k,
                i = new Un,
                n = new rr;
            return function (r, a, o) {
                function s(e, t, n, r, s) {
                    e = a + e;
                    var c = or.Handlers.get(e);
                    return null !== c ? e = c.load(e) : (i.setCrossOrigin(o), e = i.load(e)), void 0 !== t && (e.repeat.fromArray(t), 1 !== t[0] && (e.wrapS = 1e3), 1 !== t[1] && (e.wrapT = 1e3)), void 0 !== n && e.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (e.wrapS = 1e3), "mirror" === r[0] && (e.wrapS = 1002), "repeat" === r[1] && (e.wrapT = 1e3), "mirror" === r[1] && (e.wrapT = 1002)), void 0 !== s && (e.anisotropy = s), t = _a.generateUUID(), h[t] = e, t
                }
                var c, h = {},
                    l = {
                        uuid: _a.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                for (c in r) {
                    var u = r[c];
                    switch (c) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            l.name = u;
                            break;
                        case "blending":
                            l.blending = e[u];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", c, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            l.color = t.fromArray(u).getHex();
                            break;
                        case "colorSpecular":
                            l.specular = t.fromArray(u).getHex();
                            break;
                        case "colorEmissive":
                            l.emissive = t.fromArray(u).getHex();
                            break;
                        case "specularCoef":
                            l.shininess = u;
                            break;
                        case "shading":
                            "basic" === u.toLowerCase() && (l.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (l.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (l.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            l.map = s(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapEmissive":
                            l.emissiveMap = s(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                            break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                            break;
                        case "mapLight":
                            l.lightMap = s(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            l.aoMap = s(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            l.bumpMap = s(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            l.bumpScale = u;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            l.normalMap = s(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            l.normalScale = [u, u];
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            l.specularMap = s(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapMetalness":
                            l.metalnessMap = s(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                            break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                            break;
                        case "mapRoughness":
                            l.roughnessMap = s(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                            break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                            break;
                        case "mapAlpha":
                            l.alphaMap = s(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            l.side = 1;
                            break;
                        case "doubleSided":
                            l.side = 2;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), l.opacity = u;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            l[c] = u;
                            break;
                        case "vertexColors":
                            !0 === u && (l.vertexColors = 2), "face" === u && (l.vertexColors = 1);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", c, u)
                    }
                }
                return "MeshBasicMaterial" === l.type && delete l.emissive, "MeshPhongMaterial" !== l.type && delete l.specular, 1 > l.opacity && (l.transparent = !0), n.setTextures(h), n.parse(l)
            }
        }()
    }), Object.assign(sr.prototype, {
        load: function (e, t, i, n) {
            var r = this,
                a = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : or.prototype.extractUrlBase(e),
                o = new Rn(this.manager);
            o.setWithCredentials(this.withCredentials), o.load(e, function (i) {
                i = JSON.parse(i);
                var n = i.metadata;
                if (void 0 !== n && (n = n.type, void 0 !== n)) {
                    if ("object" === n.toLowerCase()) return console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.ObjectLoader instead."), void 0;
                    if ("scene" === n.toLowerCase()) return console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.SceneLoader instead."), void 0
                }
                i = r.parse(i, a), t(i.geometry, i.materials)
            }, i, n)
        },
        setTexturePath: function (e) {
            this.texturePath = e
        },
        parse: function () {
            return function (e, t) {
                void 0 !== e.data && (e = e.data), e.scale = void 0 !== e.scale ? 1 / e.scale : 1;
                var n, a, o, s, h, l, u, p, d, f, m, g, v, y, x = new lt,
                    b = e,
                    _ = b.faces;
                d = b.vertices;
                var w = b.normals,
                    M = b.colors;
                l = b.scale;
                var E = 0;
                if (void 0 !== b.uvs) {
                    for (n = 0; n < b.uvs.length; n++) b.uvs[n].length && E++;
                    for (n = 0; E > n; n++) x.faceVertexUvs[n] = []
                }
                for (s = 0, h = d.length; h > s;) n = new c, n.x = d[s++] * l, n.y = d[s++] * l, n.z = d[s++] * l, x.vertices.push(n);
                for (s = 0, h = _.length; h > s;)
                    if (d = _[s++], f = 1 & d, o = 2 & d, n = 8 & d, u = 16 & d, m = 32 & d, l = 64 & d, d &= 128, f) {
                        if (f = new ht, f.a = _[s], f.b = _[s + 1], f.c = _[s + 3], g = new ht, g.a = _[s + 1], g.b = _[s + 2], g.c = _[s + 3], s += 4, o && (o = _[s++], f.materialIndex = o, g.materialIndex = o), o = x.faces.length, n)
                            for (n = 0; E > n; n++)
                                for (v = b.uvs[n], x.faceVertexUvs[n][o] = [], x.faceVertexUvs[n][o + 1] = [], a = 0; 4 > a; a++) p = _[s++], y = v[2 * p], p = v[2 * p + 1], y = new i(y, p), 2 !== a && x.faceVertexUvs[n][o].push(y), 0 !== a && x.faceVertexUvs[n][o + 1].push(y);
                        if (u && (u = 3 * _[s++], f.normal.set(w[u++], w[u++], w[u]), g.normal.copy(f.normal)), m)
                            for (n = 0; 4 > n; n++) u = 3 * _[s++], m = new c(w[u++], w[u++], w[u]), 2 !== n && f.vertexNormals.push(m), 0 !== n && g.vertexNormals.push(m);
                        if (l && (l = _[s++], l = M[l], f.color.setHex(l), g.color.setHex(l)), d)
                            for (n = 0; 4 > n; n++) l = _[s++], l = M[l], 2 !== n && f.vertexColors.push(new k(l)), 0 !== n && g.vertexColors.push(new k(l));
                        x.faces.push(f), x.faces.push(g)
                    } else {
                        if (f = new ht, f.a = _[s++], f.b = _[s++], f.c = _[s++], o && (o = _[s++], f.materialIndex = o), o = x.faces.length, n)
                            for (n = 0; E > n; n++)
                                for (v = b.uvs[n], x.faceVertexUvs[n][o] = [], a = 0; 3 > a; a++) p = _[s++], y = v[2 * p], p = v[2 * p + 1], y = new i(y, p), x.faceVertexUvs[n][o].push(y);
                        if (u && (u = 3 * _[s++], f.normal.set(w[u++], w[u++], w[u])), m)
                            for (n = 0; 3 > n; n++) u = 3 * _[s++], m = new c(w[u++], w[u++], w[u]), f.vertexNormals.push(m);
                        if (l && (l = _[s++], f.color.setHex(M[l])), d)
                            for (n = 0; 3 > n; n++) l = _[s++], f.vertexColors.push(new k(M[l]));
                        x.faces.push(f)
                    }
                if (b = e, s = void 0 !== b.influencesPerVertex ? b.influencesPerVertex : 2, b.skinWeights)
                    for (h = 0, _ = b.skinWeights.length; _ > h; h += s) x.skinWeights.push(new r(b.skinWeights[h], s > 1 ? b.skinWeights[h + 1] : 0, s > 2 ? b.skinWeights[h + 2] : 0, s > 3 ? b.skinWeights[h + 3] : 0));
                if (b.skinIndices)
                    for (h = 0, _ = b.skinIndices.length; _ > h; h += s) x.skinIndices.push(new r(b.skinIndices[h], s > 1 ? b.skinIndices[h + 1] : 0, s > 2 ? b.skinIndices[h + 2] : 0, s > 3 ? b.skinIndices[h + 3] : 0));
                if (x.bones = b.bones, x.bones && 0 < x.bones.length && (x.skinWeights.length !== x.skinIndices.length || x.skinIndices.length !== x.vertices.length) && console.warn("When skinning, number of vertices (" + x.vertices.length + "), skinIndices (" + x.skinIndices.length + "), and skinWeights (" + x.skinWeights.length + ") should match."), h = e, _ = h.scale, void 0 !== h.morphTargets)
                    for (b = 0, s = h.morphTargets.length; s > b; b++)
                        for (x.morphTargets[b] = {}, x.morphTargets[b].name = h.morphTargets[b].name, x.morphTargets[b].vertices = [], w = x.morphTargets[b].vertices, M = h.morphTargets[b].vertices, E = 0, d = M.length; d > E; E += 3) l = new c, l.x = M[E] * _, l.y = M[E + 1] * _, l.z = M[E + 2] * _, w.push(l);
                if (void 0 !== h.morphColors && 0 < h.morphColors.length)
                    for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), _ = x.faces, h = h.morphColors[0].colors, b = 0, s = _.length; s > b; b++) _[b].color.fromArray(h, 3 * b);
                for (h = e, b = [], s = [], void 0 !== h.animation && s.push(h.animation), void 0 !== h.animations && (h.animations.length ? s = s.concat(h.animations) : s.push(h.animations)), h = 0; h < s.length; h++)(_ = nr.parseAnimation(s[h], x.bones)) && b.push(_);
                return x.morphTargets && (s = nr.CreateClipsFromMorphTargetSequences(x.morphTargets, 10), b = b.concat(s)), 0 < b.length && (x.animations = b), x.computeFaceNormals(), x.computeBoundingSphere(), void 0 === e.materials || 0 === e.materials.length ? {
                    geometry: x
                } : (b = or.prototype.initMaterials(e.materials, t, this.crossOrigin), {
                    geometry: x,
                    materials: b
                })
            }
        }()
    }), Object.assign(cr.prototype, {
        load: function (e, t, i, n) {
            "" === this.texturePath && (this.texturePath = e.substring(0, e.lastIndexOf("/") + 1));
            var r = this;
            new Rn(r.manager).load(e, function (i) {
                var a = null;
                try {
                    a = JSON.parse(i)
                } catch (o) {
                    return void 0 !== n && n(o), console.error("THREE:ObjectLoader: Can't parse " + e + ".", o.message), void 0
                }
                i = a.metadata, void 0 === i || void 0 === i.type || "geometry" === i.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + e + ". Use THREE.JSONLoader instead.") : r.parse(a, t)
            }, i, n)
        },
        setTexturePath: function (e) {
            this.texturePath = e
        },
        setCrossOrigin: function (e) {
            this.crossOrigin = e
        },
        parse: function (e, t) {
            var i = this.parseGeometries(e.geometries),
                n = this.parseImages(e.images, function () {
                    void 0 !== t && t(r)
                }),
                n = this.parseTextures(e.textures, n),
                n = this.parseMaterials(e.materials, n),
                r = this.parseObject(e.object, i, n);
            return e.animations && (r.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 === t || t(r), r
        },
        parseGeometries: function (e) {
            var t = {};
            if (void 0 !== e)
                for (var i = new sr, n = new ar, r = 0, a = e.length; a > r; r++) {
                    var o, s = e[r];
                    switch (s.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            o = new Ga[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            o = new Ga[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            o = new Ga[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            o = new Ga[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            o = new Ga[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            o = new Ga[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "IcosahedronGeometry":
                        case "OctahedronGeometry":
                        case "TetrahedronGeometry":
                            o = new Ga[s.type](s.radius, s.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            o = new Ga[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            o = new Ga[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            o = new Ga[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            o = new Ga[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                            break;
                        case "BufferGeometry":
                            o = n.parse(s);
                            break;
                        case "Geometry":
                            o = i.parse(s, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                            continue
                    }
                    o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), t[s.uuid] = o
                }
            return t
        },
        parseMaterials: function (e, t) {
            var i = {};
            if (void 0 !== e) {
                var n = new rr;
                n.setTextures(t);
                for (var r = 0, a = e.length; a > r; r++) {
                    var o = e[r];
                    if ("MultiMaterial" === o.type) {
                        for (var s = [], c = 0; c < o.materials.length; c++) s.push(n.parse(o.materials[c]));
                        i[o.uuid] = s
                    } else i[o.uuid] = n.parse(o)
                }
            }
            return i
        },
        parseAnimations: function (e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = nr.parse(e[i]);
                t.push(n)
            }
            return t
        },
        parseImages: function (e, t) {
            function i(e) {
                return n.manager.itemStart(e), o.load(e, function () {
                    n.manager.itemEnd(e)
                }, void 0, function () {
                    n.manager.itemEnd(e), n.manager.itemError(e)
                })
            }
            var n = this,
                r = {};
            if (void 0 !== e && 0 < e.length) {
                var a = new An(t),
                    o = new Cn(a);
                o.setCrossOrigin(this.crossOrigin);
                for (var a = 0, s = e.length; s > a; a++) {
                    var c = e[a],
                        h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.texturePath + c.url;
                    r[c.uuid] = i(h)
                }
            }
            return r
        },
        parseTextures: function (e, t) {
            function i(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
            }
            var r = {};
            if (void 0 !== e)
                for (var a = 0, o = e.length; o > a; a++) {
                    var s = e[a];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                    var c = new n(t[s.image]);
                    c.needsUpdate = !0, c.uuid = s.uuid, void 0 !== s.name && (c.name = s.name), void 0 !== s.mapping && (c.mapping = i(s.mapping, qa)), void 0 !== s.offset && c.offset.fromArray(s.offset), void 0 !== s.repeat && c.repeat.fromArray(s.repeat), void 0 !== s.wrap && (c.wrapS = i(s.wrap[0], Ya), c.wrapT = i(s.wrap[1], Ya)), void 0 !== s.minFilter && (c.minFilter = i(s.minFilter, Za)), void 0 !== s.magFilter && (c.magFilter = i(s.magFilter, Za)), void 0 !== s.anisotropy && (c.anisotropy = s.anisotropy), void 0 !== s.flipY && (c.flipY = s.flipY), r[s.uuid] = c
                }
            return r
        },
        parseObject: function () {
            var e = new h;
            return function (t, i, n) {
                function r(e) {
                    return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), i[e]
                }

                function a(e) {
                    if (void 0 !== e) {
                        if (Array.isArray(e)) {
                            for (var t = [], i = 0, r = e.length; r > i; i++) {
                                var a = e[i];
                                void 0 === n[a] && console.warn("THREE.ObjectLoader: Undefined material", a), t.push(n[a])
                            }
                            return t
                        }
                        return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                    }
                }
                var o;
                switch (t.type) {
                    case "Scene":
                        o = new fi, void 0 !== t.background && Number.isInteger(t.background) && (o.background = new k(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? o.fog = new di(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (o.fog = new pi(t.fog.color, t.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        o = new ct(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (o.focus = t.focus), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.filmGauge && (o.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (o.filmOffset = t.filmOffset), void 0 !== t.view && (o.view = Object.assign({}, t.view));
                        break;
                    case "OrthographicCamera":
                        o = new st(t.left, t.right, t.top, t.bottom, t.near, t.far);
                        break;
                    case "AmbientLight":
                        o = new Vn(t.color, t.intensity);
                        break;
                    case "DirectionalLight":
                        o = new Hn(t.color, t.intensity);
                        break;
                    case "PointLight":
                        o = new zn(t.color, t.intensity, t.distance, t.decay);
                        break;
                    case "RectAreaLight":
                        o = new kn(t.color, t.intensity, t.width, t.height);
                        break;
                    case "SpotLight":
                        o = new Bn(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                        break;
                    case "HemisphereLight":
                        o = new Dn(t.color, t.groundColor, t.intensity);
                        break;
                    case "SkinnedMesh":
                        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                    case "Mesh":
                        o = r(t.geometry);
                        var s = a(t.material);
                        o = o.bones && 0 < o.bones.length ? new _i(o, s) : new It(o, s);
                        break;
                    case "LOD":
                        o = new yi;
                        break;
                    case "Line":
                        o = new Mi(r(t.geometry), a(t.material), t.mode);
                        break;
                    case "LineLoop":
                        o = new Ti(r(t.geometry), a(t.material));
                        break;
                    case "LineSegments":
                        o = new Ei(r(t.geometry), a(t.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        o = new Ai(r(t.geometry), a(t.material));
                        break;
                    case "Sprite":
                        o = new vi(a(t.material));
                        break;
                    case "Group":
                        o = new Ri;
                        break;
                    default:
                        o = new at
                }
                if (o.uuid = t.uuid, void 0 !== t.name && (o.name = t.name), void 0 !== t.matrix ? (e.fromArray(t.matrix), e.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== t.position && o.position.fromArray(t.position), void 0 !== t.rotation && o.rotation.fromArray(t.rotation), void 0 !== t.quaternion && o.quaternion.fromArray(t.quaternion), void 0 !== t.scale && o.scale.fromArray(t.scale)), void 0 !== t.castShadow && (o.castShadow = t.castShadow), void 0 !== t.receiveShadow && (o.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (o.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (o.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && o.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (o.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (o.visible = t.visible), void 0 !== t.userData && (o.userData = t.userData), void 0 !== t.children)
                    for (var c in t.children) o.add(this.parseObject(t.children[c], i, n));
                if ("LOD" === t.type)
                    for (t = t.levels, s = 0; s < t.length; s++) {
                        var h = t[s];
                        c = o.getObjectByProperty("uuid", h.object), void 0 !== c && o.addLevel(c, h.distance)
                    }
                return o
            }
        }()
    });
    var qa = {
            UVMapping: 300,
            CubeReflectionMapping: 301,
            CubeRefractionMapping: 302,
            EquirectangularReflectionMapping: 303,
            EquirectangularRefractionMapping: 304,
            SphericalReflectionMapping: 305,
            CubeUVReflectionMapping: 306,
            CubeUVRefractionMapping: 307
        },
        Ya = {
            RepeatWrapping: 1e3,
            ClampToEdgeWrapping: 1001,
            MirroredRepeatWrapping: 1002
        },
        Za = {
            NearestFilter: 1003,
            NearestMipMapNearestFilter: 1004,
            NearestMipMapLinearFilter: 1005,
            LinearFilter: 1006,
            LinearMipMapNearestFilter: 1007,
            LinearMipMapLinearFilter: 1008
        };
    Object.assign(pr.prototype, {
        getPoint: function () {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function (e) {
            return e = this.getUtoTmapping(e), this.getPoint(e)
        },
        getPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; e >= i; i++) t.push(this.getPoint(i / e));
            return t
        },
        getSpacedPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; e >= i; i++) t.push(this.getPointAt(i / e));
            return t
        },
        getLength: function () {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function (e) {
            if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, i, n = [],
                r = this.getPoint(0),
                a = 0;
            for (n.push(0), i = 1; e >= i; i++) t = this.getPoint(i / e), a += t.distanceTo(r), n.push(a), r = t;
            return this.cacheArcLengths = n
        },
        updateArcLengths: function () {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function (e, t) {
            var i, n, r = this.getLengths(),
                a = r.length;
            n = t ? t : e * r[a - 1];
            for (var o, s = 0, c = a - 1; c >= s;)
                if (i = Math.floor(s + (c - s) / 2), o = r[i] - n, 0 > o) s = i + 1;
                else {
                    if (!(o > 0)) {
                        c = i;
                        break
                    }
                    c = i - 1
                }
            return i = c, r[i] === n ? i / (a - 1) : (s = r[i], (i + (n - s) / (r[i + 1] - s)) / (a - 1))
        },
        getTangent: function (e) {
            var t = e - 1e-4;
            return e += 1e-4, 0 > t && (t = 0), e > 1 && (e = 1), t = this.getPoint(t), this.getPoint(e).clone().sub(t).normalize()
        },
        getTangentAt: function (e) {
            return e = this.getUtoTmapping(e), this.getTangent(e)
        },
        computeFrenetFrames: function (e, t) {
            var i, n, r = new c,
                a = [],
                o = [],
                s = [],
                l = new c,
                u = new h;
            for (i = 0; e >= i; i++) n = i / e, a[i] = this.getTangentAt(n), a[i].normalize();
            o[0] = new c, s[0] = new c, i = Number.MAX_VALUE, n = Math.abs(a[0].x);
            var p = Math.abs(a[0].y),
                d = Math.abs(a[0].z);
            for (i >= n && (i = n, r.set(1, 0, 0)), i >= p && (i = p, r.set(0, 1, 0)), i >= d && r.set(0, 0, 1), l.crossVectors(a[0], r).normalize(), o[0].crossVectors(a[0], l), s[0].crossVectors(a[0], o[0]), i = 1; e >= i; i++) o[i] = o[i - 1].clone(), s[i] = s[i - 1].clone(), l.crossVectors(a[i - 1], a[i]), l.length() > Number.EPSILON && (l.normalize(), r = Math.acos(_a.clamp(a[i - 1].dot(a[i]), -1, 1)), o[i].applyMatrix4(u.makeRotationAxis(l, r))), s[i].crossVectors(a[i], o[i]);
            if (!0 === t)
                for (r = Math.acos(_a.clamp(o[0].dot(o[e]), -1, 1)), r /= e, 0 < a[0].dot(l.crossVectors(o[0], o[e])) && (r = -r), i = 1; e >= i; i++) o[i].applyMatrix4(u.makeRotationAxis(a[i], r * i)), s[i].crossVectors(a[i], o[i]);
            return {
                tangents: a,
                normals: o,
                binormals: s
            }
        }
    }), dr.prototype = Object.create(pr.prototype), dr.prototype.constructor = dr, dr.prototype.isLineCurve = !0, dr.prototype.getPoint = function (e) {
        if (1 === e) return this.v2.clone();
        var t = this.v2.clone().sub(this.v1);
        return t.multiplyScalar(e).add(this.v1), t
    }, dr.prototype.getPointAt = function (e) {
        return this.getPoint(e)
    }, dr.prototype.getTangent = function () {
        return this.v2.clone().sub(this.v1).normalize()
    }, fr.prototype = Object.assign(Object.create(pr.prototype), {
        constructor: fr,
        add: function (e) {
            this.curves.push(e)
        },
        closePath: function () {
            var e = this.curves[0].getPoint(0),
                t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new dr(t, e))
        },
        getPoint: function (e) {
            var t = e * this.getLength(),
                i = this.getCurveLengths();
            for (e = 0; e < i.length;) {
                if (i[e] >= t) return t = i[e] - t, e = this.curves[e], i = e.getLength(), e.getPointAt(0 === i ? 0 : 1 - t / i);
                e++
            }
            return null
        },
        getLength: function () {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function () {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function () {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var e = [], t = 0, i = 0, n = this.curves.length; n > i; i++) t += this.curves[i].getLength(), e.push(t);
            return this.cacheLengths = e
        },
        getSpacedPoints: function (e) {
            void 0 === e && (e = 40);
            for (var t = [], i = 0; e >= i; i++) t.push(this.getPoint(i / e));
            return this.autoClose && t.push(t[0]), t
        },
        getPoints: function (e) {
            e = e || 12;
            for (var t, i = [], n = 0, r = this.curves; n < r.length; n++)
                for (var a = r[n], a = a.getPoints(a && a.isEllipseCurve ? 2 * e : a && a.isLineCurve ? 1 : a && a.isSplineCurve ? e * a.points.length : e), o = 0; o < a.length; o++) {
                    var s = a[o];
                    t && t.equals(s) || (i.push(s), t = s)
                }
            return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
        },
        createPointsGeometry: function (e) {
            return e = this.getPoints(e), this.createGeometry(e)
        },
        createSpacedPointsGeometry: function (e) {
            return e = this.getSpacedPoints(e), this.createGeometry(e)
        },
        createGeometry: function (e) {
            for (var t = new lt, i = 0, n = e.length; n > i; i++) {
                var r = e[i];
                t.vertices.push(new c(r.x, r.y, r.z || 0))
            }
            return t
        }
    }), mr.prototype = Object.create(pr.prototype), mr.prototype.constructor = mr, mr.prototype.isEllipseCurve = !0, mr.prototype.getPoint = function (e) {
        for (var t = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, r = Math.abs(n) < Number.EPSILON; 0 > n;) n += t;
        for (; n > t;) n -= t;
        n < Number.EPSILON && (n = r ? 0 : t), !0 !== this.aClockwise || r || (n = n === t ? -t : n - t), t = this.aStartAngle + e * n, e = this.aX + this.xRadius * Math.cos(t);
        var a = this.aY + this.yRadius * Math.sin(t);
        return 0 !== this.aRotation && (t = Math.cos(this.aRotation), n = Math.sin(this.aRotation), r = e - this.aX, a -= this.aY, e = r * t - a * n + this.aX, a = r * n + a * t + this.aY), new i(e, a)
    }, gr.prototype = Object.create(pr.prototype), gr.prototype.constructor = gr, gr.prototype.isSplineCurve = !0, gr.prototype.getPoint = function (e) {
        var t = this.points,
            n = (t.length - 1) * e;
        e = Math.floor(n);
        var n = n - e,
            r = t[0 === e ? e : e - 1],
            a = t[e],
            o = t[e > t.length - 2 ? t.length - 1 : e + 1],
            t = t[e > t.length - 3 ? t.length - 1 : e + 2];
        return new i(hr(n, r.x, a.x, o.x, t.x), hr(n, r.y, a.y, o.y, t.y))
    }, vr.prototype = Object.create(pr.prototype), vr.prototype.constructor = vr, vr.prototype.getPoint = function (e) {
        var t = this.v0,
            n = this.v1,
            r = this.v2,
            a = this.v3;
        return new i(ur(e, t.x, n.x, r.x, a.x), ur(e, t.y, n.y, r.y, a.y))
    }, yr.prototype = Object.create(pr.prototype), yr.prototype.constructor = yr, yr.prototype.getPoint = function (e) {
        var t = this.v0,
            n = this.v1,
            r = this.v2;
        return new i(lr(e, t.x, n.x, r.x), lr(e, t.y, n.y, r.y))
    };
    var Ja = Object.assign(Object.create(fr.prototype), {
        fromPoints: function (e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, i = e.length; i > t; t++) this.lineTo(e[t].x, e[t].y)
        },
        moveTo: function (e, t) {
            this.currentPoint.set(e, t)
        },
        lineTo: function (e, t) {
            var n = new dr(this.currentPoint.clone(), new i(e, t));
            this.curves.push(n), this.currentPoint.set(e, t)
        },
        quadraticCurveTo: function (e, t, n, r) {
            e = new yr(this.currentPoint.clone(), new i(e, t), new i(n, r)), this.curves.push(e), this.currentPoint.set(n, r)
        },
        bezierCurveTo: function (e, t, n, r, a, o) {
            e = new vr(this.currentPoint.clone(), new i(e, t), new i(n, r), new i(a, o)), this.curves.push(e), this.currentPoint.set(a, o)
        },
        splineThru: function (e) {
            var t = [this.currentPoint.clone()].concat(e),
                t = new gr(t);
            this.curves.push(t), this.currentPoint.copy(e[e.length - 1])
        },
        arc: function (e, t, i, n, r, a) {
            this.absarc(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, a)
        },
        absarc: function (e, t, i, n, r, a) {
            this.absellipse(e, t, i, i, n, r, a)
        },
        ellipse: function (e, t, i, n, r, a, o, s) {
            this.absellipse(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, a, o, s)
        },
        absellipse: function (e, t, i, n, r, a, o, s) {
            e = new mr(e, t, i, n, r, a, o, s), 0 < this.curves.length && (t = e.getPoint(0), t.equals(this.currentPoint) || this.lineTo(t.x, t.y)), this.curves.push(e), e = e.getPoint(1), this.currentPoint.copy(e)
        }
    });
    xr.prototype = Ja, Ja.constructor = xr, br.prototype = Object.assign(Object.create(Ja), {
        constructor: br,
        getPointsHoles: function (e) {
            for (var t = [], i = 0, n = this.holes.length; n > i; i++) t[i] = this.holes[i].getPoints(e);
            return t
        },
        extractAllPoints: function (e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        extractPoints: function (e) {
            return this.extractAllPoints(e)
        }
    }), Object.assign(_r.prototype, {
        moveTo: function (e, t) {
            this.currentPath = new xr, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
        },
        lineTo: function (e, t) {
            this.currentPath.lineTo(e, t)
        },
        quadraticCurveTo: function (e, t, i, n) {
            this.currentPath.quadraticCurveTo(e, t, i, n)
        },
        bezierCurveTo: function (e, t, i, n, r, a) {
            this.currentPath.bezierCurveTo(e, t, i, n, r, a)
        },
        splineThru: function (e) {
            this.currentPath.splineThru(e)
        },
        toShapes: function (e, t) {
            function i(e) {
                for (var t = [], i = 0, n = e.length; n > i; i++) {
                    var r = e[i],
                        a = new br;
                    a.curves = r.curves, t.push(a)
                }
                return t
            }

            function n(e, t) {
                for (var i = t.length, n = !1, r = i - 1, a = 0; i > a; r = a++) {
                    var o = t[r],
                        s = t[a],
                        c = s.x - o.x,
                        h = s.y - o.y;
                    if (Math.abs(h) > Number.EPSILON) {
                        if (0 > h && (o = t[a], c = -c, s = t[r], h = -h), !(e.y < o.y || e.y > s.y))
                            if (e.y === o.y) {
                                if (e.x === o.x) return !0
                            } else {
                                if (r = h * (e.x - o.x) - c * (e.y - o.y), 0 === r) return !0;
                                0 > r || (n = !n)
                            }
                    } else if (e.y === o.y && (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x)) return !0
                }
                return n
            }
            var r = za.isClockWise,
                a = this.subPaths;
            if (0 === a.length) return [];
            if (!0 === t) return i(a);
            var o, s, c, h = [];
            if (1 === a.length) return s = a[0], c = new br, c.curves = s.curves, h.push(c), h;
            var l = !r(a[0].getPoints()),
                l = e ? !l : l;
            c = [];
            var u, p = [],
                d = [],
                f = 0;
            p[f] = void 0, d[f] = [];
            for (var m = 0, g = a.length; g > m; m++) s = a[m], u = s.getPoints(), o = r(u), (o = e ? !o : o) ? (!l && p[f] && f++, p[f] = {
                s: new br,
                p: u
            }, p[f].s.curves = s.curves, l && f++, d[f] = []) : d[f].push({
                h: s,
                p: u[0]
            });
            if (!p[0]) return i(a);
            if (1 < p.length) {
                for (m = !1, s = [], r = 0, a = p.length; a > r; r++) c[r] = [];
                for (r = 0, a = p.length; a > r; r++)
                    for (o = d[r], l = 0; l < o.length; l++) {
                        for (f = o[l], u = !0, g = 0; g < p.length; g++) n(f.p, p[g].p) && (r !== g && s.push({
                            froms: r,
                            tos: g,
                            hole: l
                        }), u ? (u = !1, c[g].push(f)) : m = !0);
                        u && c[r].push(f)
                    }
                0 < s.length && (m || (d = c))
            }
            for (m = 0, r = p.length; r > m; m++)
                for (c = p[m].s, h.push(c), s = d[m], a = 0, o = s.length; o > a; a++) c.holes.push(s[a].h);
            return h
        }
    }), Object.assign(wr.prototype, {
        isFont: !0,
        generateShapes: function (e, t, i) {
            void 0 === t && (t = 100), void 0 === i && (i = 4);
            var n = this.data;
            e = String(e).split("");
            var r = t / n.resolution,
                a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                o = 0,
                s = 0;
            t = [];
            for (var c = 0; c < e.length; c++) {
                var h = e[c];
                if ("\n" === h) o = 0, s -= a;
                else {
                    var l;
                    l = r;
                    var u = o,
                        p = s;
                    if (h = n.glyphs[h] || n.glyphs["?"]) {
                        var d, f, m, g, v, y, x, b, _ = new _r,
                            w = [];
                        if (h.o)
                            for (var M = h._cachedOutline || (h._cachedOutline = h.o.split(" ")), E = 0, T = M.length; T > E;) switch (M[E++]) {
                                case "m":
                                    d = M[E++] * l + u, f = M[E++] * l + p, _.moveTo(d, f);
                                    break;
                                case "l":
                                    d = M[E++] * l + u, f = M[E++] * l + p, _.lineTo(d, f);
                                    break;
                                case "q":
                                    if (d = M[E++] * l + u, f = M[E++] * l + p, v = M[E++] * l + u, y = M[E++] * l + p, _.quadraticCurveTo(v, y, d, f), g = w[w.length - 1]) {
                                        m = g.x, g = g.y;
                                        for (var S = 1; i >= S; S++) {
                                            var A = S / i;
                                            lr(A, m, v, d), lr(A, g, y, f)
                                        }
                                    }
                                    break;
                                case "b":
                                    if (d = M[E++] * l + u, f = M[E++] * l + p, v = M[E++] * l + u, y = M[E++] * l + p, x = M[E++] * l + u, b = M[E++] * l + p, _.bezierCurveTo(v, y, x, b, d, f), g = w[w.length - 1])
                                        for (m = g.x, g = g.y, S = 1; i >= S; S++) A = S / i, ur(A, m, v, x, d), ur(A, g, y, b, f)
                            }
                        l = {
                            offsetX: h.ha * l,
                            path: _
                        }
                    } else l = void 0;
                    o += l.offsetX, t.push(l.path)
                }
            }
            for (i = [], n = 0, e = t.length; e > n; n++) Array.prototype.push.apply(i, t[n].toShapes());
            return i
        }
    }), Object.assign(Mr.prototype, {
        load: function (e, t, i, n) {
            var r = this;
            new Rn(this.manager).load(e, function (e) {
                var i;
                try {
                    i = JSON.parse(e)
                } catch (n) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(e.substring(65, e.length - 2))
                }
                e = r.parse(i), t && t(e)
            }, i, n)
        },
        parse: function (e) {
            return new wr(e)
        }
    });
    var Qa, Ka = {
        getContext: function () {
            return void 0 === Qa && (Qa = new(window.AudioContext || window.webkitAudioContext)), Qa
        },
        setContext: function (e) {
            Qa = e
        }
    };
    Object.assign(Er.prototype, {
        load: function (e, t, i, n) {
            var r = new Rn(this.manager);
            r.setResponseType("arraybuffer"), r.load(e, function (e) {
                Ka.getContext().decodeAudioData(e, function (e) {
                    t(e)
                })
            }, i, n)
        }
    }), Object.assign(Tr.prototype, {
        update: function () {
            var e, t, i, n, r, a, o, s, c = new h,
                l = new h;
            return function (h) {
                if (e !== this || t !== h.focus || i !== h.fov || n !== h.aspect * this.aspect || r !== h.near || a !== h.far || o !== h.zoom || s !== this.eyeSep) {
                    e = this, t = h.focus, i = h.fov, n = h.aspect * this.aspect, r = h.near, a = h.far, o = h.zoom;
                    var u = h.projectionMatrix.clone();
                    s = this.eyeSep / 2;
                    var p, d, f = s * r / t,
                        m = r * Math.tan(_a.DEG2RAD * i * .5) / o;
                    l.elements[12] = -s, c.elements[12] = s, p = -m * n + f, d = m * n + f, u.elements[0] = 2 * r / (d - p), u.elements[8] = (d + p) / (d - p), this.cameraL.projectionMatrix.copy(u), p = -m * n - f, d = m * n - f, u.elements[0] = 2 * r / (d - p), u.elements[8] = (d + p) / (d - p), this.cameraR.projectionMatrix.copy(u)
                }
                this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(l), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(c)
            }
        }()
    }), Sr.prototype = Object.create(at.prototype), Sr.prototype.constructor = Sr, Ar.prototype = Object.assign(Object.create(at.prototype), {
        constructor: Ar,
        getInput: function () {
            return this.gain
        },
        removeFilter: function () {
            null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
        },
        getFilter: function () {
            return this.filter
        },
        setFilter: function (e) {
            null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
        },
        getMasterVolume: function () {
            return this.gain.gain.value
        },
        setMasterVolume: function (e) {
            this.gain.gain.value = e
        },
        updateMatrixWorld: function () {
            var e = new c,
                t = new s,
                i = new c,
                n = new c;
            return function (r) {
                at.prototype.updateMatrixWorld.call(this, r), r = this.context.listener;
                var a = this.up;
                this.matrixWorld.decompose(e, t, i), n.set(0, 0, -1).applyQuaternion(t), r.positionX ? (r.positionX.setValueAtTime(e.x, this.context.currentTime), r.positionY.setValueAtTime(e.y, this.context.currentTime), r.positionZ.setValueAtTime(e.z, this.context.currentTime), r.forwardX.setValueAtTime(n.x, this.context.currentTime), r.forwardY.setValueAtTime(n.y, this.context.currentTime), r.forwardZ.setValueAtTime(n.z, this.context.currentTime), r.upX.setValueAtTime(a.x, this.context.currentTime), r.upY.setValueAtTime(a.y, this.context.currentTime), r.upZ.setValueAtTime(a.z, this.context.currentTime)) : (r.setPosition(e.x, e.y, e.z), r.setOrientation(n.x, n.y, n.z, a.x, a.y, a.z))
            }
        }()
    }), Rr.prototype = Object.assign(Object.create(at.prototype), {
        constructor: Rr,
        getOutput: function () {
            return this.gain
        },
        setNodeSource: function (e) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
        },
        setBuffer: function (e) {
            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
        },
        play: function () {
            if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
            else {
                if (!1 !== this.hasPlaybackControl) {
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), e.playbackRate.setValueAtTime(this.playbackRate, this.startTime), e.start(0, this.startTime), this.isPlaying = !0, this.source = e, this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
        },
        pause: function () {
            return !1 !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this) : (console.warn("THREE.Audio: this Audio has no playback control."), void 0)
        },
        stop: function () {
            return !1 !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = 0, this.isPlaying = !1, this) : (console.warn("THREE.Audio: this Audio has no playback control."), void 0)
        },
        connect: function () {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; t > e; e++) this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function () {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; t > e; e++) this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function () {
            return this.filters
        },
        setFilters: function (e) {
            return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
        },
        getFilter: function () {
            return this.getFilters()[0]
        },
        setFilter: function (e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function (e) {
            return !1 !== this.hasPlaybackControl ? (this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this) : (console.warn("THREE.Audio: this Audio has no playback control."), void 0)
        },
        getPlaybackRate: function () {
            return this.playbackRate
        },
        onEnded: function () {
            this.isPlaying = !1
        },
        getLoop: function () {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function (e) {
            return !1 !== this.hasPlaybackControl ? (this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this) : (console.warn("THREE.Audio: this Audio has no playback control."), void 0)
        },
        getVolume: function () {
            return this.gain.gain.value
        },
        setVolume: function (e) {
            return this.gain.gain.value = e, this
        }
    }), Lr.prototype = Object.assign(Object.create(Rr.prototype), {
        constructor: Lr,
        getOutput: function () {
            return this.panner
        },
        getRefDistance: function () {
            return this.panner.refDistance
        },
        setRefDistance: function (e) {
            this.panner.refDistance = e
        },
        getRolloffFactor: function () {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function (e) {
            this.panner.rolloffFactor = e
        },
        getDistanceModel: function () {
            return this.panner.distanceModel
        },
        setDistanceModel: function (e) {
            this.panner.distanceModel = e
        },
        getMaxDistance: function () {
            return this.panner.maxDistance
        },
        setMaxDistance: function (e) {
            this.panner.maxDistance = e
        },
        updateMatrixWorld: function () {
            var e = new c;
            return function (t) {
                at.prototype.updateMatrixWorld.call(this, t), e.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(e.x, e.y, e.z)
            }
        }()
    }), Object.assign(Pr.prototype, {
        getFrequencyData: function () {
            return this.analyser.getByteFrequencyData(this.data), this.data
        },
        getAverageFrequency: function () {
            for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++) e += t[i];
            return e / t.length
        }
    }), Object.assign(Cr.prototype, {
        accumulate: function (e, t) {
            var i = this.buffer,
                n = this.valueSize,
                r = e * n + n,
                a = this.cumulativeWeight;
            if (0 === a) {
                for (a = 0; a !== n; ++a) i[r + a] = i[a];
                a = t
            } else a += t, this._mixBufferRegion(i, r, 0, t / a, n);
            this.cumulativeWeight = a
        },
        apply: function (e) {
            var t = this.valueSize,
                i = this.buffer;
            e = e * t + t;
            var n = this.cumulativeWeight,
                r = this.binding;
            this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, e, 3 * t, 1 - n, t);
            for (var n = t, a = t + t; n !== a; ++n)
                if (i[n] !== i[n + t]) {
                    r.setValue(i, e);
                    break
                }
        },
        saveOriginalState: function () {
            var e = this.buffer,
                t = this.valueSize,
                i = 3 * t;
            this.binding.getValue(e, i);
            for (var n = t; n !== i; ++n) e[n] = e[i + n % t];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function () {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        },
        _select: function (e, t, i, n, r) {
            if (n >= .5)
                for (n = 0; n !== r; ++n) e[t + n] = e[i + n]
        },
        _slerp: function (e, t, i, n) {
            s.slerpFlat(e, t, e, t, e, i, n)
        },
        _lerp: function (e, t, i, n, r) {
            for (var a = 1 - n, o = 0; o !== r; ++o) {
                var s = t + o;
                e[s] = e[s] * a + e[i + o] * n
            }
        }
    }), Object.assign(Ir.prototype, {
        getValue: function (e, t) {
            this.bind();
            var i = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== i && i.getValue(e, t)
        },
        setValue: function (e, t) {
            for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(e, t)
        },
        bind: function () {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
        },
        unbind: function () {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
        }
    }), Object.assign(Ur, {
        Composite: Ir,
        create: function (e, t, i) {
            return e && e.isAnimationObjectGroup ? new Ur.Composite(e, t, i) : new Ur(e, t, i)
        },
        sanitizeNodeName: function (e) {
            return e.replace(/\s/g, "_").replace(/[^\w-]/g, "")
        },
        parseTrackName: function () {
            var e = new RegExp("^" + /((?:[\w-]+[\/:])*)/.source + /([\w-\.]+)?/.source + /(?:\.([\w-]+)(?:\[(.+)\])?)?/.source + /\.([\w-]+)(?:\[(.+)\])?/.source + "$"),
                t = ["material", "materials", "bones"];
            return function (i) {
                var n = e.exec(i);
                if (!n) throw Error("PropertyBinding: Cannot parse trackName: " + i);
                var n = {
                        nodeName: n[2],
                        objectName: n[3],
                        objectIndex: n[4],
                        propertyName: n[5],
                        propertyIndex: n[6]
                    },
                    r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r) {
                    var a = n.nodeName.substring(r + 1); - 1 !== t.indexOf(a) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = a)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + i);
                return n
            }
        }(),
        findNode: function (e, t) {
            if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                var i = function (e) {
                    for (var i = 0; i < e.bones.length; i++) {
                        var n = e.bones[i];
                        if (n.name === t) return n
                    }
                    return null
                }(e.skeleton);
                if (i) return i
            }
            if (e.children) {
                var n = function (e) {
                    for (var i = 0; i < e.length; i++) {
                        var r = e[i];
                        if (r.name === t || r.uuid === t || (r = n(r.children))) return r
                    }
                    return null
                };
                if (i = n(e.children)) return i
            }
            return null
        }
    }), Object.assign(Ur.prototype, {
        _getValue_unavailable: function () {},
        _setValue_unavailable: function () {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function (e, t) {
            e[t] = this.node[this.propertyName]
        }, function (e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) e[t++] = i[n]
        }, function (e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }, function (e, t) {
            this.resolvedProperty.toArray(e, t)
        }],
        SetterByBindingTypeAndVersioning: [
            [function (e, t) {
                this.node[this.propertyName] = e[t]
            }, function (e, t) {
                this.node[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
            }, function (e, t) {
                this.node[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++]
            }, function (e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                this.targetObject.needsUpdate = !0
            }, function (e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }, function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
            }, function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (e, t) {
                this.resolvedProperty.fromArray(e, t)
            }, function (e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
            }, function (e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
            }]
        ],
        getValue: function (e, t) {
            this.bind(), this.getValue(e, t)
        },
        setValue: function (e, t) {
            this.bind(), this.setValue(e, t)
        },
        bind: function () {
            var e = this.node,
                t = this.parsedPath,
                i = t.objectName,
                n = t.propertyName,
                r = t.propertyIndex;
            if (e || (this.node = e = Ur.findNode(this.rootNode, t.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                if (i) {
                    var a = t.objectIndex;
                    switch (i) {
                        case "materials":
                            if (!e.material) return console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this), void 0;
                            if (!e.material.materials) return console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this), void 0;
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this), void 0;
                            for (e = e.skeleton.bones, i = 0; i < e.length; i++)
                                if (e[i].name === a) {
                                    a = i;
                                    break
                                }
                            break;
                        default:
                            if (void 0 === e[i]) return console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this), void 0;
                            e = e[i]
                    }
                    if (void 0 !== a) {
                        if (void 0 === e[a]) return console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e), void 0;
                        e = e[a]
                    }
                }
                if (a = e[n], void 0 === a) console.error("THREE.PropertyBinding: Trying to update property for track: " + t.nodeName + "." + n + " but it wasn't found.", e);
                else {
                    if (t = this.Versioning.None, void 0 !== e.needsUpdate ? (t = this.Versioning.NeedsUpdate, this.targetObject = e) : void 0 !== e.matrixWorldNeedsUpdate && (t = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = e), i = this.BindingType.Direct, void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry) return console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this), void 0;
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes) return console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this), void 0;
                                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                                    if (e.geometry.morphAttributes.position[i].name === r) {
                                        r = i;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets) return console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this), void 0;
                                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                                    if (e.geometry.morphTargets[i].name === r) {
                                        r = i;
                                        break
                                    }
                            }
                        }
                        i = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r
                    } else void 0 !== a.fromArray && void 0 !== a.toArray ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (i = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][t]
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function () {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(Ur.prototype, {
        _getValue_unbound: Ur.prototype.getValue,
        _setValue_unbound: Ur.prototype.setValue
    }), Object.assign(Nr.prototype, {
        isAnimationObjectGroup: !0,
        add: function () {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, c = 0, h = arguments.length; c !== h; ++c) {
                var l = arguments[c],
                    u = l.uuid,
                    p = n[u];
                if (void 0 === p) {
                    p = t++, n[u] = p, e.push(l);
                    for (var u = 0, d = s; u !== d; ++u) o[u].push(new Ur(l, r[u], a[u]))
                } else if (i > p) {
                    var f = --i,
                        d = e[f];
                    for (n[d.uuid] = p, e[p] = d, n[u] = f, e[f] = l, u = 0, d = s; u !== d; ++u) {
                        var m = o[u],
                            g = m[p];
                        m[p] = m[f], void 0 === g && (g = new Ur(l, r[u], a[u])), m[f] = g
                    }
                } else void 0 !== e[p] && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = i
        },
        remove: function () {
            for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, a = 0, o = arguments.length; a !== o; ++a) {
                var s = arguments[a],
                    c = s.uuid,
                    h = i[c];
                if (void 0 !== h && h >= t) {
                    var l = t++,
                        u = e[l];
                    for (i[u.uuid] = h, e[h] = u, i[c] = l, e[l] = s, s = 0, c = r; s !== c; ++s) {
                        var u = n[s],
                            p = u[h];
                        u[h] = u[l], u[l] = p
                    }
                }
            }
            this.nCachedObjects_ = t
        },
        uncache: function () {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                var c = arguments[o].uuid,
                    h = n[c];
                if (void 0 !== h)
                    if (delete n[c], i > h) {
                        var c = --i,
                            l = e[c],
                            u = --t,
                            p = e[u];
                        for (n[l.uuid] = h, e[h] = l, n[p.uuid] = c, e[c] = p, e.pop(), l = 0, p = a; l !== p; ++l) {
                            var d = r[l],
                                f = d[u];
                            d[h] = d[c], d[c] = f, d.pop()
                        }
                    } else
                        for (u = --t, p = e[u], n[p.uuid] = h, e[h] = p, e.pop(), l = 0, p = a; l !== p; ++l) d = r[l], d[h] = d[u], d.pop()
            }
            this.nCachedObjects_ = i
        },
        subscribe_: function (e, t) {
            var i = this._bindingsIndicesByPath,
                n = i[e],
                r = this._bindings;
            if (void 0 !== n) return r[n];
            var a = this._paths,
                o = this._parsedPaths,
                s = this._objects,
                c = this.nCachedObjects_,
                h = Array(s.length),
                n = r.length;
            for (i[e] = n, a.push(e), o.push(t), r.push(h), i = c, n = s.length; i !== n; ++i) h[i] = new Ur(s[i], e, t);
            return h
        },
        unsubscribe_: function (e) {
            var t = this._bindingsIndicesByPath,
                i = t[e];
            if (void 0 !== i) {
                var n = this._paths,
                    r = this._parsedPaths,
                    a = this._bindings,
                    o = a.length - 1,
                    s = a[o];
                t[e[o]] = i, a[i] = s, a.pop(), r[i] = r[o], r.pop(), n[i] = n[o], n.pop()
            }
        }
    }), Object.assign(Dr.prototype, {
        play: function () {
            return this._mixer._activateAction(this), this
        },
        stop: function () {
            return this._mixer._deactivateAction(this), this.reset()
        },
        reset: function () {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        },
        isRunning: function () {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function () {
            return this._mixer._isActiveAction(this)
        },
        startAt: function (e) {
            return this._startTime = e, this
        },
        setLoop: function (e, t) {
            return this.loop = e, this.repetitions = t, this
        },
        setEffectiveWeight: function (e) {
            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
        },
        getEffectiveWeight: function () {
            return this._effectiveWeight
        },
        fadeIn: function (e) {
            return this._scheduleFading(e, 0, 1)
        },
        fadeOut: function (e) {
            return this._scheduleFading(e, 1, 0)
        },
        crossFadeFrom: function (e, t, i) {
            if (e.fadeOut(t), this.fadeIn(t), i) {
                i = this._clip.duration;
                var n = e._clip.duration,
                    r = i / n;
                e.warp(1, n / i, t), this.warp(r, 1, t)
            }
            return this
        },
        crossFadeTo: function (e, t, i) {
            return e.crossFadeFrom(this, t, i)
        },
        stopFading: function () {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        },
        setEffectiveTimeScale: function (e) {
            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
        },
        getEffectiveTimeScale: function () {
            return this._effectiveTimeScale
        },
        setDuration: function (e) {
            return this.timeScale = this._clip.duration / e, this.stopWarping()
        },
        syncWith: function (e) {
            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
        },
        halt: function (e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        },
        warp: function (e, t, i) {
            var n = this._mixer,
                r = n.time,
                a = this._timeScaleInterpolant,
                o = this.timeScale;
            return null === a && (this._timeScaleInterpolant = a = n._lendControlInterpolant()), n = a.parameterPositions, a = a.sampleValues, n[0] = r, n[1] = r + i, a[0] = e / o, a[1] = t / o, this
        },
        stopWarping: function () {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        },
        getMixer: function () {
            return this._mixer
        },
        getClip: function () {
            return this._clip
        },
        getRoot: function () {
            return this._localRoot || this._mixer._root
        },
        _update: function (e, t, i, n) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    if (t = (e - r) * i, 0 > t || 0 === i) return;
                    this._startTime = null, t *= i
                }
                if (t *= this._updateTimeScale(e), i = this._updateTime(t), e = this._updateWeight(e), e > 0) {
                    t = this._interpolants;
                    for (var r = this._propertyBindings, a = 0, o = t.length; a !== o; ++a) t[a].evaluate(i), r[a].accumulate(n, e)
                }
            } else this._updateWeight(e)
        },
        _updateWeight: function (e) {
            var t = 0;
            if (this.enabled) {
                var t = this.weight,
                    i = this._weightInterpolant;
                if (null !== i) {
                    var n = i.evaluate(e)[0],
                        t = t * n;
                    e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t
        },
        _updateTimeScale: function (e) {
            var t = 0;
            if (!this.paused) {
                var t = this.timeScale,
                    i = this._timeScaleInterpolant;
                if (null !== i) {
                    var n = i.evaluate(e)[0],
                        t = t * n;
                    e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                }
            }
            return this._effectiveTimeScale = t
        },
        _updateTime: function (e) {
            var t = this.time + e;
            if (0 === e) return t;
            var i = this._clip.duration,
                n = this.loop,
                r = this._loopCount;
            if (2200 === n) e: {
                if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), t >= i) t = i;
                else {
                    if (!(0 > t)) break e;
                    t = 0
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 > e ? -1 : 1
                })
            }
            else {
                if (n = 2202 === n, -1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, n)) : this._setEndings(0 === this.repetitions, !0, n)), t >= i || 0 > t) {
                    var a = Math.floor(t / i),
                        t = t - i * a,
                        r = r + Math.abs(a),
                        o = this.repetitions - r;
                    0 > o ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? i : 0, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    })) : (0 === o ? (e = 0 > e, this._setEndings(e, !e, n)) : this._setEndings(!1, !1, n), this._loopCount = r, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    }))
                }
                if (n && 1 === (1 & r)) return this.time = t, i - t
            }
            return this.time = t
        },
        _setEndings: function (e, t, i) {
            var n = this._interpolantSettings;
            i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function (e, t, i) {
            var n = this._mixer,
                r = n.time,
                a = this._weightInterpolant;
            return null === a && (this._weightInterpolant = a = n._lendControlInterpolant()), n = a.parameterPositions, a = a.sampleValues, n[0] = r, a[0] = t, n[1] = r + e, a[1] = i, this
        }
    }), Object.assign(Or.prototype, t.prototype, {
        _bindAction: function (e, t) {
            var i = e._localRoot || this._root,
                n = e._clip.tracks,
                r = n.length,
                a = e._propertyBindings,
                o = e._interpolants,
                s = i.uuid,
                c = this._bindingsByRootAndName,
                h = c[s];
            for (void 0 === h && (h = {}, c[s] = h), c = 0; c !== r; ++c) {
                var l = n[c],
                    u = l.name,
                    p = h[u];
                if (void 0 === p) {
                    if (p = a[c], void 0 !== p) {
                        null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, u));
                        continue
                    }
                    p = new Cr(Ur.create(i, u, t && t._propertyBindings[c].binding.parsedPath), l.ValueTypeName, l.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, s, u)
                }
                a[c] = p, o[c].resultBuffer = p.buffer
            }
        },
        _activateAction: function (e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid,
                        i = e._clip.uuid,
                        n = this._actionsByClip[i];
                    this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t)
                }
                for (t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
                    var r = t[i];
                    0 === r.useCount++ && (this._lendBinding(r), r.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function (e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
                    var r = t[i];
                    0 === --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function () {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function (e) {
            return e = e._cacheIndex, null !== e && e < this._nActiveActions
        },
        _addInactiveAction: function (e, t, i) {
            var n = this._actions,
                r = this._actionsByClip,
                a = r[t];
            void 0 === a ? (a = {
                knownActions: [e],
                actionByRoot: {}
            }, e._byClipCacheIndex = 0, r[t] = a) : (t = a.knownActions, e._byClipCacheIndex = t.length, t.push(e)), e._cacheIndex = n.length, n.push(e), a.actionByRoot[i] = e
        },
        _removeInactiveAction: function (e) {
            var t = this._actions,
                i = t[t.length - 1],
                n = e._cacheIndex;
            i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null;
            var t = e._clip.uuid,
                i = this._actionsByClip,
                n = i[t],
                r = n.knownActions,
                a = r[r.length - 1],
                o = e._byClipCacheIndex;
            a._byClipCacheIndex = o, r[o] = a, r.pop(), e._byClipCacheIndex = null, delete n.actionByRoot[(e._localRoot || this._root).uuid], 0 === r.length && delete i[t], this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function (e) {
            e = e._propertyBindings;
            for (var t = 0, i = e.length; t !== i; ++t) {
                var n = e[t];
                0 === --n.referenceCount && this._removeInactiveBinding(n)
            }
        },
        _lendAction: function (e) {
            var t = this._actions,
                i = e._cacheIndex,
                n = this._nActiveActions++,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _takeBackAction: function (e) {
            var t = this._actions,
                i = e._cacheIndex,
                n = --this._nActiveActions,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _addInactiveBinding: function (e, t, i) {
            var n = this._bindingsByRootAndName,
                r = n[t],
                a = this._bindings;
            void 0 === r && (r = {}, n[t] = r), r[i] = e, e._cacheIndex = a.length, a.push(e)
        },
        _removeInactiveBinding: function (e) {
            var t = this._bindings,
                i = e.binding,
                n = i.rootNode.uuid,
                i = i.path,
                r = this._bindingsByRootAndName,
                a = r[n],
                o = t[t.length - 1];
            e = e._cacheIndex, o._cacheIndex = e, t[e] = o, t.pop(), delete a[i];
            e: {
                for (var s in a) break e;delete r[n]
            }
        },
        _lendBinding: function (e) {
            var t = this._bindings,
                i = e._cacheIndex,
                n = this._nActiveBindings++,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _takeBackBinding: function (e) {
            var t = this._bindings,
                i = e._cacheIndex,
                n = --this._nActiveBindings,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _lendControlInterpolant: function () {
            var e = this._controlInterpolants,
                t = this._nActiveControlInterpolants++,
                i = e[t];
            return void 0 === i && (i = new Xn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = t, e[t] = i), i
        },
        _takeBackControlInterpolant: function (e) {
            var t = this._controlInterpolants,
                i = e.__cacheIndex,
                n = --this._nActiveControlInterpolants,
                r = t[n];
            e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function (e, t) {
            var i = t || this._root,
                n = i.uuid,
                r = "string" == typeof e ? nr.findByName(i, e) : e,
                i = null !== r ? r.uuid : e,
                a = this._actionsByClip[i],
                o = null;
            if (void 0 !== a) {
                if (o = a.actionByRoot[n], void 0 !== o) return o;
                o = a.knownActions[0], null === r && (r = o._clip)
            }
            return null === r ? null : (r = new Dr(this, r, t), this._bindAction(r, o), this._addInactiveAction(r, i, n), r)
        },
        existingAction: function (e, t) {
            var i = t || this._root,
                n = i.uuid,
                i = "string" == typeof e ? nr.findByName(i, e) : e,
                i = this._actionsByClip[i ? i.uuid : e];
            return void 0 !== i ? i.actionByRoot[n] || null : null
        },
        stopAllAction: function () {
            for (var e = this._actions, t = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== t; ++r) e[r].reset();
            for (r = 0; r !== n; ++r) i[r].useCount = 0;
            return this
        },
        update: function (e) {
            e *= this.timeScale;
            for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== i; ++o) t[o]._update(n, e, r, a);
            for (e = this._bindings, t = this._nActiveBindings, o = 0; o !== t; ++o) e[o].apply(a);
            return this
        },
        getRoot: function () {
            return this._root
        },
        uncacheClip: function (e) {
            var t = this._actions;
            e = e.uuid;
            var i = this._actionsByClip,
                n = i[e];
            if (void 0 !== n) {
                for (var n = n.knownActions, r = 0, a = n.length; r !== a; ++r) {
                    var o = n[r];
                    this._deactivateAction(o);
                    var s = o._cacheIndex,
                        c = t[t.length - 1];
                    o._cacheIndex = null, o._byClipCacheIndex = null, c._cacheIndex = s, t[s] = c, t.pop(), this._removeInactiveBindingsForAction(o)
                }
                delete i[e]
            }
        },
        uncacheRoot: function (e) {
            e = e.uuid;
            var t, i = this._actionsByClip;
            for (t in i) {
                var n = i[t].actionByRoot[e];
                void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
            if (t = this._bindingsByRootAndName[e], void 0 !== t)
                for (var r in t) e = t[r], e.restoreOriginalState(), this._removeInactiveBinding(e)
        },
        uncacheAction: function (e, t) {
            var i = this.existingAction(e, t);
            null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
        }
    }), Fr.prototype.clone = function () {
        return new Fr(void 0 === this.value.clone ? this.value : this.value.clone())
    }, Br.prototype = Object.assign(Object.create(Mt.prototype), {
        constructor: Br,
        isInstancedBufferGeometry: !0,
        addGroup: function (e, t, i) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: i
            })
        },
        copy: function (e) {
            var t = e.index;
            null !== t && this.setIndex(t.clone());
            var i, t = e.attributes;
            for (i in t) this.addAttribute(i, t[i].clone());
            for (e = e.groups, i = 0, t = e.length; t > i; i++) {
                var n = e[i];
                this.addGroup(n.start, n.count, n.materialIndex)
            }
            return this
        }
    }), Object.defineProperties(zr.prototype, {
        count: {
            get: function () {
                return this.data.count
            }
        },
        array: {
            get: function () {
                return this.data.array
            }
        }
    }), Object.assign(zr.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t, this
        },
        setY: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
        },
        setZ: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
        },
        setW: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
        },
        getX: function (e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function (e, t, i) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
        },
        setXYZ: function (e, t, i, n) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this
        },
        setXYZW: function (e, t, i, n, r) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this
        }
    }), Object.defineProperty(Gr.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(Gr.prototype, {
        isInterleavedBuffer: !0,
        setArray: function (e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e
        },
        setDynamic: function (e) {
            return this.dynamic = e, this
        },
        copy: function (e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
        },
        copyAt: function (e, t, i) {
            e *= this.stride, i *= t.stride;
            for (var n = 0, r = this.stride; r > n; n++) this.array[e + n] = t.array[i + n];
            return this
        },
        set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        onUpload: function (e) {
            return this.onUploadCallback = e, this
        }
    }), Hr.prototype = Object.assign(Object.create(Gr.prototype), {
        constructor: Hr,
        isInstancedInterleavedBuffer: !0,
        copy: function (e) {
            return Gr.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        }
    }), Vr.prototype = Object.assign(Object.create(ut.prototype), {
        constructor: Vr,
        isInstancedBufferAttribute: !0,
        copy: function (e) {
            return ut.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        }
    }), Object.assign(kr.prototype, {
        linePrecision: 1,
        set: function (e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function (e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function (e, t) {
            var i = [];
            return Wr(e, this, i, t), i.sort(jr), i
        },
        intersectObjects: function (e, t) {
            var i = [];
            if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
            for (var n = 0, r = e.length; r > n; n++) Wr(e[n], this, i, t);
            return i.sort(jr), i
        }
    }), Object.assign(Xr.prototype, {
        start: function () {
            this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
        },
        stop: function () {
            this.getElapsedTime(), this.autoStart = this.running = !1
        },
        getElapsedTime: function () {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function () {
            var e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now(),
                    e = (t - this.oldTime) / 1e3;
                this.oldTime = t, this.elapsedTime += e
            }
            return e
        }
    }), Object.assign(qr.prototype, {
        set: function (e, t, i) {
            return this.radius = e, this.phi = t, this.theta = i, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
        },
        makeSafe: function () {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        },
        setFromVector3: function (e) {
            return this.radius = e.length(), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(e.x, e.z), this.phi = Math.acos(_a.clamp(e.y / this.radius, -1, 1))), this
        }
    }), Object.assign(Yr.prototype, {
        set: function (e, t, i) {
            return this.radius = e, this.theta = t, this.y = i, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
        },
        setFromVector3: function (e) {
            return this.radius = Math.sqrt(e.x * e.x + e.z * e.z), this.theta = Math.atan2(e.x, e.z), this.y = e.y, this
        }
    }), Zr.prototype = Object.create(It.prototype), Zr.prototype.constructor = Zr, Zr.prototype.createAnimation = function (e, t, i, n) {
        t = {
            start: t,
            end: i,
            length: i - t + 1,
            fps: n,
            duration: (i - t) / n,
            lastFrame: 0,
            currentFrame: 0,
            active: !1,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: !1,
            mirroredLoop: !1
        }, this.animationsMap[e] = t, this.animationsList.push(t)
    }, Zr.prototype.autoCreateAnimations = function (e) {
        for (var t, i = /([a-z]+)_?(\d+)/i, n = {}, r = this.geometry, a = 0, o = r.morphTargets.length; o > a; a++) {
            var s = r.morphTargets[a].name.match(i);
            if (s && 1 < s.length) {
                var c = s[1];
                n[c] || (n[c] = {
                    start: 1 / 0,
                    end: -1 / 0
                }), s = n[c], a < s.start && (s.start = a), a > s.end && (s.end = a), t || (t = c)
            }
        }
        for (c in n) s = n[c], this.createAnimation(c, s.start, s.end, e);
        this.firstAnimation = t
    }, Zr.prototype.setAnimationDirectionForward = function (e) {
        (e = this.animationsMap[e]) && (e.direction = 1, e.directionBackwards = !1)
    }, Zr.prototype.setAnimationDirectionBackward = function (e) {
        (e = this.animationsMap[e]) && (e.direction = -1, e.directionBackwards = !0)
    }, Zr.prototype.setAnimationFPS = function (e, t) {
        var i = this.animationsMap[e];
        i && (i.fps = t, i.duration = (i.end - i.start) / i.fps)
    }, Zr.prototype.setAnimationDuration = function (e, t) {
        var i = this.animationsMap[e];
        i && (i.duration = t, i.fps = (i.end - i.start) / i.duration)
    }, Zr.prototype.setAnimationWeight = function (e, t) {
        var i = this.animationsMap[e];
        i && (i.weight = t)
    }, Zr.prototype.setAnimationTime = function (e, t) {
        var i = this.animationsMap[e];
        i && (i.time = t)
    }, Zr.prototype.getAnimationTime = function (e) {
        var t = 0;
        return (e = this.animationsMap[e]) && (t = e.time), t
    }, Zr.prototype.getAnimationDuration = function (e) {
        var t = -1;
        return (e = this.animationsMap[e]) && (t = e.duration), t
    }, Zr.prototype.playAnimation = function (e) {
        var t = this.animationsMap[e];
        t ? (t.time = 0, t.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + e + "] undefined in .playAnimation()")
    }, Zr.prototype.stopAnimation = function (e) {
        (e = this.animationsMap[e]) && (e.active = !1)
    }, Zr.prototype.update = function (e) {
        for (var t = 0, i = this.animationsList.length; i > t; t++) {
            var n = this.animationsList[t];
            if (n.active) {
                var r = n.duration / n.length;
                n.time += n.direction * e, n.mirroredLoop ? (n.time > n.duration || 0 > n.time) && (n.direction *= -1, n.time > n.duration && (n.time = n.duration, n.directionBackwards = !0), 0 > n.time && (n.time = 0, n.directionBackwards = !1)) : (n.time %= n.duration, 0 > n.time && (n.time += n.duration));
                var a = n.start + _a.clamp(Math.floor(n.time / r), 0, n.length - 1),
                    o = n.weight;
                a !== n.currentFrame && (this.morphTargetInfluences[n.lastFrame] = 0, this.morphTargetInfluences[n.currentFrame] = 1 * o, this.morphTargetInfluences[a] = 0, n.lastFrame = n.currentFrame, n.currentFrame = a), r = n.time % r / r, n.directionBackwards && (r = 1 - r), n.currentFrame !== n.lastFrame ? (this.morphTargetInfluences[n.currentFrame] = r * o, this.morphTargetInfluences[n.lastFrame] = (1 - r) * o) : this.morphTargetInfluences[n.currentFrame] = o
            }
        }
    }, Jr.prototype = Object.create(at.prototype), Jr.prototype.constructor = Jr, Jr.prototype.isImmediateRenderObject = !0, Qr.prototype = Object.create(Ei.prototype), Qr.prototype.constructor = Qr, Qr.prototype.update = function () {
        var e = new c,
            t = new c,
            i = new K;
        return function () {
            var n = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            var r = this.object.matrixWorld,
                a = this.geometry.attributes.position,
                o = this.object.geometry;
            if (o && o.isGeometry)
                for (var s = o.vertices, c = o.faces, h = o = 0, l = c.length; l > h; h++)
                    for (var u = c[h], p = 0, d = u.vertexNormals.length; d > p; p++) {
                        var f = u.vertexNormals[p];
                        e.copy(s[u[n[p]]]).applyMatrix4(r), t.copy(f).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), a.setXYZ(o, e.x, e.y, e.z), o += 1, a.setXYZ(o, t.x, t.y, t.z), o += 1
                    } else if (o && o.isBufferGeometry)
                        for (n = o.attributes.position, s = o.attributes.normal, p = o = 0, d = n.count; d > p; p++) e.set(n.getX(p), n.getY(p), n.getZ(p)).applyMatrix4(r), t.set(s.getX(p), s.getY(p), s.getZ(p)), t.applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), a.setXYZ(o, e.x, e.y, e.z), o += 1, a.setXYZ(o, t.x, t.y, t.z), o += 1;
            a.needsUpdate = !0
        }
    }(), Kr.prototype = Object.create(at.prototype), Kr.prototype.constructor = Kr, Kr.prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, Kr.prototype.update = function () {
        var e = new c,
            t = new c;
        return function () {
            this.light.updateMatrixWorld();
            var i = this.light.distance ? this.light.distance : 1e3,
                n = i * Math.tan(this.light.angle);
            this.cone.scale.set(n, n, i), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), this.cone.material.color.copy(this.light.color)
        }
    }(), ea.prototype = Object.create(Ei.prototype), ea.prototype.constructor = ea, ea.prototype.onBeforeRender = function () {
        var e = new c,
            t = new h,
            i = new h;
        return function () {
            var n = this.bones,
                r = this.geometry,
                a = r.getAttribute("position");
            i.getInverse(this.root.matrixWorld);
            for (var o = 0, s = 0; o < n.length; o++) {
                var c = n[o];
                c.parent && c.parent.isBone && (t.multiplyMatrices(i, c.matrixWorld), e.setFromMatrixPosition(t), a.setXYZ(s, e.x, e.y, e.z), t.multiplyMatrices(i, c.parent.matrixWorld), e.setFromMatrixPosition(t), a.setXYZ(s + 1, e.x, e.y, e.z), s += 2)
            }
            r.getAttribute("position").needsUpdate = !0
        }
    }(), ta.prototype = Object.create(It.prototype), ta.prototype.constructor = ta, ta.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose()
    }, ta.prototype.update = function () {
        this.material.color.copy(this.light.color)
    }, ia.prototype = Object.create(at.prototype), ia.prototype.constructor = ia, ia.prototype.dispose = function () {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, ia.prototype.update = function () {
        var e = this.children[0];
        e.material.color.copy(this.light.color);
        var t = .5 * this.light.width,
            i = .5 * this.light.height,
            e = e.geometry.attributes.position,
            n = e.array;
        n[0] = t, n[1] = -i, n[2] = 0, n[3] = t, n[4] = i, n[5] = 0, n[6] = -t, n[7] = i, n[8] = 0, n[9] = -t, n[10] = -i, n[11] = 0, n[12] = t, n[13] = -i, n[14] = 0, e.needsUpdate = !0
    }, na.prototype = Object.create(at.prototype), na.prototype.constructor = na, na.prototype.dispose = function () {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, na.prototype.update = function () {
        var e = new c,
            t = new k,
            i = new k;
        return function () {
            var n = this.children[0],
                r = n.geometry.getAttribute("color");
            t.copy(this.light.color), i.copy(this.light.groundColor);
            for (var a = 0, o = r.count; o > a; a++) {
                var s = o / 2 > a ? t : i;
                r.setXYZ(a, s.r, s.g, s.b)
            }
            n.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()), r.needsUpdate = !0
        }
    }(), ra.prototype = Object.create(Ei.prototype), ra.prototype.constructor = ra, aa.prototype = Object.create(Ei.prototype), aa.prototype.constructor = aa, oa.prototype = Object.create(Ei.prototype), oa.prototype.constructor = oa, oa.prototype.update = function () {
        var e = new c,
            t = new c,
            i = new K;
        return function () {
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry, o = a.vertices, a = a.faces, s = 0, c = 0, h = a.length; h > c; c++) {
                var l = a[c],
                    u = l.normal;
                e.copy(o[l.a]).add(o[l.b]).add(o[l.c]).divideScalar(3).applyMatrix4(n), t.copy(u).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), r.setXYZ(s, e.x, e.y, e.z), s += 1, r.setXYZ(s, t.x, t.y, t.z), s += 1
            }
            r.needsUpdate = !0
        }
    }(), sa.prototype = Object.create(at.prototype), sa.prototype.constructor = sa, sa.prototype.dispose = function () {
        var e = this.children[0],
            t = this.children[1];
        e.geometry.dispose(), e.material.dispose(), t.geometry.dispose(), t.material.dispose()
    }, sa.prototype.update = function () {
        var e = new c,
            t = new c,
            i = new c;
        return function () {
            e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(t, e);
            var n = this.children[0],
                r = this.children[1];
            n.lookAt(i), n.material.color.copy(this.light.color), r.lookAt(i), r.scale.z = i.length()
        }
    }(), ca.prototype = Object.create(Ei.prototype), ca.prototype.constructor = ca, ca.prototype.update = function () {
        function e(e, a, o, s) {
            if (n.set(a, o, s).unproject(r), e = i[e], void 0 !== e)
                for (a = t.getAttribute("position"), o = 0, s = e.length; s > o; o++) a.setXYZ(e[o], n.x, n.y, n.z)
        }
        var t, i, n = new c,
            r = new ot;
        return function () {
            t = this.geometry, i = this.pointMap, r.projectionMatrix.copy(this.camera.projectionMatrix), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
        }
    }(), ha.prototype = Object.create(Ei.prototype), ha.prototype.constructor = ha, ha.prototype.update = function () {
        var e = new J;
        return function (t) {
            if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) {
                t = e.min;
                var i = e.max,
                    n = this.geometry.attributes.position,
                    r = n.array;
                r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = t.x, r[4] = i.y, r[5] = i.z, r[6] = t.x, r[7] = t.y, r[8] = i.z, r[9] = i.x, r[10] = t.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = t.z, r[15] = t.x, r[16] = i.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = i.x, r[22] = t.y, r[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }
    }(), ha.prototype.setFromObject = function (e) {
        return this.object = e, this.update(), this
    };
    var $a, eo;
    la.prototype = Object.create(at.prototype), la.prototype.constructor = la, la.prototype.setDirection = function () {
        var e, t = new c;
        return function (i) {
            .99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e))
        }
    }(), la.prototype.setLength = function (e, t, i) {
        void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
    }, la.prototype.setColor = function (e) {
        this.line.material.color.copy(e), this.cone.material.color.copy(e)
    }, ua.prototype = Object.create(Ei.prototype), ua.prototype.constructor = ua;
    var to = new c,
        io = new pa,
        no = new pa,
        ro = new pa;
    da.prototype = Object.create(pr.prototype), da.prototype.constructor = da, da.prototype.getPoint = function (e) {
        var t = this.points,
            i = t.length;
        e *= i - (this.closed ? 0 : 1);
        var n = Math.floor(e);
        e -= n, this.closed ? n += n > 0 ? 0 : (Math.floor(Math.abs(n) / t.length) + 1) * t.length : 0 === e && n === i - 1 && (n = i - 2, e = 1);
        var r, a, o;
        if (this.closed || n > 0 ? r = t[(n - 1) % i] : (to.subVectors(t[0], t[1]).add(t[0]), r = to), a = t[n % i], o = t[(n + 1) % i], this.closed || i > n + 2 ? t = t[(n + 2) % i] : (to.subVectors(t[i - 1], t[i - 2]).add(t[i - 1]), t = to), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
            var s = "chordal" === this.type ? .5 : .25,
                i = Math.pow(r.distanceToSquared(a), s),
                n = Math.pow(a.distanceToSquared(o), s),
                s = Math.pow(o.distanceToSquared(t), s);
            1e-4 > n && (n = 1), 1e-4 > i && (i = n), 1e-4 > s && (s = n), io.initNonuniformCatmullRom(r.x, a.x, o.x, t.x, i, n, s), no.initNonuniformCatmullRom(r.y, a.y, o.y, t.y, i, n, s), ro.initNonuniformCatmullRom(r.z, a.z, o.z, t.z, i, n, s)
        } else "catmullrom" === this.type && (i = void 0 !== this.tension ? this.tension : .5, io.initCatmullRom(r.x, a.x, o.x, t.x, i), no.initCatmullRom(r.y, a.y, o.y, t.y, i), ro.initCatmullRom(r.z, a.z, o.z, t.z, i));
        return new c(io.calc(e), no.calc(e), ro.calc(e))
    }, fa.prototype = Object.create(pr.prototype), fa.prototype.constructor = fa, fa.prototype.getPoint = function (e) {
        var t = this.v0,
            i = this.v1,
            n = this.v2,
            r = this.v3;
        return new c(ur(e, t.x, i.x, n.x, r.x), ur(e, t.y, i.y, n.y, r.y), ur(e, t.z, i.z, n.z, r.z))
    }, ma.prototype = Object.create(pr.prototype), ma.prototype.constructor = ma, ma.prototype.getPoint = function (e) {
        var t = this.v0,
            i = this.v1,
            n = this.v2;
        return new c(lr(e, t.x, i.x, n.x), lr(e, t.y, i.y, n.y), lr(e, t.z, i.z, n.z))
    }, ga.prototype = Object.create(pr.prototype), ga.prototype.constructor = ga, ga.prototype.getPoint = function (e) {
        if (1 === e) return this.v2.clone();
        var t = new c;
        return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t
    }, va.prototype = Object.create(mr.prototype), va.prototype.constructor = va, pr.create = function (e, t) {
        return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(pr.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
    }, ya.prototype = Object.create(da.prototype), xa.prototype = Object.create(da.prototype), ba.prototype = Object.create(da.prototype), Object.assign(ba.prototype, {
        initFromArray: function () {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function () {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function () {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), ra.prototype.setColors = function () {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, ea.prototype.update = function () {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(j.prototype, {
        center: function (e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function () {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function (e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        size: function (e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Object.assign(J.prototype, {
        center: function (e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function () {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function (e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionSphere: function (e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        },
        size: function (e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Pt.prototype.center = function (e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
    }, _a.random16 = function () {
        return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random()
    }, Object.assign(K.prototype, {
        flattenToArrayOffset: function (e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        multiplyVector3: function (e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
        },
        multiplyVector3Array: function () {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function (e) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function () {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(h.prototype, {
        extractPosition: function (e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        },
        flattenToArrayOffset: function (e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        getPosition: function () {
            var e;
            return function () {
                return void 0 === e && (e = new c), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function (e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function (e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector4: function (e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector3Array: function () {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function (e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
        },
        crossVector: function (e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        translate: function () {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function (e) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function () {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function (e, t, i, n, r, a) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, i, r, a)
        }
    }), $.prototype.isIntersectionLine = function (e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
    }, s.prototype.multiplyVector3 = function (e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
    }, Object.assign(Lt.prototype, {
        isIntersectionBox: function (e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionPlane: function (e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
        },
        isIntersectionSphere: function (e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        }
    }), Object.assign(br.prototype, {
        extrude: function (e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Ki(this, e)
        },
        makeGeometry: function (e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new hn(this, e)
        }
    }), Object.assign(i.prototype, {
        fromAttribute: function (e, t, i) {
            return console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        }
    }), Object.assign(c.prototype, {
        setEulerFromRotationMatrix: function () {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function () {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function (e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function (e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function (e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        },
        applyProjection: function (e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
        },
        fromAttribute: function (e, t, i) {
            return console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        }
    }), Object.assign(r.prototype, {
        fromAttribute: function (e, t, i) {
            return console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        }
    }), lt.prototype.computeTangents = function () {
        console.warn("THREE.Geometry: .computeTangents() has been removed.")
    }, Object.assign(at.prototype, {
        getChildByName: function (e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
        },
        renderDepth: function () {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function (e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
        }
    }), Object.defineProperties(at.prototype, {
        eulerOrder: {
            get: function () {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function (e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(yi.prototype, {
        objects: {
            get: function () {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(xi.prototype, "useVertexTexture", {
        get: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), Object.defineProperty(pr.prototype, "__arcLengthDivisions", {
        get: function () {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function (e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
        }
    }), ct.prototype.setLens = function (e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
    }, Object.defineProperties(Nn.prototype, {
        onlyShadow: {
            set: function () {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function () {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function (e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function () {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function (e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function (e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
            }
        }
    }), Object.defineProperties(ut.prototype, {
        length: {
            get: function () {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        }
    }), Object.assign(Mt.prototype, {
        addIndex: function (e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
        },
        addDrawCall: function (e, t, i) {
            void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
        },
        clearDrawCalls: function () {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function () {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function () {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(Mt.prototype, {
        drawcalls: {
            get: function () {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function () {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.defineProperties(Fr.prototype, {
        dynamic: {
            set: function () {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function () {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(q.prototype, {
        wrapAround: {
            get: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        wrapRGB: {
            get: function () {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new k
            }
        }
    }), Object.defineProperties(wn.prototype, {
        metal: {
            get: function () {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function () {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(Y.prototype, {
        derivatives: {
            get: function () {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function (e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
            }
        }
    }), Object.assign(ui.prototype, {
        getCurrentRenderTarget: function () {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        supportsFloatTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function () {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function () {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function () {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function (e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
        },
        initMaterial: function () {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function () {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
    }), Object.defineProperties(ui.prototype, {
        shadowMapEnabled: {
            get: function () {
                return this.shadowMap.enabled
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function () {
                return this.shadowMap.type
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function () {
                return this.shadowMap.cullFace
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = e
            }
        }
    }), Object.defineProperties(tt.prototype, {
        cullFace: {
            get: function () {
                return this.renderReverseSided ? 2 : 1
            },
            set: function (e) {
                e = 1 !== e, console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + e + "."), this.renderReverseSided = e
            }
        }
    }), Object.defineProperties(a.prototype, {
        wrapS: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
            }
        },
        offset: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
            }
        },
        repeat: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
            }
        },
        format: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
            }
        },
        type: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
            }
        }
    }), Rr.prototype.load = function (e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t = this;
        return (new Er).load(e, function (e) {
            t.setBuffer(e)
        }), this
    }, Pr.prototype.getData = function () {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, e.WebGLRenderTargetCube = o, e.WebGLRenderTarget = a, e.WebGLRenderer = ui, e.ShaderLib = Na, e.UniformsLib = Ca, e.UniformsUtils = Ia, e.ShaderChunk = Ua, e.FogExp2 = pi, e.Fog = di, e.Scene = fi, e.LensFlare = mi, e.Sprite = vi, e.LOD = yi, e.SkinnedMesh = _i, e.Skeleton = xi, e.Bone = bi, e.Mesh = It, e.LineSegments = Ei, e.LineLoop = Ti, e.Line = Mi, e.Points = Ai, e.Group = Ri, e.VideoTexture = Li, e.DataTexture = l, e.CompressedTexture = Pi, e.CubeTexture = u, e.CanvasTexture = Ci, e.DepthTexture = Ii, e.Texture = n, e.CompressedTextureLoader = Ln, e.DataTextureLoader = Pn, e.CubeTextureLoader = In, e.TextureLoader = Un, e.ObjectLoader = cr, e.MaterialLoader = rr, e.BufferGeometryLoader = ar, e.DefaultLoadingManager = ka, e.LoadingManager = An, e.JSONLoader = sr, e.ImageLoader = Cn, e.FontLoader = Mr, e.FileLoader = Rn, e.Loader = or, e.Cache = Va, e.AudioLoader = Er, e.SpotLightShadow = Fn, e.SpotLight = Bn, e.PointLight = zn, e.RectAreaLight = kn, e.HemisphereLight = Dn, e.DirectionalLightShadow = Gn, e.DirectionalLight = Hn, e.AmbientLight = Vn, e.LightShadow = On, e.Light = Nn, e.StereoCamera = Tr, e.PerspectiveCamera = ct, e.OrthographicCamera = st, e.CubeCamera = Sr, e.ArrayCamera = si, e.Camera = ot, e.AudioListener = Ar, e.PositionalAudio = Lr, e.AudioContext = Ka, e.AudioAnalyser = Pr, e.Audio = Rr, e.VectorKeyframeTrack = Zn, e.StringKeyframeTrack = $n, e.QuaternionKeyframeTrack = Qn, e.NumberKeyframeTrack = Kn, e.ColorKeyframeTrack = tr, e.BooleanKeyframeTrack = er, e.PropertyMixer = Cr, e.PropertyBinding = Ur, e.KeyframeTrack = ir, e.AnimationUtils = ja, e.AnimationObjectGroup = Nr, e.AnimationMixer = Or, e.AnimationClip = nr, e.Uniform = Fr, e.InstancedBufferGeometry = Br, e.BufferGeometry = Mt, e.GeometryIdCount = function () {
        return Fa++
    }, e.Geometry = lt, e.InterleavedBufferAttribute = zr, e.InstancedInterleavedBuffer = Hr, e.InterleavedBuffer = Gr, e.InstancedBufferAttribute = Vr, e.Face3 = ht, e.Object3D = at, e.Raycaster = kr, e.Layers = rt, e.EventDispatcher = t, e.Clock = Xr, e.QuaternionLinearInterpolant = Jn, e.LinearInterpolant = Xn, e.DiscreteInterpolant = qn, e.CubicInterpolant = Wn, e.Interpolant = jn, e.Triangle = Ct, e.Math = _a, e.Spherical = qr, e.Cylindrical = Yr, e.Plane = $, e.Frustum = et, e.Sphere = Q, e.Ray = Lt, e.Matrix4 = h, e.Matrix3 = K, e.Box3 = J, e.Box2 = j, e.Line3 = Pt, e.Euler = nt, e.Vector4 = r, e.Vector3 = c, e.Vector2 = i, e.Quaternion = s, e.Color = k, e.MorphBlendMesh = Zr, e.ImmediateRenderObject = Jr, e.VertexNormalsHelper = Qr, e.SpotLightHelper = Kr, e.SkeletonHelper = ea, e.PointLightHelper = ta, e.RectAreaLightHelper = ia, e.HemisphereLightHelper = na, e.GridHelper = ra, e.PolarGridHelper = aa, e.FaceNormalsHelper = oa, e.DirectionalLightHelper = sa, e.CameraHelper = ca, e.BoxHelper = ha, e.ArrowHelper = la, e.AxisHelper = ua, e.CatmullRomCurve3 = da, e.CubicBezierCurve3 = fa, e.QuadraticBezierCurve3 = ma, e.LineCurve3 = ga, e.ArcCurve = va, e.EllipseCurve = mr, e.SplineCurve = gr, e.CubicBezierCurve = vr, e.QuadraticBezierCurve = yr, e.LineCurve = dr, e.Shape = br, e.Path = xr, e.ShapePath = _r, e.Font = wr, e.CurvePath = fr, e.Curve = pr, e.ShapeUtils = za, e.SceneUtils = {
        createMultiMaterialObject: function (e, t) {
            for (var i = new Ri, n = 0, r = t.length; r > n; n++) i.add(new It(e, t[n]));
            return i
        },
        detach: function (e, t, i) {
            e.applyMatrix(t.matrixWorld), t.remove(e), i.add(e)
        },
        attach: function (e, t, i) {
            e.applyMatrix((new h).getInverse(i.matrixWorld)), t.remove(e), i.add(e)
        }
    }, e.WireframeGeometry = Ui, e.ParametricGeometry = Ni, e.ParametricBufferGeometry = Di, e.TetrahedronGeometry = Bi, e.TetrahedronBufferGeometry = zi, e.OctahedronGeometry = Gi, e.OctahedronBufferGeometry = Hi, e.IcosahedronGeometry = Vi, e.IcosahedronBufferGeometry = ki, e.DodecahedronGeometry = ji, e.DodecahedronBufferGeometry = Wi, e.PolyhedronGeometry = Oi, e.PolyhedronBufferGeometry = Fi, e.TubeGeometry = Xi, e.TubeBufferGeometry = qi, e.TorusKnotGeometry = Yi, e.TorusKnotBufferGeometry = Zi, e.TorusGeometry = Ji, e.TorusBufferGeometry = Qi, e.TextGeometry = en, e.TextBufferGeometry = tn, e.SphereGeometry = nn, e.SphereBufferGeometry = rn, e.RingGeometry = an, e.RingBufferGeometry = on, e.PlaneGeometry = St, e.PlaneBufferGeometry = At, e.LatheGeometry = sn, e.LatheBufferGeometry = cn, e.ShapeGeometry = hn, e.ShapeBufferGeometry = ln, e.ExtrudeGeometry = Ki, e.ExtrudeBufferGeometry = $i, e.EdgesGeometry = un, e.ConeGeometry = fn, e.ConeBufferGeometry = mn, e.CylinderGeometry = pn, e.CylinderBufferGeometry = dn, e.CircleGeometry = gn, e.CircleBufferGeometry = vn, e.BoxGeometry = Et, e.BoxBufferGeometry = Tt, e.ShadowMaterial = yn, e.SpriteMaterial = gi, e.RawShaderMaterial = xn, e.ShaderMaterial = Y, e.PointsMaterial = Si, e.MeshPhysicalMaterial = _n, e.MeshStandardMaterial = bn, e.MeshPhongMaterial = wn, e.MeshToonMaterial = Mn, e.MeshNormalMaterial = En, e.MeshLambertMaterial = Tn, e.MeshDepthMaterial = Z, e.MeshBasicMaterial = Rt, e.LineDashedMaterial = Sn, e.LineBasicMaterial = wi, e.Material = q, e.Float64BufferAttribute = bt, e.Float32BufferAttribute = xt, e.Uint32BufferAttribute = yt, e.Int32BufferAttribute = vt, e.Uint16BufferAttribute = gt, e.Int16BufferAttribute = mt, e.Uint8ClampedBufferAttribute = ft, e.Uint8BufferAttribute = dt, e.Int8BufferAttribute = pt, e.BufferAttribute = ut, e.REVISION = "86", e.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, e.CullFaceNone = 0, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.FrontFaceDirectionCW = 0, e.FrontFaceDirectionCCW = 1, e.BasicShadowMap = 0, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.FrontSide = 0, e.BackSide = 1, e.DoubleSide = 2, e.FlatShading = 1, e.SmoothShading = 2, e.NoColors = 0, e.FaceColors = 1, e.VertexColors = 2, e.NoBlending = 0, e.NormalBlending = 1, e.AdditiveBlending = 2, e.SubtractiveBlending = 3, e.MultiplyBlending = 4, e.CustomBlending = 5, e.AddEquation = 100, e.SubtractEquation = 101, e.ReverseSubtractEquation = 102, e.MinEquation = 103, e.MaxEquation = 104, e.ZeroFactor = 200, e.OneFactor = 201, e.SrcColorFactor = 202, e.OneMinusSrcColorFactor = 203, e.SrcAlphaFactor = 204, e.OneMinusSrcAlphaFactor = 205, e.DstAlphaFactor = 206, e.OneMinusDstAlphaFactor = 207, e.DstColorFactor = 208, e.OneMinusDstColorFactor = 209, e.SrcAlphaSaturateFactor = 210, e.NeverDepth = 0, e.AlwaysDepth = 1, e.LessDepth = 2, e.LessEqualDepth = 3, e.EqualDepth = 4, e.GreaterEqualDepth = 5, e.GreaterDepth = 6, e.NotEqualDepth = 7, e.MultiplyOperation = 0, e.MixOperation = 1, e.AddOperation = 2, e.NoToneMapping = 0, e.LinearToneMapping = 1, e.ReinhardToneMapping = 2, e.Uncharted2ToneMapping = 3, e.CineonToneMapping = 4, e.UVMapping = 300, e.CubeReflectionMapping = 301, e.CubeRefractionMapping = 302, e.EquirectangularReflectionMapping = 303, e.EquirectangularRefractionMapping = 304, e.SphericalReflectionMapping = 305, e.CubeUVReflectionMapping = 306, e.CubeUVRefractionMapping = 307, e.RepeatWrapping = 1e3, e.ClampToEdgeWrapping = 1001, e.MirroredRepeatWrapping = 1002, e.NearestFilter = 1003, e.NearestMipMapNearestFilter = 1004, e.NearestMipMapLinearFilter = 1005, e.LinearFilter = 1006, e.LinearMipMapNearestFilter = 1007, e.LinearMipMapLinearFilter = 1008, e.UnsignedByteType = 1009, e.ByteType = 1010, e.ShortType = 1011, e.UnsignedShortType = 1012, e.IntType = 1013, e.UnsignedIntType = 1014, e.FloatType = 1015, e.HalfFloatType = 1016, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e.UnsignedInt248Type = 1020, e.AlphaFormat = 1021, e.RGBFormat = 1022, e.RGBAFormat = 1023, e.LuminanceFormat = 1024, e.LuminanceAlphaFormat = 1025, e.RGBEFormat = 1023, e.DepthFormat = 1026, e.DepthStencilFormat = 1027, e.RGB_S3TC_DXT1_Format = 2001, e.RGBA_S3TC_DXT1_Format = 2002, e.RGBA_S3TC_DXT3_Format = 2003, e.RGBA_S3TC_DXT5_Format = 2004, e.RGB_PVRTC_4BPPV1_Format = 2100, e.RGB_PVRTC_2BPPV1_Format = 2101, e.RGBA_PVRTC_4BPPV1_Format = 2102, e.RGBA_PVRTC_2BPPV1_Format = 2103, e.RGB_ETC1_Format = 2151, e.LoopOnce = 2200, e.LoopRepeat = 2201, e.LoopPingPong = 2202, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.InterpolateSmooth = 2302, e.ZeroCurvatureEnding = 2400, e.ZeroSlopeEnding = 2401, e.WrapAroundEnding = 2402, e.TrianglesDrawMode = 0, e.TriangleStripDrawMode = 1, e.TriangleFanDrawMode = 2, e.LinearEncoding = 3e3, e.sRGBEncoding = 3001, e.GammaEncoding = 3007, e.RGBEEncoding = 3002, e.LogLuvEncoding = 3003, e.RGBM7Encoding = 3004, e.RGBM16Encoding = 3005, e.RGBDEncoding = 3006, e.BasicDepthPacking = 3200, e.RGBADepthPacking = 3201, e.CubeGeometry = Et, e.Face4 = function (e, t, i, n, r, a, o) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new ht(e, t, i, r, a, o)
    }, e.LineStrip = 0, e.LinePieces = 1, e.MeshFaceMaterial = function (e) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
    }, e.MultiMaterial = function (e) {
        return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function () {
            return e.slice()
        }, e
    }, e.PointCloud = function (e, t) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ai(e, t)
    }, e.Particle = function (e) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new vi(e)
    }, e.ParticleSystem = function (e, t) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ai(e, t)
    }, e.PointCloudMaterial = function (e) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Si(e)
    }, e.ParticleBasicMaterial = function (e) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Si(e)
    }, e.ParticleSystemMaterial = function (e) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Si(e)
    }, e.Vertex = function (e, t, i) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new c(e, t, i)
    }, e.DynamicBufferAttribute = function (e, t) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new ut(e, t).setDynamic(!0)
    }, e.Int8Attribute = function (e, t) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new pt(e, t)
    }, e.Uint8Attribute = function (e, t) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new dt(e, t)
    }, e.Uint8ClampedAttribute = function (e, t) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new ft(e, t)
    }, e.Int16Attribute = function (e, t) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new mt(e, t)
    }, e.Uint16Attribute = function (e, t) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new gt(e, t)
    }, e.Int32Attribute = function (e, t) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new vt(e, t)
    }, e.Uint32Attribute = function (e, t) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new yt(e, t)
    }, e.Float32Attribute = function (e, t) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new xt(e, t)
    }, e.Float64Attribute = function (e, t) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new bt(e, t)
    }, e.ClosedSplineCurve3 = ya, e.SplineCurve3 = xa, e.Spline = ba, e.BoundingBoxHelper = function (e, t) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new ha(e, t)
    }, e.EdgesHelper = function (e, t) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ei(new un(e.geometry), new wi({
            color: void 0 !== t ? t : 16777215
        }))
    }, e.WireframeHelper = function (e, t) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ei(new Ui(e.geometry), new wi({
            color: void 0 !== t ? t : 16777215
        }))
    }, e.XHRLoader = function (e) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Rn(e)
    }, e.BinaryTextureLoader = function (e) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Pn(e)
    }, e.GeometryUtils = {
        merge: function (e, t, i) {
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
            var n;
            t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), n = t.matrix, t = t.geometry), e.merge(t, n, i)
        },
        center: function (e) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
        }
    }, e.ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function (e, t, i, n) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var r = new Un;
            return r.setCrossOrigin(this.crossOrigin), e = r.load(e, i, void 0, n), t && (e.mapping = t), e
        },
        loadTextureCube: function (e, t, i, n) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var r = new In;
            return r.setCrossOrigin(this.crossOrigin), e = r.load(e, i, void 0, n), t && (e.mapping = t), e
        },
        loadCompressedTexture: function () {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        },
        loadCompressedTextureCube: function () {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }
    }, e.Projector = function () {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (e, t) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t)
        }, this.unprojectVector = function (e, t) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t)
        }, this.pickingRay = function () {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }, e.CanvasRenderer = function () {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function () {}, this.render = function () {}, this.setClearColor = function () {}, this.setSize = function () {}
    }, Object.defineProperty(e, "__esModule", {
        value: !0
    })
});
THREE.OrbitControls = function (e, t) {
    function n() {
        return 2 * Math.PI / 60 / 60 * k.autoRotateSpeed
    }

    function o() {
        return Math.pow(.95, k.zoomSpeed)
    }

    function a(e) {
        z.theta -= e
    }

    function i(e) {
        z.phi -= e
    }

    function r(e) {
        k.object instanceof THREE.PerspectiveCamera ? F /= e : k.object instanceof THREE.OrthographicCamera ? (k.object.zoom = Math.max(k.minZoom, Math.min(k.maxZoom, k.object.zoom * e)), k.object.updateProjectionMatrix(), X = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), k.enableZoom = !1)
    }

    function s(e) {
        k.object instanceof THREE.PerspectiveCamera ? F *= e : k.object instanceof THREE.OrthographicCamera ? (k.object.zoom = Math.max(k.minZoom, Math.min(k.maxZoom, k.object.zoom / e)), k.object.updateProjectionMatrix(), X = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), k.enableZoom = !1)
    }

    function c(e) {
        K.set(e.clientX, e.clientY)
    }

    function u(e) {
        Q.set(e.clientX, e.clientY)
    }

    function m(e) {
        G.set(e.clientX, e.clientY)
    }

    function d(e) {
        _.set(e.clientX, e.clientY), B.subVectors(_, K);
        var t = k.domElement === document ? k.domElement.body : k.domElement;
        a(2 * Math.PI * B.x / t.clientWidth * k.rotateSpeed), i(2 * Math.PI * B.y / t.clientHeight * k.rotateSpeed), K.copy(_), k.update()
    }

    function l(e) {
        J.set(e.clientX, e.clientY), $.subVectors(J, Q), $.y > 0 ? r(o()) : $.y < 0 && s(o()), Q.copy(J), k.update()
    }

    function E(e) {
        W.set(e.clientX, e.clientY), q.subVectors(W, G), nt(q.x, q.y), G.copy(W), k.update()
    }

    function h() {}

    function p(e) {
        e.deltaY < 0 ? s(o()) : e.deltaY > 0 && r(o()), k.update()
    }

    function b(e) {
        switch (e.keyCode) {
            case k.keys.UP:
                nt(0, k.keyPanSpeed), k.update();
                break;
            case k.keys.BOTTOM:
                nt(0, -k.keyPanSpeed), k.update();
                break;
            case k.keys.LEFT:
                nt(k.keyPanSpeed, 0), k.update();
                break;
            case k.keys.RIGHT:
                nt(-k.keyPanSpeed, 0), k.update()
        }
    }

    function f(e) {
        K.set(e.touches[0].pageX, e.touches[0].pageY)
    }

    function T(e) {
        var t = e.touches[0].pageX - e.touches[1].pageX,
            n = e.touches[0].pageY - e.touches[1].pageY,
            o = Math.sqrt(t * t + n * n);
        Q.set(0, o)
    }

    function g(e) {
        G.set(e.touches[0].pageX, e.touches[0].pageY)
    }

    function R(e) {
        _.set(e.touches[0].pageX, e.touches[0].pageY), B.subVectors(_, K);
        var t = k.domElement === document ? k.domElement.body : k.domElement;
        a(2 * Math.PI * B.x / t.clientWidth * k.rotateSpeed), i(2 * Math.PI * B.y / t.clientHeight * k.rotateSpeed), K.copy(_), k.update()
    }

    function v(e) {
        var t = e.touches[0].pageX - e.touches[1].pageX,
            n = e.touches[0].pageY - e.touches[1].pageY,
            a = Math.sqrt(t * t + n * n);
        J.set(0, a), $.subVectors(J, Q), $.y > 0 ? s(o()) : $.y < 0 && r(o()), Q.copy(J), k.update()
    }

    function O(e) {
        W.set(e.touches[0].pageX, e.touches[0].pageY), q.subVectors(W, G), nt(q.x, q.y), G.copy(W), k.update()
    }

    function y() {}

    function H(e) {
        if (k.enabled !== !1) {
            switch (e.preventDefault(), e.button) {
                case k.mouseButtons.ORBIT:
                    if (k.enableRotate === !1) return;
                    c(e), V = S.ROTATE;
                    break;
                case k.mouseButtons.ZOOM:
                    if (k.enableZoom === !1) return;
                    u(e), V = S.DOLLY;
                    break;
                case k.mouseButtons.PAN:
                    if (k.enablePan === !1) return;
                    m(e), V = S.PAN
            }
            V !== S.NONE && (document.addEventListener("mousemove", w, !1), document.addEventListener("mouseup", P, !1), k.dispatchEvent(D))
        }
    }

    function w(e) {
        if (k.enabled !== !1) switch (e.preventDefault(), V) {
            case S.ROTATE:
                if (k.enableRotate === !1) return;
                d(e);
                break;
            case S.DOLLY:
                if (k.enableZoom === !1) return;
                l(e);
                break;
            case S.PAN:
                if (k.enablePan === !1) return;
                E(e)
        }
    }

    function P(e) {
        k.enabled !== !1 && (h(e), document.removeEventListener("mousemove", w, !1), document.removeEventListener("mouseup", P, !1), k.dispatchEvent(U), V = S.NONE)
    }

    function j(e) {
        k.enabled === !1 || k.enableZoom === !1 || V !== S.NONE && V !== S.ROTATE || (e.preventDefault(), e.stopPropagation(), p(e), k.dispatchEvent(D), k.dispatchEvent(U))
    }

    function C(e) {
        k.enabled !== !1 && k.enableKeys !== !1 && k.enablePan !== !1 && b(e)
    }

    function M(e) {
        if (k.enabled !== !1) {
            switch (e.touches.length) {
                case 1:
                    if (k.enableRotate === !1) return;
                    f(e), V = S.TOUCH_ROTATE;
                    break;
                case 2:
                    if (k.enableZoom === !1) return;
                    T(e), V = S.TOUCH_DOLLY;
                    break;
                case 3:
                    if (k.enablePan === !1) return;
                    g(e), V = S.TOUCH_PAN;
                    break;
                default:
                    V = S.NONE
            }
            V !== S.NONE && k.dispatchEvent(D)
        }
    }

    function L(e) {
        if (k.enabled !== !1) switch (e.preventDefault(), e.stopPropagation(), e.touches.length) {
            case 1:
                if (k.enableRotate === !1) return;
                if (V !== S.TOUCH_ROTATE) return;
                R(e);
                break;
            case 2:
                if (k.enableZoom === !1) return;
                if (V !== S.TOUCH_DOLLY) return;
                v(e);
                break;
            case 3:
                if (k.enablePan === !1) return;
                if (V !== S.TOUCH_PAN) return;
                O(e);
                break;
            default:
                V = S.NONE
        }
    }

    function N(e) {
        k.enabled !== !1 && (y(e), k.dispatchEvent(U), V = S.NONE)
    }

    function A(e) {
        k.enabled !== !1 && e.preventDefault()
    }
    this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.target = new THREE.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40
    }, this.mouseButtons = {
        ORBIT: THREE.MOUSE.LEFT,
        ZOOM: THREE.MOUSE.MIDDLE,
        PAN: THREE.MOUSE.RIGHT
    }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function () {
        return Y.phi
    }, this.getAzimuthalAngle = function () {
        return Y.theta
    }, this.saveState = function () {
        k.target0.copy(k.target), k.position0.copy(k.object.position), k.zoom0 = k.object.zoom
    }, this.reset = function () {
        k.target.copy(k.target0), k.object.position.copy(k.position0), k.object.zoom = k.zoom0, k.object.updateProjectionMatrix(), k.dispatchEvent(x), k.update(), V = S.NONE
    }, this.update = function () {
        var t = new THREE.Vector3,
            o = (new THREE.Quaternion).setFromUnitVectors(e.up, new THREE.Vector3(0, 1, 0)),
            i = o.clone().inverse(),
            r = new THREE.Vector3,
            s = new THREE.Quaternion;
        return function () {
            var e = k.object.position;
            return t.copy(e).sub(k.target), t.applyQuaternion(o), Y.setFromVector3(t), k.autoRotate && V === S.NONE && a(n()), Y.theta += z.theta, Y.phi += z.phi, Y.theta = Math.max(k.minAzimuthAngle, Math.min(k.maxAzimuthAngle, Y.theta)), Y.phi = Math.max(k.minPolarAngle, Math.min(k.maxPolarAngle, Y.phi)), Y.makeSafe(), Y.radius *= F, Y.radius = Math.max(k.minDistance, Math.min(k.maxDistance, Y.radius)), k.target.add(I), t.setFromSpherical(Y), t.applyQuaternion(i), e.copy(k.target).add(t), k.object.lookAt(k.target), k.enableDamping === !0 ? (z.theta *= 1 - k.dampingFactor, z.phi *= 1 - k.dampingFactor) : z.set(0, 0, 0), F = 1, I.set(0, 0, 0), X || r.distanceToSquared(k.object.position) > Z || 8 * (1 - s.dot(k.object.quaternion)) > Z ? (k.dispatchEvent(x), r.copy(k.object.position), s.copy(k.object.quaternion), X = !1, !0) : !1
        }
    }(), this.dispose = function () {
        k.domElement.removeEventListener("contextmenu", A, !1), k.domElement.removeEventListener("mousedown", H, !1), k.domElement.removeEventListener("wheel", j, !1), k.domElement.removeEventListener("touchstart", M, !1), k.domElement.removeEventListener("touchend", N, !1), k.domElement.removeEventListener("touchmove", L, !1), document.removeEventListener("mousemove", w, !1), document.removeEventListener("mouseup", P, !1), window.removeEventListener("keydown", C, !1)
    };
    var k = this,
        x = {
            type: "change"
        },
        D = {
            type: "start"
        },
        U = {
            type: "end"
        },
        S = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_DOLLY: 4,
            TOUCH_PAN: 5
        },
        V = S.NONE,
        Z = 1e-6,
        Y = new THREE.Spherical,
        z = new THREE.Spherical,
        F = 1,
        I = new THREE.Vector3,
        X = !1,
        K = new THREE.Vector2,
        _ = new THREE.Vector2,
        B = new THREE.Vector2,
        G = new THREE.Vector2,
        W = new THREE.Vector2,
        q = new THREE.Vector2,
        Q = new THREE.Vector2,
        J = new THREE.Vector2,
        $ = new THREE.Vector2,
        et = function () {
            var e = new THREE.Vector3;
            return function (t, n) {
                e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), I.add(e)
            }
        }(),
        tt = function () {
            var e = new THREE.Vector3;
            return function (t, n) {
                e.setFromMatrixColumn(n, 1), e.multiplyScalar(t), I.add(e)
            }
        }(),
        nt = function () {
            var e = new THREE.Vector3;
            return function (t, n) {
                var o = k.domElement === document ? k.domElement.body : k.domElement;
                if (k.object instanceof THREE.PerspectiveCamera) {
                    var a = k.object.position;
                    e.copy(a).sub(k.target);
                    var i = e.length();
                    i *= Math.tan(k.object.fov / 2 * Math.PI / 180), et(2 * t * i / o.clientHeight, k.object.matrix), tt(2 * n * i / o.clientHeight, k.object.matrix)
                } else k.object instanceof THREE.OrthographicCamera ? (et(t * (k.object.right - k.object.left) / k.object.zoom / o.clientWidth, k.object.matrix), tt(n * (k.object.top - k.object.bottom) / k.object.zoom / o.clientHeight, k.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), k.enablePan = !1)
            }
        }();
    k.domElement.addEventListener("contextmenu", A, !1), k.domElement.addEventListener("mousedown", H, !1), k.domElement.addEventListener("wheel", j, !1), k.domElement.addEventListener("touchstart", M, !1), k.domElement.addEventListener("touchend", N, !1), k.domElement.addEventListener("touchmove", L, !1), window.addEventListener("keydown", C, !1), this.update()
}, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype), THREE.OrbitControls.prototype.constructor = THREE.OrbitControls, Object.defineProperties(THREE.OrbitControls.prototype, {
    center: {
        get: function () {
            return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target
        }
    },
    noZoom: {
        get: function () {
            return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
        },
        set: function (e) {
            console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !e
        }
    },
    noRotate: {
        get: function () {
            return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
        },
        set: function (e) {
            console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !e
        }
    },
    noPan: {
        get: function () {
            return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
        },
        set: function (e) {
            console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !e
        }
    },
    noKeys: {
        get: function () {
            return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
        },
        set: function (e) {
            console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !e
        }
    },
    staticMoving: {
        get: function () {
            return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
        },
        set: function (e) {
            console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !e
        }
    },
    dynamicDampingFactor: {
        get: function () {
            return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor
        },
        set: function (e) {
            console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = e
        }
    }
});